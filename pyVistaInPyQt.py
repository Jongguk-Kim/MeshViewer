# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'blankWindow.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import os, math, time 
try: 
    from PyQt5 import QtCore, QtGui, QtWidgets
except: 
    os.system("pip install PyQt5")

try: 
    import numpy as np 
except: 
    os.system("pip install numpy")

# from click import progressbar

import pyVista as Mesh 


try: 
    from pyvistaqt import QtInteractor, MainWindow
except: 
    os.system("pip install pyvistaqt")



colors=['linen', 
    'silver', 'gray', 'linen', \
    'tan', 'teal', 'orange', 'blue', \
        'yellow', 'red', 'black']

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1210, 685)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.gridLayout.addLayout(self.verticalLayout, 1, 0, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout_solid_Jaco_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_solid_Jaco_2.setObjectName("verticalLayout_solid_Jaco_2")
        self.pushButton_openfile = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_openfile.setMaximumSize(QtCore.QSize(120, 30))
        self.pushButton_openfile.setObjectName("pushButton_openfile")
        self.verticalLayout_solid_Jaco_2.addWidget(self.pushButton_openfile)
        self.pushButton_add_Mesh = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_add_Mesh.setMinimumSize(QtCore.QSize(120, 0))
        self.pushButton_add_Mesh.setMaximumSize(QtCore.QSize(120, 30))
        self.pushButton_add_Mesh.setObjectName("pushButton_add_Mesh")
        self.verticalLayout_solid_Jaco_2.addWidget(self.pushButton_add_Mesh)
        self.lineEdit_temp = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_temp.setMaximumSize(QtCore.QSize(120, 20))
        self.lineEdit_temp.setObjectName("lineEdit_temp")
        self.verticalLayout_solid_Jaco_2.addWidget(self.lineEdit_temp)
        self.horizontalLayout.addLayout(self.verticalLayout_solid_Jaco_2)
        self.verticalLayout_color = QtWidgets.QVBoxLayout()
        self.verticalLayout_color.setObjectName("verticalLayout_color")
        self.comboBox = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox.setMinimumSize(QtCore.QSize(80, 25))
        self.comboBox.setMaximumSize(QtCore.QSize(100, 25))
        self.comboBox.setObjectName("comboBox")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.verticalLayout_color.addWidget(self.comboBox)
        self.checkBox_colorChanging = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_colorChanging.setMaximumSize(QtCore.QSize(80, 15))
        self.checkBox_colorChanging.setObjectName("checkBox_colorChanging")
        self.verticalLayout_color.addWidget(self.checkBox_colorChanging)
        self.pushButton_replaceCells = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_replaceCells.setMaximumSize(QtCore.QSize(100, 25))
        self.pushButton_replaceCells.setObjectName("pushButton_replaceCells")
        self.verticalLayout_color.addWidget(self.pushButton_replaceCells)
        self.pushButton_SaveSfricSurface = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_SaveSfricSurface.setMaximumSize(QtCore.QSize(100, 25))
        self.pushButton_SaveSfricSurface.setObjectName("pushButton_SaveSfricSurface")
        self.verticalLayout_color.addWidget(self.pushButton_SaveSfricSurface)
        self.horizontalLayout.addLayout(self.verticalLayout_color)
        self.verticalLayout_Opecity = QtWidgets.QVBoxLayout()
        self.verticalLayout_Opecity.setObjectName("verticalLayout_Opecity")
        self.checkBox_meshLine = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_meshLine.setMaximumSize(QtCore.QSize(90, 30))
        self.checkBox_meshLine.setChecked(True)
        self.checkBox_meshLine.setObjectName("checkBox_meshLine")
        self.verticalLayout_Opecity.addWidget(self.checkBox_meshLine)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setContentsMargins(0, -1, -1, -1)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label_opecity = QtWidgets.QLabel(self.centralwidget)
        self.label_opecity.setMaximumSize(QtCore.QSize(50, 15))
        self.label_opecity.setAlignment(QtCore.Qt.AlignCenter)
        self.label_opecity.setObjectName("label_opecity")
        self.horizontalLayout_2.addWidget(self.label_opecity)
        self.lineEdit_opecity = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_opecity.setMaximumSize(QtCore.QSize(30, 20))
        self.lineEdit_opecity.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_opecity.setObjectName("lineEdit_opecity")
        self.horizontalLayout_2.addWidget(self.lineEdit_opecity)
        self.verticalLayout_Opecity.addLayout(self.horizontalLayout_2)
        self.horizontalSlider_opacity = QtWidgets.QSlider(self.centralwidget)
        self.horizontalSlider_opacity.setMaximumSize(QtCore.QSize(90, 15))
        self.horizontalSlider_opacity.setMaximum(100)
        self.horizontalSlider_opacity.setSingleStep(5)
        self.horizontalSlider_opacity.setProperty("value", 100)
        self.horizontalSlider_opacity.setOrientation(QtCore.Qt.Horizontal)
        self.horizontalSlider_opacity.setObjectName("horizontalSlider_opacity")
        self.verticalLayout_Opecity.addWidget(self.horizontalSlider_opacity)
        self.horizontalLayout.addLayout(self.verticalLayout_Opecity)
        self.verticalLayout_edges = QtWidgets.QVBoxLayout()
        self.verticalLayout_edges.setObjectName("verticalLayout_edges")
        self.horizontalLayout.addLayout(self.verticalLayout_edges)
        self.verticalLayout_solid_Jaco = QtWidgets.QVBoxLayout()
        self.verticalLayout_solid_Jaco.setObjectName("verticalLayout_solid_Jaco")
        self.checkBox_showEdges = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_showEdges.setMaximumSize(QtCore.QSize(60, 15))
        self.checkBox_showEdges.setObjectName("checkBox_showEdges")
        self.verticalLayout_solid_Jaco.addWidget(self.checkBox_showEdges)
        self.checkBox_Solid = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_Solid.setMaximumSize(QtCore.QSize(80, 15))
        self.checkBox_Solid.setObjectName("checkBox_Solid")
        self.verticalLayout_solid_Jaco.addWidget(self.checkBox_Solid)
        self.checkBox_jacobian = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_jacobian.setMaximumSize(QtCore.QSize(80, 15))
        self.checkBox_jacobian.setObjectName("checkBox_jacobian")
        self.verticalLayout_solid_Jaco.addWidget(self.checkBox_jacobian)
        self.checkBox_Slicing = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_Slicing.setMaximumSize(QtCore.QSize(80, 15))
        self.checkBox_Slicing.setObjectName("checkBox_Slicing")
        self.verticalLayout_solid_Jaco.addWidget(self.checkBox_Slicing)
        self.horizontalLayout.addLayout(self.verticalLayout_solid_Jaco)
        self.verticalLayout_solid_Jaco_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_solid_Jaco_3.setObjectName("verticalLayout_solid_Jaco_3")
        self.radioButton_sdbNone = QtWidgets.QRadioButton(self.centralwidget)
        self.radioButton_sdbNone.setMaximumSize(QtCore.QSize(60, 16777215))
        self.radioButton_sdbNone.setChecked(True)
        self.radioButton_sdbNone.setObjectName("radioButton_sdbNone")
        self.verticalLayout_solid_Jaco_3.addWidget(self.radioButton_sdbNone)
        self.radioButton_SDB_sed = QtWidgets.QRadioButton(self.centralwidget)
        self.radioButton_SDB_sed.setMaximumSize(QtCore.QSize(60, 16777215))
        self.radioButton_SDB_sed.setObjectName("radioButton_SDB_sed")
        self.verticalLayout_solid_Jaco_3.addWidget(self.radioButton_SDB_sed)
        self.radioButton_SDB_eld = QtWidgets.QRadioButton(self.centralwidget)
        self.radioButton_SDB_eld.setMaximumSize(QtCore.QSize(60, 16777215))
        self.radioButton_SDB_eld.setObjectName("radioButton_SDB_eld")
        self.verticalLayout_solid_Jaco_3.addWidget(self.radioButton_SDB_eld)
        self.radioButton_cPres = QtWidgets.QRadioButton(self.centralwidget)
        self.radioButton_cPres.setMaximumSize(QtCore.QSize(60, 16777215))
        self.radioButton_cPres.setObjectName("radioButton_cPres")
        self.verticalLayout_solid_Jaco_3.addWidget(self.radioButton_cPres)
        self.horizontalLayout.addLayout(self.verticalLayout_solid_Jaco_3)
        self.verticalLayout_Extra = QtWidgets.QVBoxLayout()
        self.verticalLayout_Extra.setObjectName("verticalLayout_Extra")
        self.radioButton_Temperature = QtWidgets.QRadioButton(self.centralwidget)
        self.radioButton_Temperature.setEnabled(False)
        self.radioButton_Temperature.setMaximumSize(QtCore.QSize(60, 16777215))
        self.radioButton_Temperature.setChecked(True)
        self.radioButton_Temperature.setObjectName("radioButton_Temperature")
        self.verticalLayout_Extra.addWidget(self.radioButton_Temperature)
        self.radioButton_ext2 = QtWidgets.QRadioButton(self.centralwidget)
        self.radioButton_ext2.setEnabled(False)
        self.radioButton_ext2.setMaximumSize(QtCore.QSize(60, 16777215))
        self.radioButton_ext2.setObjectName("radioButton_ext2")
        self.verticalLayout_Extra.addWidget(self.radioButton_ext2)
        self.radioButton_ext3 = QtWidgets.QRadioButton(self.centralwidget)
        self.radioButton_ext3.setEnabled(False)
        self.radioButton_ext3.setMaximumSize(QtCore.QSize(60, 16777215))
        self.radioButton_ext3.setObjectName("radioButton_ext3")
        self.verticalLayout_Extra.addWidget(self.radioButton_ext3)
        self.radioButton_ext4 = QtWidgets.QRadioButton(self.centralwidget)
        self.radioButton_ext4.setEnabled(False)
        self.radioButton_ext4.setMaximumSize(QtCore.QSize(60, 16777215))
        self.radioButton_ext4.setObjectName("radioButton_ext4")
        self.verticalLayout_Extra.addWidget(self.radioButton_ext4)
        self.horizontalLayout.addLayout(self.verticalLayout_Extra)
        self.verticalLayout_xClipping = QtWidgets.QVBoxLayout()
        self.verticalLayout_xClipping.setObjectName("verticalLayout_xClipping")
        self.checkBox_clipping_X = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_clipping_X.setMaximumSize(QtCore.QSize(60, 15))
        self.checkBox_clipping_X.setObjectName("checkBox_clipping_X")
        self.verticalLayout_xClipping.addWidget(self.checkBox_clipping_X)
        self.checkBox_clipping_X_reverse = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_clipping_X_reverse.setMaximumSize(QtCore.QSize(70, 15))
        self.checkBox_clipping_X_reverse.setObjectName("checkBox_clipping_X_reverse")
        self.verticalLayout_xClipping.addWidget(self.checkBox_clipping_X_reverse)
        self.horizontalSlider_x_clipping = QtWidgets.QSlider(self.centralwidget)
        self.horizontalSlider_x_clipping.setMaximumSize(QtCore.QSize(80, 30))
        self.horizontalSlider_x_clipping.setMaximum(100)
        self.horizontalSlider_x_clipping.setSingleStep(5)
        self.horizontalSlider_x_clipping.setProperty("value", 50)
        self.horizontalSlider_x_clipping.setSliderPosition(50)
        self.horizontalSlider_x_clipping.setOrientation(QtCore.Qt.Horizontal)
        self.horizontalSlider_x_clipping.setObjectName("horizontalSlider_x_clipping")
        self.verticalLayout_xClipping.addWidget(self.horizontalSlider_x_clipping)
        self.horizontalLayout.addLayout(self.verticalLayout_xClipping)
        self.verticalLayout_yClipping = QtWidgets.QVBoxLayout()
        self.verticalLayout_yClipping.setObjectName("verticalLayout_yClipping")
        self.checkBox_clipping_Y = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_clipping_Y.setMaximumSize(QtCore.QSize(60, 15))
        self.checkBox_clipping_Y.setObjectName("checkBox_clipping_Y")
        self.verticalLayout_yClipping.addWidget(self.checkBox_clipping_Y)
        self.checkBox_clipping_Y_reverse = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_clipping_Y_reverse.setMaximumSize(QtCore.QSize(70, 15))
        self.checkBox_clipping_Y_reverse.setObjectName("checkBox_clipping_Y_reverse")
        self.verticalLayout_yClipping.addWidget(self.checkBox_clipping_Y_reverse)
        self.horizontalSlider_y_clipping = QtWidgets.QSlider(self.centralwidget)
        self.horizontalSlider_y_clipping.setMaximumSize(QtCore.QSize(80, 30))
        self.horizontalSlider_y_clipping.setMaximum(100)
        self.horizontalSlider_y_clipping.setSingleStep(5)
        self.horizontalSlider_y_clipping.setProperty("value", 50)
        self.horizontalSlider_y_clipping.setSliderPosition(50)
        self.horizontalSlider_y_clipping.setOrientation(QtCore.Qt.Horizontal)
        self.horizontalSlider_y_clipping.setObjectName("horizontalSlider_y_clipping")
        self.verticalLayout_yClipping.addWidget(self.horizontalSlider_y_clipping)
        self.horizontalLayout.addLayout(self.verticalLayout_yClipping)
        self.verticalLayout_zClipping = QtWidgets.QVBoxLayout()
        self.verticalLayout_zClipping.setObjectName("verticalLayout_zClipping")
        self.checkBox_clipping_Z = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_clipping_Z.setMaximumSize(QtCore.QSize(60, 15))
        self.checkBox_clipping_Z.setObjectName("checkBox_clipping_Z")
        self.verticalLayout_zClipping.addWidget(self.checkBox_clipping_Z)
        self.checkBox_clipping_Z_reverse = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_clipping_Z_reverse.setMaximumSize(QtCore.QSize(70, 15))
        self.checkBox_clipping_Z_reverse.setObjectName("checkBox_clipping_Z_reverse")
        self.verticalLayout_zClipping.addWidget(self.checkBox_clipping_Z_reverse)
        self.horizontalSlider_z_clipping = QtWidgets.QSlider(self.centralwidget)
        self.horizontalSlider_z_clipping.setMaximumSize(QtCore.QSize(80, 30))
        self.horizontalSlider_z_clipping.setMaximum(100)
        self.horizontalSlider_z_clipping.setSingleStep(5)
        self.horizontalSlider_z_clipping.setProperty("value", 50)
        self.horizontalSlider_z_clipping.setSliderPosition(50)
        self.horizontalSlider_z_clipping.setOrientation(QtCore.Qt.Horizontal)
        self.horizontalSlider_z_clipping.setObjectName("horizontalSlider_z_clipping")
        self.verticalLayout_zClipping.addWidget(self.horizontalSlider_z_clipping)
        self.horizontalLayout.addLayout(self.verticalLayout_zClipping)
        self.verticalLayout_zClipping_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_zClipping_2.setObjectName("verticalLayout_zClipping_2")
        self.label_view_upPosition = QtWidgets.QLabel(self.centralwidget)
        self.label_view_upPosition.setMinimumSize(QtCore.QSize(50, 0))
        self.label_view_upPosition.setMaximumSize(QtCore.QSize(60, 15))
        self.label_view_upPosition.setAlignment(QtCore.Qt.AlignCenter)
        self.label_view_upPosition.setObjectName("label_view_upPosition")
        self.verticalLayout_zClipping_2.addWidget(self.label_view_upPosition)
        self.lineEdit_view_upPosition = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_view_upPosition.setMaximumSize(QtCore.QSize(80, 20))
        self.lineEdit_view_upPosition.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_view_upPosition.setObjectName("lineEdit_view_upPosition")
        self.verticalLayout_zClipping_2.addWidget(self.lineEdit_view_upPosition)
        self.horizontalLayout_preset_View = QtWidgets.QHBoxLayout()
        self.horizontalLayout_preset_View.setObjectName("horizontalLayout_preset_View")
        self.pushButton_View_yz = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_View_yz.setMaximumSize(QtCore.QSize(20, 20))
        self.pushButton_View_yz.setObjectName("pushButton_View_yz")
        self.horizontalLayout_preset_View.addWidget(self.pushButton_View_yz)
        self.pushButton_View_xz = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_View_xz.setMaximumSize(QtCore.QSize(20, 20))
        self.pushButton_View_xz.setObjectName("pushButton_View_xz")
        self.horizontalLayout_preset_View.addWidget(self.pushButton_View_xz)
        self.pushButton_View_yx = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_View_yx.setMaximumSize(QtCore.QSize(20, 20))
        self.pushButton_View_yx.setObjectName("pushButton_View_yx")
        self.horizontalLayout_preset_View.addWidget(self.pushButton_View_yx)
        self.verticalLayout_zClipping_2.addLayout(self.horizontalLayout_preset_View)
        self.label_view_upPosition_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_view_upPosition_2.setMinimumSize(QtCore.QSize(50, 0))
        self.label_view_upPosition_2.setMaximumSize(QtCore.QSize(80, 15))
        self.label_view_upPosition_2.setAlignment(QtCore.Qt.AlignCenter)
        self.label_view_upPosition_2.setObjectName("label_view_upPosition_2")
        self.verticalLayout_zClipping_2.addWidget(self.label_view_upPosition_2)
        self.lineEdit_slicingAngle = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_slicingAngle.setMaximumSize(QtCore.QSize(80, 20))
        self.lineEdit_slicingAngle.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_slicingAngle.setObjectName("lineEdit_slicingAngle")
        self.verticalLayout_zClipping_2.addWidget(self.lineEdit_slicingAngle)
        self.horizontalLayout.addLayout(self.verticalLayout_zClipping_2)
        self.verticalLayout_zClipping_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_zClipping_3.setObjectName("verticalLayout_zClipping_3")
        self.lineEdit_showNodes = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_showNodes.setMaximumSize(QtCore.QSize(125, 20))
        self.lineEdit_showNodes.setObjectName("lineEdit_showNodes")
        self.verticalLayout_zClipping_3.addWidget(self.lineEdit_showNodes)
        self.lineEdit_showElements = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_showElements.setMaximumSize(QtCore.QSize(125, 20))
        self.lineEdit_showElements.setObjectName("lineEdit_showElements")
        self.verticalLayout_zClipping_3.addWidget(self.lineEdit_showElements)
        self.horizontalLayout_cRange = QtWidgets.QHBoxLayout()
        self.horizontalLayout_cRange.setObjectName("horizontalLayout_cRange")
        self.lineEdit_colorRange = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_colorRange.setMaximumSize(QtCore.QSize(60, 20))
        self.lineEdit_colorRange.setObjectName("lineEdit_colorRange")
        self.horizontalLayout_cRange.addWidget(self.lineEdit_colorRange)
        self.lineEdit_colorRange1 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_colorRange1.setMaximumSize(QtCore.QSize(60, 20))
        self.lineEdit_colorRange1.setObjectName("lineEdit_colorRange1")
        self.horizontalLayout_cRange.addWidget(self.lineEdit_colorRange1)
        self.verticalLayout_zClipping_3.addLayout(self.horizontalLayout_cRange)
        self.horizontalLayout_colorRange_value = QtWidgets.QHBoxLayout()
        self.horizontalLayout_colorRange_value.setObjectName("horizontalLayout_colorRange_value")
        self.lineEdit_colorRange_value = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_colorRange_value.setMaximumSize(QtCore.QSize(60, 20))
        self.lineEdit_colorRange_value.setObjectName("lineEdit_colorRange_value")
        self.horizontalLayout_colorRange_value.addWidget(self.lineEdit_colorRange_value)
        self.lineEdit_colorRange_value1 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_colorRange_value1.setMaximumSize(QtCore.QSize(60, 20))
        self.lineEdit_colorRange_value1.setObjectName("lineEdit_colorRange_value1")
        self.horizontalLayout_colorRange_value.addWidget(self.lineEdit_colorRange_value1)
        self.verticalLayout_zClipping_3.addLayout(self.horizontalLayout_colorRange_value)
        self.horizontalLayout.addLayout(self.verticalLayout_zClipping_3)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1210, 21))
        self.menubar.setObjectName("menubar")
        self.menuHOME = QtWidgets.QMenu(self.menubar)
        self.menuHOME.setObjectName("menuHOME")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionToggle_Background_color = QtWidgets.QAction(MainWindow)
        self.actionToggle_Background_color.setObjectName("actionToggle_Background_color")
        self.menuHOME.addAction(self.actionToggle_Background_color)
        self.menubar.addAction(self.menuHOME.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "3D Mesh Viewer [ptn, axi, trd, sdb, sfric]"))
        self.pushButton_openfile.setText(_translate("MainWindow", "Open mesh"))
        self.pushButton_add_Mesh.setText(_translate("MainWindow", "Add mesh"))
        self.comboBox.setItemText(0, _translate("MainWindow", "white"))
        self.comboBox.setItemText(1, _translate("MainWindow", "violet"))
        self.comboBox.setItemText(2, _translate("MainWindow", "lightgreen"))
        self.comboBox.setItemText(3, _translate("MainWindow", "gray"))
        self.comboBox.setItemText(4, _translate("MainWindow", "coral"))
        self.comboBox.setItemText(5, _translate("MainWindow", "aqua"))
        self.comboBox.setItemText(6, _translate("MainWindow", "pink"))
        self.comboBox.setItemText(7, _translate("MainWindow", "coral"))
        self.comboBox.setItemText(8, _translate("MainWindow", "lightblue"))
        self.comboBox.setItemText(9, _translate("MainWindow", "steelblue"))
        self.comboBox.setItemText(10, _translate("MainWindow", "wheat"))
        self.checkBox_colorChanging.setText(_translate("MainWindow", "Next Color"))
        self.pushButton_replaceCells.setText(_translate("MainWindow", "Replace"))
        self.pushButton_SaveSfricSurface.setText(_translate("MainWindow", "save_sfricSurf"))
        self.checkBox_meshLine.setText(_translate("MainWindow", "Mesh Line"))
        self.label_opecity.setText(_translate("MainWindow", "Opecity "))
        self.lineEdit_opecity.setText(_translate("MainWindow", "100"))
        self.checkBox_showEdges.setText(_translate("MainWindow", "Edges"))
        self.checkBox_Solid.setText(_translate("MainWindow", "Solid"))
        self.checkBox_jacobian.setText(_translate("MainWindow", "Jacobian"))
        self.checkBox_Slicing.setText(_translate("MainWindow", "Slicing"))
        self.radioButton_sdbNone.setText(_translate("MainWindow", "NONE"))
        self.radioButton_SDB_sed.setText(_translate("MainWindow", "SED"))
        self.radioButton_SDB_eld.setText(_translate("MainWindow", "Heat G"))
        self.radioButton_cPres.setText(_translate("MainWindow", "Pres"))
        self.radioButton_Temperature.setText(_translate("MainWindow", "Tem"))
        self.radioButton_ext2.setText(_translate("MainWindow", "2"))
        self.radioButton_ext3.setText(_translate("MainWindow", "3"))
        self.radioButton_ext4.setText(_translate("MainWindow", "4"))
        self.checkBox_clipping_X.setText(_translate("MainWindow", "Clip X"))
        self.checkBox_clipping_X_reverse.setText(_translate("MainWindow", "Invert"))
        self.checkBox_clipping_Y.setText(_translate("MainWindow", "Clip Y"))
        self.checkBox_clipping_Y_reverse.setText(_translate("MainWindow", "Inverst"))
        self.checkBox_clipping_Z.setText(_translate("MainWindow", "Clip Z"))
        self.checkBox_clipping_Z_reverse.setText(_translate("MainWindow", "Invert"))
        self.label_view_upPosition.setText(_translate("MainWindow", "ViewPoint"))
        self.lineEdit_view_upPosition.setText(_translate("MainWindow", "1, 0, 0"))
        self.pushButton_View_yz.setText(_translate("MainWindow", "yz"))
        self.pushButton_View_xz.setText(_translate("MainWindow", "xz"))
        self.pushButton_View_yx.setText(_translate("MainWindow", "yx"))
        self.label_view_upPosition_2.setText(_translate("MainWindow", "Slicing Angle"))
        self.lineEdit_slicingAngle.setText(_translate("MainWindow", "0"))
        self.menuHOME.setTitle(_translate("MainWindow", "HOME"))
        self.actionToggle_Background_color.setText(_translate("MainWindow", "Toggle White Background"))
        self.actionToggle_Background_color.setShortcut(_translate("MainWindow", "Ctrl+Shift+W"))


    def operating(self): 
        self.actions()
        self.initialize()
        self.createFrame()
        
    def initialize(self): 
        icon = QtGui.QIcon()
        try: 
            icon.addPixmap(QtGui.QPixmap("pyMesh.ico"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
            MainWindow.setWindowIcon(icon)
        except: 
            pass 

        self.meshfile = False 
        self.meshes=[]; self.points=[]; self.colors=[]; self.edges=[]; self.surfaces=[]; self.nodes=[]
        self.idx_element=[]; self.elements=[]; self.presses=[]; self.temperatures =[]
        self.valueStart = 0.0; self.valueEnd = 0.0; self.vgap = 0
        self.opecity = 1.0
        self.show_edges = False
        self.camera_position=None 
        self.show_qualityCheck = False
        self.show_meshLine = True 
        self.click_meshLine = 0 
        self.color_meshLine = 'black'
        self.clippedMesh = None 
        self.xClipped = False
        self.yClipped = False
        self.zClipped = False
        self.solidClip = False 
        self.x_revClipping = False 
        self.y_revClipping = False 
        self.z_revClipping = False 

        self.xClippingShift = 0.0
        self.yClippingShift = 0.0
        self.zClippingShift = 0.0
        self.xclippingScale = 1.0
        self.yclippingScale = 1.0
        self.zclippingScale = 1.0

        self.view_upPosition = '1, 1, 1'
        self.lineEdit_view_upPosition.setText("1, 1, 1")
        self.xmx = 0; self.xmn = 0
        self.ymx = 0; self.ymn = 0
        self.zmx = 0; self.zmn = 0

        self.copiedView=None 

        self.defaultColor_Background = True 

        self.color_edge_line = [('black', 2), ('red', 2)]
        self.click_show_edge = 0 
        self.nColor_edge_line = len(self.color_edge_line)

        self.dfile = "qt_pyVista.dir"
        cwd =os.getcwd()
        if os.path.isfile(self.dfile) == False: 
            df = cwd + '/' +self.dfile
            self.cwd=writeworkingdirectory(df, dfile=self.dfile)
        else: 
            f = open(self.dfile, 'r')
            line =f.readlines()
            f.close()
            self.cwd =line[0]

        self.lineEdit_showNodes.setPlaceholderText("node id")
        self.lineEdit_showNodes.setFocus()
        self.lineEdit_showElements.setPlaceholderText("element id")
        self.lineEdit_showElements.setFocus()
        self.lineEdit_colorRange.setPlaceholderText("C-Range: 0.0,1.0")
        self.lineEdit_colorRange.setFocus()
        self.lineEdit_colorRange.setText("0.01")
        self.lineEdit_colorRange1.setText("0.1")
        self.searched_points=[]; self.searchedNodes=[]; self.searchedElements=[]; self.searchedCells=[]
        self.radioButton_sdbNone.setChecked(True)
        self.radioButton_Temperature.setEnabled(False)

    def actions(self): 
        self.pushButton_openfile.clicked.connect(self.openFile)
        self.pushButton_add_Mesh.clicked.connect(self.addMesh)
        self.horizontalSlider_opacity.valueChanged.connect(self.get_OpecityValue)
        self.lineEdit_opecity.returnPressed.connect(self.change_OpecityValue)
        
        self.checkBox_showEdges.clicked.connect(self.showEdges)
        self.checkBox_jacobian.clicked.connect(self.showQualityCheck)
        self.checkBox_meshLine.clicked.connect(self.show_MeshLine)
        self.checkBox_Solid.clicked.connect(self.choose_solid_surface)

        self.checkBox_clipping_X.clicked.connect(self.clipping_X)
        self.checkBox_clipping_Y.clicked.connect(self.clipping_Y)
        self.checkBox_clipping_Z.clicked.connect(self.clipping_Z)
        self.horizontalSlider_x_clipping.valueChanged.connect(self.clipping_X)
        self.horizontalSlider_y_clipping.valueChanged.connect(self.clipping_Y)
        self.horizontalSlider_z_clipping.valueChanged.connect(self.clipping_Z)
        self.checkBox_clipping_X_reverse.clicked.connect(self.clipping_X)
        self.checkBox_clipping_Y_reverse.clicked.connect(self.clipping_Y)
        self.checkBox_clipping_Z_reverse.clicked.connect(self.clipping_Z)

        self.radioButton_SDB_sed.clicked.connect(self.showMesh)
        self.radioButton_SDB_eld.clicked.connect(self.showMesh)
        self.radioButton_Temperature.clicked.connect(self.showMesh)
        self.radioButton_cPres.clicked.connect(self.showMesh)
        self.radioButton_sdbNone.clicked.connect(self.showMesh)
        self.lineEdit_slicingAngle.returnPressed.connect(self.slicing)
        self.checkBox_Slicing.clicked.connect(self.slicing)

        self.actionToggle_Background_color.triggered.connect(self.toggling_color_background) 
        self.lineEdit_view_upPosition.returnPressed.connect(self.changeViewPosition)
        self.pushButton_View_xz.clicked.connect(self.viewxz)
        self.pushButton_View_yz.clicked.connect(self.viewyz)
        self.pushButton_View_yx.clicked.connect(self.viewyx)

        self.lineEdit_showNodes.returnPressed.connect(self.showSearchedNodes)
        self.lineEdit_showElements.returnPressed.connect(self.showSearchedElements)

        self.lineEdit_colorRange_value.editingFinished.connect(self.changeRatio)
        self.lineEdit_colorRange_value1.editingFinished.connect(self.changeRatio)
        

        self.pushButton_replaceCells.clicked.connect(self.replaceCells)

        self.pushButton_SaveSfricSurface.clicked.connect(self.saveSurface_sfric)

    def viewyz(self): 
        self.lineEdit_view_upPosition.setText('1, 0, 0')
        self.changeViewPosition()
    def viewxz(self): 
        try: 
            self.plotter.camera.up=(0, 0, 1)
        except: 
            pass 
        self.lineEdit_view_upPosition.setText('0, -1, 0')
        self.changeViewPosition()
    def viewyx(self): 
        if ".ptn" in self.meshfile: 
            self.lineEdit_view_upPosition.setText('0, 0, -1')
        else: 
            self.lineEdit_view_upPosition.setText('0, 0, 1')
        self.changeViewPosition()
        if ".ptn" in self.meshfile: 
            self.plotter.camera.roll += 90
            # self.plotter.camera.azimuth += 90
            # self.plotter.camera.elevation += 90

    def copyView(self): 
        self.get_camera_position()
    def pasteView(self): 
        self.plotter.show()

    def changeViewPosition(self): 
        self.view_upPosition = self.lineEdit_view_upPosition.text().strip()

        vx=1; vy=0; vz=0 
        listText = self.view_upPosition.split(",")
        for i, v in enumerate(listText): 
            try: v = float(v)
            except: v = 0.0 
            if i ==0: vx = v 
            if i ==1: vy = v 
            if i ==2: vz = v 
        if vx ==0 and vy ==0 and vz ==0: 
            vx = vy = vz = 1 
            self.lineEdit_view_upPosition.setText("1, 1, 1")
        ### plotter.camera_position = [(11.7, 4.7, -4.33),  (0.0, 0.0, 0.0), (0.3, 0.07, 0.9)]
        # A good starting camera position - the three values are the camera position,
        # the camera focus, and the up vector of the viewport
        if vx == 0 and vy ==0 and vz !=0: 
            if vz > 0: self.plotter.camera_position = 'yx' #self.plotter.camera.up=(1, 0, 0)
            else: 
                self.plotter.set_viewup([-1, 0, 0])
                self.plotter.camera_position = 'xy' 
                # self.plotter.camera.up=(-1, 0, 0)
        elif vx != 0 and vy ==0 and vz==0: 
            if vx > 0: self.plotter.camera_position = 'yz'
            else: 
                self.plotter.set_viewup([0, 0, -1])
                self.plotter.camera_position = 'zy' 
                # self.plotter.camera.up=(0, 0, -1)
        elif vx == 0 and vy !=0 and vz==0: 
            if vy > 0: self.plotter.camera_position = 'zx'
            else: 
                self.plotter.set_viewup([-1, 0, 0])
                self.plotter.camera_position = 'xz' 
                # self.plotter.camera.up=(-1, 0, 0)
        else: 
            self.plotter.camera_position  = (vx, vy, vz)
        self.showMesh()
    
    def toggling_color_background(self): 
        if self.defaultColor_Background: 
            self.defaultColor_Background=False 
        else: 
            self.defaultColor_Background = True 
        self.get_camera_position()
        self.showMesh()

    def choose_solid_surface(self): 
        if self.checkBox_Solid.isChecked(): self.solidClip = True 
        else: self.solidClip = False 
        self.get_camera_position()
        self.showMesh()
    def clipping_X(self): 
        self.xClippingShift = (self.horizontalSlider_x_clipping.value() - 50) * self.xclippingScale #float(self.lineEdit_x_clip_offset.text())
        if self.checkBox_clipping_X.isChecked(): self.xClipped = True 
        else: self.xClipped = False 
        if self.checkBox_clipping_X_reverse.isChecked(): self.x_revClipping = True 
        else: self.x_revClipping = False 
        self.get_camera_position()
        self.showMesh()
    
    def clipping_Y(self): 
        self.yClippingShift = (self.horizontalSlider_y_clipping.value() - 50) * self.yclippingScale #float(self.lineEdit_y_clip_offset.text())
        if self.checkBox_clipping_Y.isChecked(): self.yClipped = True 
        else: self.yClipped = False 
        if self.checkBox_clipping_Y_reverse.isChecked(): self.y_revClipping = True 
        else: self.y_revClipping = False 
        self.get_camera_position()
        self.showMesh()

    def clipping_Z(self): 
        self.zClippingShift = (self.horizontalSlider_z_clipping.value() - 50)*self.zclippingScale #float(self.lineEdit_z_clip_offset.text())
        if self.checkBox_clipping_Z.isChecked(): self.zClipped = True 
        else: self.zClipped = False 
        if self.checkBox_clipping_Z_reverse.isChecked(): self.z_revClipping = True 
        else: self.z_revClipping = False 
        self.get_camera_position()
        self.showMesh()

    def get_camera_position(self): 
        try: 
            self.camera_position = self.plotter.camera_position
            self.copied_camera = self.plotter.camera
        except: 
            self.camera_position = None 

    def show_MeshLine(self): 
        if self.checkBox_meshLine.isChecked(): 
            self.show_meshLine = True 
            if self.color_meshLine == 'black': self.color_meshLine = 'gray'
            elif self.color_meshLine == 'gray': self.color_meshLine = 'blue'
            elif self.color_meshLine == 'blue': self.color_meshLine = 'red'
            elif self.color_meshLine == 'red': self.color_meshLine = 'black'

        else: self.show_meshLine = False

        self.get_camera_position()
        
        self.showMesh()

    def showQualityCheck(self): 
        if self.checkBox_jacobian.isChecked(): 
            self.show_qualityCheck = True 
        else: self.show_qualityCheck = False

        self.get_camera_position()
        self.showMesh()
        
    def showEdges(self): 
        if self.checkBox_showEdges.isChecked(): 
            self.show_edges = True 
            self.click_show_edge += 1 
        else: self.show_edges = False
        self.get_camera_position()
        self.showMesh()

    def get_OpecityValue(self): 

        self.opecity = self.horizontalSlider_opacity.value() / 100.0
        # self.label_opecity.setText("Opecity : %d"%(self.opecity*100))
        self.lineEdit_opecity.setText(str(int(self.opecity*100)))
        self.get_camera_position() 
        self.showMesh()

    def change_OpecityValue(self): 
        opecity = int(self.lineEdit_opecity.text()) 
        self.horizontalSlider_opacity.setSliderPosition(opecity)
        self.get_OpecityValue()



    def clearFrame(self): 
        for i in range(self.verticalLayout.count()): self.verticalLayout.itemAt(i).widget().close()

    def createFrame(self): 
        self.frame = QtWidgets.QFrame() 
        self.plotter = QtInteractor(self.frame)
        self.verticalLayout.addWidget(self.plotter.interactor) 
        
    
    def get_pyVistaMesh(self): 
        print(self.meshfile)
        if ".ptn" in self.meshfile: 
            pvMesh = Mesh.MESH(self.meshfile, centering=True)
            # trd, edges, pt1, surface, npn, idx_element,_ = Mesh.load_pyVista_mesh(self.meshfile, centering=True) 
        else: 
            pvMesh = Mesh.MESH(self.meshfile, centering=False)
            # trd, edges, pt1, surface, npn, idx_element, _ = Mesh.load_pyVista_mesh(self.meshfile) 
        self.lineEdit_temp.setText(self.meshfile.split("/")[-1])

        trd = pvMesh.grid
        edges = pvMesh.edges 
        pt1   = pvMesh.pt_cloud
        surface = pvMesh.surfaces
        npn = pvMesh.nodes 
        idx_element = pvMesh.idx_element
        cells = pvMesh.cells 

        if '.sfric' in self.meshfile: 
            self.class_sfric = pvMesh.class_sfric

        self.meshes.append(trd)
        self.points.append(pt1)
        self.edges.append(edges)
        self.surfaces.append(surface)
        self.nodes.append(npn)
        print(" >>>>>>>>>>>>>>", pvMesh.surfaces)
        self.idx_element.append(idx_element)
        self.elements.append(cells) 

        if '.sfric' in self.meshfile or '.dat' in self.meshfile: 
            if isinstance(pvMesh.press, type(None)): 
                self.presses.append(pvMesh.npress)
            else: 
                self.presses.append(pvMesh.press)
        if '.sdb' in self.meshfile: 
            self.temperatures.append(pvMesh.temperature)

        self.lineEdit_colorRange.setText("0.0")
        self.lineEdit_colorRange1.setText("0.1")
        if '.sdb' in self.meshfile: 
            self.radioButton_SDB_sed.setEnabled(True)
            self.radioButton_SDB_eld.setEnabled(True)
            self.radioButton_Temperature.setEnabled(True)
            self.radioButton_cPres.setEnabled(False)
            
        elif '.sfric' in self.meshfile or '.dat' in self.meshfile: 
            self.radioButton_SDB_sed.setEnabled(False)
            self.radioButton_SDB_eld.setEnabled(False)
            self.radioButton_Temperature.setEnabled(False)
            self.radioButton_cPres.setEnabled(True)
            self.lineEdit_colorRange_value.setText("50000")
            self.lineEdit_colorRange_value1.setText("500000")
        else: 
            self.radioButton_SDB_sed.setEnabled(False)
            self.radioButton_SDB_eld.setEnabled(False)
            self.radioButton_Temperature.setEnabled(False)
            self.radioButton_cPres.setEnabled(False)
        self.radioButton_sdbNone.setChecked(True)

        xmn = 10**7; xmx=-10**7; ymn = 10**7; ymx=-10**7; zmn = 10**7; zmx=-10**7
        for nodes in self.nodes: 
            mn = np.min(nodes[:,1]); mx = np.max(nodes[:,1])
            if xmn > mn: xmn = mn 
            if xmx < mx: xmx = mx 

            mn = np.min(nodes[:,2]); mx = np.max(nodes[:,2])
            if ymn > mn: ymn = mn 
            if ymx < mx: ymx = mx 

            mn = np.min(nodes[:,3]); mx = np.max(nodes[:,3])
            if zmn > mn: zmn = mn 
            if zmx < mx: zmx = mx  

        self.xclippingScale=(xmx-xmn)/99
        self.yclippingScale=(ymx-ymn)/99
        self.zclippingScale=(zmx-zmn)/99
        self.xmx = xmx; self.xmn = xmn 
        self.ymx = ymx; self.ymn = ymn 
        self.zmx = zmx; self.zmn = zmn 

        print (" Scaling x=%.3E, y=%.3E, z=%.3E"%(self.xclippingScale, self.yclippingScale, self.zclippingScale))
        print (" min y=%.6f, max y=%.6f"%(ymn*self.yclippingScale, ymx*self.yclippingScale))

    def changingCurrentColor(self): 
        if self.checkBox_colorChanging.isChecked(): 
            index = self.comboBox.currentIndex() + 1 
            count = self.comboBox.count() 
            if index >= count: index -= count  
            self.comboBox.setCurrentIndex(index)

    def openFile(self): 
        self.meshes=[]; self.points=[]; self.colors=[]; self.edges=[]; self.surfaces=[]; self.nodes=[]
        self.idx_element = []; self.elements=[]; self.presses=[]

        self.horizontalSlider_x_clipping.setSliderPosition(50)
        self.horizontalSlider_y_clipping.setSliderPosition(50)
        self.horizontalSlider_z_clipping.setSliderPosition(50)
        self.camera_position = None 

        self.gettingPyvistaMesh()

    def addMesh(self): 
        self.gettingPyvistaMesh()


    def gettingPyvistaMesh(self): 
        self.meshfile, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Select File", self.cwd, "File Open(*.trd *.axi *.ptn *.inp *.sfric0* *.sdb0* *-postfoot.dat)")
        if self.meshfile: 
            self.cwd = writeworkingdirectory(self.meshfile, dfile=self.dfile)
            try:
                t= time.time()
                self.get_pyVistaMesh()
                t1 = time.time()
                print("Time to read : %.3f"%(t1-t))
            except Exception as ex: 
                etext = str(ex) + "\n\n" + "Error to open file \n " + "%s"%(self.meshfile)
                writingError(etext)
                print(etext)

            self.colors.append(self.comboBox.currentText())
            self.showMesh() 
            self.changingCurrentColor()
    
    def saveSurface_sfric(self): 
        if ".sfric" in self.meshfile: 
            results =  self.meshfile[:-9]+"-sfric_surface.inp"
            savefile, _= QtWidgets.QFileDialog.getSaveFileName(None, "Save files as", results, "SFRIC Surface Mesh(*.inp)")
            
            fp = open(savefile, 'w') 

            fp.write("*NODE\n")
            for n in self.class_sfric.Node.Node: 
                fp.write("%10d, %10.6f, %10.6f, %10.6f\n"%(n[0], n[1], n[2], n[3]))

            fp.write("*ELEMENT, TYPE=M3D4R\n")
            for sf in self.class_sfric.Surface.Surface: 
                fp.write("%10d, %10d, %10d, %10d, %10d\n"%(sf[0], sf[1], sf[2], sf[3], sf[4]))

            fp.close()

    def clearPlotter(self):

        self.clearFrame()
        self.createFrame()
        self.plotter.clear()

    def showMesh(self):
        self.clearPlotter()
        try: 
            self.plotting()
        except Exception as ex: 
            etext = str(ex) + "\n\n" + "Error to plotting \n"
            writingError(etext)
            print(etext)

    def slicing(self):
        if self.checkBox_Slicing.isChecked():  
            self.lineEdit_opecity.setText("1")
            if not '.ptn' in self.meshfile: 
                opecity = int(self.lineEdit_opecity.text()) 
                self.horizontalSlider_opacity.setSliderPosition(opecity)
                self.opecity = self.horizontalSlider_opacity.value() / 100.0
                self.lineEdit_opecity.setText(str(int(self.opecity*100)))

                angle = float(self.lineEdit_slicingAngle.text().strip())
                radian_angle = math.radians(angle)
                self.lineEdit_view_upPosition.setText("%.3f, 0, %.3f"%(math.cos(radian_angle), math.sin(radian_angle)))

        else: 
            if not '.ptn' in self.meshfile: 
                angle = float(self.lineEdit_slicingAngle.text().strip())
                radian_angle = math.radians(angle)
                self.lineEdit_view_upPosition.setText("%.3f, 0, %.3f"%(math.cos(radian_angle), math.sin(radian_angle)))
            self.lineEdit_opecity.setText("100")
        
        self.change_OpecityValue()

    def changeRatio(self): 
        if '.sdb' in self.meshfile or '.sfric' in self.meshfile or '.dat' in self.meshfile:
            if self.vgap != 0  : 
                low = float(self.lineEdit_colorRange_value.text().strip())
                lpst = (low-self.vmin) / self.vgap
                self.lineEdit_colorRange.setText("%.6f"%(lpst))

                high = float(self.lineEdit_colorRange_value1.text().strip())
                hpst = (high-self.vmin) / self.vgap
                self.lineEdit_colorRange1.setText("%.6f"%(hpst))

    def plotting(self, nodeplotRecursive=False): 
        if not self.meshfile: return 
        self.valueStart = 0.0; self.valueEnd = 0.0; self.vgap = 0 

        ilow  =  self.lineEdit_colorRange.text().strip()
        ihigh =  self.lineEdit_colorRange1.text().strip()
        psize = 5  

        if '.sdb' in self.meshfile: 
            if self.radioButton_SDB_sed.isChecked(): item = 'sed'
            elif self.radioButton_SDB_eld.isChecked(): item = 'eld'
            elif self.radioButton_Temperature.isChecked(): item = 'temperature'
            else: item = False

        elif '.sfric' in self.meshfile or '.dat' in self.meshfile: 
            item = 'press'
        else: 
            item = False 
        
        
        if ".sfric" in self.meshfile or ".dat" in self.meshfile: 
            if not self.xClipped and not self.yClipped and not self.zClipped: 
                for surface, press, clr in zip(self.surfaces, self.presses, self.colors): 
                    if item: 
                        vmax = press[item].max(); vmin = press[item].min()
                        vgap = vmax - vmin  
                        low = float(ilow); high = float(ihigh)
                        start = vmin + vgap * low; end = vmin + vgap * high
                        self.lineEdit_colorRange_value.setText("%.1f"%(start))
                        self.lineEdit_colorRange_value1.setText("%.1f"%(end))
                        self.valueStart = start; self.valueEnd = end 
                        self.vmin = vmin; self.vmax = vmax; self.vgap= vgap 
                        print(self.vmin, self.vmax) 
                    
                    self.plotter_surf = self.plotter.add_mesh(surface, show_edges=self.show_meshLine, color=clr, metallic=0.3, pbr=False, diffuse=1, opacity=self.opecity, smooth_shading=False, edge_color=self.color_meshLine) 
                    
                    if self.checkBox_Slicing.isChecked(): 
                        angle = float(self.lineEdit_slicingAngle.text().strip())
                        radian_angle = math.radians(angle)
                        sliced = surface.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                        self.plotter_qulity = self.plotter.add_mesh(sliced,color='red', opacity=1.0)
                    
                    if self.radioButton_cPres.isChecked():
                        dargs = dict(scalars=item, cmap='rainbow', show_edges=self.show_meshLine, n_colors=150, clim=[start, end], below_color='white', edge_color=self.color_meshLine)
                        self.plotter_qulity = self.plotter.add_mesh(press, interpolate_before_map=True, opacity=1, 
                             scalar_bar_args={'title': ' %s  - interpolated'%(item)}, smooth_shading=True, **dargs)
                        
            else: 
                for surface, press, clr in zip(self.surfaces, self.presses, self.colors): 
                    if item: 
                        vmax = press[item].max(); vmin = press[item].min()
                        vgap = vmax - vmin  
                        low = float(ilow); high = float(ihigh)
                        start = vmin + vgap * low; end = vmin + vgap * high
                        self.lineEdit_colorRange_value.setText("%.1f"%(start))
                        self.lineEdit_colorRange_value1.setText("%.1f"%(end))
                        self.valueStart = start; self.valueEnd = end 
                        self.vmin = vmin; self.vmax = vmax; self.vgap= vgap 

                    clippedMesh = self.clipping(surface)
                    clippedPress = self.clipping(press)
                    self.plotter_surf = self.plotter.add_mesh(clippedMesh, show_edges=self.show_meshLine, color=clr, metallic=0.3, \
                        pbr=False, diffuse=1, opacity=self.opecity, smooth_shading=False, edge_color=self.color_meshLine) 
                    
                    if self.checkBox_Slicing.isChecked(): 
                        angle = float(self.lineEdit_slicingAngle.text().strip())
                        radian_angle = math.radians(angle)
                        sliced = clippedMesh.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                        self.plotter_qulity = self.plotter.add_mesh(sliced,color='red', opacity=1.0)

                    if self.radioButton_cPres.isChecked():
                        dargs = dict(scalars=item, cmap='rainbow', show_edges=self.show_meshLine, n_colors=150, clim=[start, end], below_color='white')
                        self.plotter_qulity = self.plotter.add_mesh(clippedPress, interpolate_before_map=True, opacity=self.opecity, edge_color=self.color_meshLine, 
                            scalar_bar_args={'title': ' %s  - interpolated'%(item)}, **dargs)
                        self.lineEdit_view_upPosition.setText("0,0,1")
                    
                self.plotter.enable_cell_picking(mesh=surface)
        elif '.sdb' in self.meshfile: 
            if not self.xClipped and not self.yClipped and not self.zClipped: 
                self.clippedMesh= None 
                cnt = 0     
                for mesh, clr, edge, surface in zip(self.meshes, self.colors, self.edges, self.surfaces):
                    
                    if item: 
                        vmax = mesh[item].max(); vmin = mesh[item].min()
                        vgap = vmax - vmin 
                        low = float(ilow); high = float(ihigh) 
                        start = vmin + vgap * low; end = vmin + vgap * high
                        self.lineEdit_colorRange_value.setText("%.1f"%(start))
                        self.lineEdit_colorRange_value1.setText("%.1f"%(end))
                        self.valueStart = start; self.valueEnd = end 
                        self.vmin = vmin; self.vmax = vmax; self.vgap= vgap 
                    
                    if self.show_edges: 
                        self.plotter_edges = self.plotter.add_mesh(edge, color=self.color_edge_line[self.click_show_edge%self.nColor_edge_line][0], line_width=self.color_edge_line[self.click_show_edge%self.nColor_edge_line][1])
                    if self.radioButton_SDB_sed.isChecked() or self.radioButton_SDB_eld.isChecked(): 
                        dargs = dict(scalars=item, cmap='rainbow', show_edges=self.show_meshLine, n_colors=150, clim=[start, end], below_color='white', edge_color=self.color_meshLine)
                        self.plotter_qulity = self.plotter.add_mesh(mesh, interpolate_before_map=True, opacity=self.opecity, 
                             scalar_bar_args={'title': ' %s  - interpolated'%(item)}, **dargs)
                        if self.checkBox_Slicing.isChecked(): 
                            angle = float(self.lineEdit_slicingAngle.text().strip())
                            radian_angle = math.radians(angle)
                            sliced = mesh.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                            self.plotter_qulity = self.plotter.add_mesh(sliced, interpolate_before_map=True, opacity=1.0, 
                                scalar_bar_args={'title': ' %s  - interpolated'%(item)}, **dargs)

                        self.plotter.enable_cell_picking(mesh=mesh)
                    elif self.radioButton_Temperature.isChecked(): 
                        dargs = dict(scalars=item, cmap='rainbow', show_edges=self.show_meshLine, n_colors=150, clim=[start, end], below_color='white', edge_color=self.color_meshLine)
                        self.plotter_qulity = self.plotter.add_mesh(mesh, interpolate_before_map=True, opacity=self.opecity, 
                             scalar_bar_args={'title': ' %s  - interpolated'%(item)}, **dargs)

                        if self.checkBox_Slicing.isChecked(): 
                            angle = float(self.lineEdit_slicingAngle.text().strip())
                            radian_angle = math.radians(angle)
                            try: 
                                sliced = mesh.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                                self.plotter_qulity = self.plotter.add_mesh(sliced, interpolate_before_map=True, opacity=1.0, 
                                    scalar_bar_args={'title': ' %s  - interpolated'%(item)}, **dargs)
                            except Exception as ex: 
                                print(ex)


                    else: 
                        if self.show_qualityCheck:        
                            showmesh = mesh.compute_cell_quality('jacobian')
                            self.plotter_qulity = self.plotter.add_mesh(showmesh, show_edges=self.show_meshLine, pbr=False, diffuse=1, opacity=self.opecity, edge_color=self.color_meshLine )
                        elif self.solidClip :             
                            showmesh = mesh 
                            self.plotter_qulity = self.plotter.add_mesh(showmesh, color=clr, show_edges=self.show_meshLine, pbr=False, diffuse=1, opacity=self.opecity, edge_color=self.color_meshLine )
                        else:                             
                            showmesh = surface 
                            self.plotter_qulity = self.plotter.add_mesh(showmesh, color=clr, show_edges=self.show_meshLine, pbr=False, diffuse=1, opacity=self.opecity, edge_color=self.color_meshLine )
                        self.plotter.enable_cell_picking(mesh=showmesh)

                        if self.checkBox_Slicing.isChecked(): 
                            angle = float(self.lineEdit_slicingAngle.text().strip())
                            radian_angle = math.radians(angle)
                            if self.show_qualityCheck: 
                                sliced = showmesh.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                                self.plotter_qulity = self.plotter.add_mesh(sliced, opacity=1.0, show_edges=True)
                            elif self.solidClip: 
                                sliced = showmesh.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                                self.plotter_qulity = self.plotter.add_mesh(sliced, opacity=1.0, show_edges=True, color=clr)
                            else: 
                                sliced = surface.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                                self.plotter_qulity = self.plotter.add_mesh(sliced,color='red', opacity=1.0)
                            
                        
                    cnt += 1 
            else: 
                cnt = 0 
                for mesh, clr, edge, surface in zip(self.meshes, self.colors, self.edges, self.surfaces):
                    try: 
                        if item: 
                            vmax = mesh[item].max(); vmin = mesh[item].min()
                            vgap = vmax - vmin 
                            low = float(ilow); high = float(ihigh) 
                            start = vmin + vgap * low; end = vmin + vgap * high
                            self.lineEdit_colorRange_value.setText("%.1f"%(start))
                            self.lineEdit_colorRange_value1.setText("%.1f"%(end))
                            self.valueStart = start; self.valueEnd = end 
                            self.vmin = vmin; self.vmax = vmax; self.vgap= vgap 

                        if self.show_edges: 
                            clippedEdge =  self.clipping(edge)
                            self.plotter_clippedEdges = self.plotter.add_mesh(clippedEdge, color=self.color_edge_line[self.click_show_edge%self.nColor_edge_line][0], line_width=self.color_edge_line[self.click_show_edge%self.nColor_edge_line][1])
                        
                        if self.radioButton_SDB_sed.isChecked() or self.radioButton_SDB_eld.isChecked():  
                            clippedMesh = self.clipping(mesh)
                            dargs = dict(scalars=item, cmap='rainbow', show_edges=self.show_meshLine, n_colors=150, clim=[start, end], below_color='white', edge_color=self.color_meshLine)
                            self.plotter_qulity = self.plotter.add_mesh(clippedMesh, interpolate_before_map=True, opacity=self.opecity, 
                                scalar_bar_args={'title': ' %s  - interpolated'%(item)}, **dargs)
                            if self.checkBox_Slicing.isChecked(): 
                                angle = float(self.lineEdit_slicingAngle.text().strip())
                                radian_angle = math.radians(angle)
                                sliced = clippedMesh.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                                self.plotter_qulity = self.plotter.add_mesh(sliced, interpolate_before_map=True, opacity=1.0, 
                                    scalar_bar_args={'title': ' %s  - interpolated'%(item)}, **dargs)

                             
                            self.plotter.enable_cell_picking(mesh=clippedMesh)
                        elif self.radioButton_Temperature.isChecked(): 
                            clippedMesh = self.clipping(mesh)
                            dargs = dict(scalars=item, cmap='rainbow', show_edges=self.show_meshLine, n_colors=150, clim=[start, end], below_color='white', edge_color=self.color_meshLine)
                            self.plotter_qulity = self.plotter.add_mesh(clippedMesh, interpolate_before_map=True, opacity=self.opecity, 
                                scalar_bar_args={'title': ' %s  - interpolated'%(item)}, **dargs)
                            if self.checkBox_Slicing.isChecked(): 
                                angle = float(self.lineEdit_slicingAngle.text().strip())
                                radian_angle = math.radians(angle)
                                try: 
                                    sliced = clippedMesh.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                                    self.plotter_qulity = self.plotter.add_mesh(sliced, interpolate_before_map=True, opacity=1.0, 
                                        scalar_bar_args={'title': ' %s  - interpolated'%(item)}, **dargs)
                                except Exception as ex: 
                                    print(ex)
                        else: 
                            if self.show_qualityCheck:
                                qmesh = mesh.compute_cell_quality('jacobian')
                                clippedMesh =  self.clipping(qmesh)
                                self.plotter_qulity = self.plotter.add_mesh(clippedMesh, show_edges=self.show_meshLine, pbr=False, diffuse=1, opacity=self.opecity, edge_color=self.color_meshLine )
                            elif self.solidClip :   
                                clippedMesh = self.clipping(mesh)          
                                self.plotter_qulity = self.plotter.add_mesh(clippedMesh, color=clr, show_edges=self.show_meshLine, pbr=False, diffuse=1, opacity=self.opecity, edge_color=self.color_meshLine )
                            else:               
                                clippedMesh = self.clipping(surface)              
                                self.plotter_qulity = self.plotter.add_mesh(clippedMesh, color=clr, show_edges=self.show_meshLine, pbr=False, diffuse=1, opacity=self.opecity, edge_color=self.color_meshLine )

                            if self.checkBox_Slicing.isChecked():
                                angle = float(self.lineEdit_slicingAngle.text().strip())
                                radian_angle = math.radians(angle)
                                sliced = clippedMesh.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])

                                if self.show_qualityCheck: 
                                    self.plotter_qulity = self.plotter.add_mesh(sliced, opacity=1.0, show_edges=True)
                                elif self.solidClip: 
                                    self.plotter_qulity = self.plotter.add_mesh(sliced, opacity=1.0, show_edges=True, color=clr)
                                else: 
                                    self.plotter_qulity = self.plotter.add_mesh(sliced,color='red', opacity=1.0)

                            self.plotter.enable_cell_picking(mesh=clippedMesh)
                    except Exception as EX: 
                        print (EX)
                        cnt += 1 
                        continue 
                    cnt += 1 
                    
        else: 
            if not self.xClipped and not self.yClipped and not self.zClipped: 
                self.clippedMesh= None     
                for mesh, clr, edge, surface in zip(self.meshes, self.colors, self.edges, self.surfaces):
                    if isinstance(surface, type(None)) : 
                        self.checkBox_Solid.setChecked(True)
                        self.solidClip = True 
                    if self.show_edges: 
                        self.plotter_edges = self.plotter.add_mesh(edge, color=self.color_edge_line[self.click_show_edge%self.nColor_edge_line][0],\
                            line_width=self.color_edge_line[self.click_show_edge%self.nColor_edge_line][1])
                    if self.show_qualityCheck: 
                        meshQuality = mesh.compute_cell_quality('jacobian')
                        self.plotter_qulity = self.plotter.add_mesh(meshQuality, show_edges=self.show_meshLine,\
                            pbr=False, diffuse=1, opacity=self.opecity, edge_color=self.color_meshLine)
                        self.plotter.enable_cell_picking(mesh=meshQuality)
                    
                    elif self.solidClip: 
                        self.plotter_surf = self.plotter.add_mesh(mesh, show_edges=self.show_meshLine, \
                            color=clr, metallic=0.3, pbr=False, diffuse=1, opacity=self.opecity, smooth_shading=False, edge_color=self.color_meshLine) 
                        self.plotter.enable_cell_picking(mesh=mesh)
                    else: 
                        self.plotter_surf = self.plotter.add_mesh(surface, show_edges=self.show_meshLine, color=clr, metallic=0.3, pbr=False, \
                            diffuse=1, opacity=self.opecity, smooth_shading=False, edge_color=self.color_meshLine) 
                        self.plotter.enable_cell_picking(mesh=surface)

                    if self.checkBox_Slicing.isChecked(): 
                        if '.ptn' in self.meshfile: 
                            if self.show_qualityCheck:
                                self.plotter_qulity = self.plotter.add_mesh_slice(meshQuality,  opacity=1.0, show_edges=True)
                            elif self.solidClip: 
                                self.plotter_qulity = self.plotter.add_mesh_slice(mesh, color=clr, opacity=1.0, show_edges=True)
                            else: 
                                self.plotter_qulity = self.plotter.add_mesh_slice(surface, color='red', opacity=1.0)
                        else: 
                            angle = float(self.lineEdit_slicingAngle.text().strip())
                            radian_angle = math.radians(angle)
                            
                            if self.show_qualityCheck:
                                sliced = meshQuality.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                                self.plotter_qulity = self.plotter.add_mesh(sliced, opacity=1.0, show_edges=True, colors=True, edge_color=self.color_meshLine)
                            elif self.solidClip: 
                                sliced = mesh.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                                self.plotter_qulity = self.plotter.add_mesh(sliced, opacity=1.0, show_edges=True, color=clr, edge_color=self.color_meshLine)
                            else: 
                                sliced = surface.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                                self.plotter_qulity = self.plotter.add_mesh(sliced, opacity=1.0, color='red')

            else: 
                for mesh, clr, edge, surface in zip(self.meshes, self.colors, self.edges, self.surfaces):
                    if isinstance(surface, type(None)) : 
                        self.checkBox_Solid.setChecked(True)
                        self.solidClip = True
                        
                    if self.solidClip: clippedMesh = mesh 
                    else: clippedMesh = surface 

                    clippedMesh = self.clipping(clippedMesh) 
                    try: 
                        if self.show_edges: 
                            clippedEdge = self.clipping(edge) 
                            self.plotter_clippedEdges = self.plotter.add_mesh(clippedEdge, \
                                color=self.color_edge_line[self.click_show_edge%self.nColor_edge_line][0],\
                                    line_width=self.color_edge_line[self.click_show_edge%self.nColor_edge_line][1])
                        if self.show_qualityCheck:  
                            meshQuality = clippedMesh.compute_cell_quality('jacobian')
                            self.plotter_clippedQuality = self.plotter.add_mesh(meshQuality, show_edges=self.show_meshLine, \
                                pbr=False, diffuse=1, opacity=self.opecity, edge_color=self.color_meshLine)
                            self.plotter.enable_cell_picking(mesh=meshQuality)
                        else: 
                            self.plotter_clippedMesh = self.plotter.add_mesh(clippedMesh, show_edges=self.show_meshLine, \
                                color=clr, metallic=0.3, pbr=False, diffuse=1, opacity=self.opecity, smooth_shading=False, edge_color=self.color_meshLine) 
                            self.plotter.enable_cell_picking(mesh=clippedMesh)
                    except Exception as EX: 
                        print (EX)
                        continue 

                    if self.checkBox_Slicing.isChecked(): 
                        if '.ptn' in self.meshfile: 
                            if self.show_qualityCheck:
                                self.plotter_qulity = self.plotter.add_mesh_slice(meshQuality,  opacity=1.0, show_edges=True, edge_color=self.color_meshLine)
                            elif self.solidClip: 
                                self.plotter_qulity = self.plotter.add_mesh_slice(clippedMesh, color=clr, opacity=1.0, show_edges=True, edge_color=self.color_meshLine)
                            else: 
                                self.plotter_qulity = self.plotter.add_mesh_slice(clippedMesh, color='red', opacity=1.0)

                        else: 

                            angle = float(self.lineEdit_slicingAngle.text().strip())
                            radian_angle = math.radians(angle)

                            if self.show_qualityCheck:
                                sliced = meshQuality.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])
                            else: 
                                sliced = clippedMesh.slice(normal=[math.cos(radian_angle), 0, math.sin(radian_angle)])

                            if self.solidClip: 
                                self.plotter_qulity = self.plotter.add_mesh(sliced, opacity=1.0, show_edges=True, edge_color=self.color_meshLine)                             
                            else: 
                                self.plotter_qulity = self.plotter.add_mesh(sliced, color='red', opacity=1.0)                             
                    
        # if not self.radioButton_cPres.isChecked():
        #     lights = Mesh.lighting()
        #     for light in lights: 
        #         self.plotter.add_light(light)    

        if self.defaultColor_Background: 
            self.plotter.set_background('gray', top='white')
        else: 
            self.plotter.set_background('white')
            ## dark theme 
            # Mesh.dark_Theme()
            # self.plotter.set_background('black')
        self.plotter.enable_parallel_projection()
        self.plotter.add_axes()
        

        if not isinstance(self.camera_position, type(None)): 
            # self.plotter.camera_position = self.camera_position
            self.plotter.camera = self.copied_camera 
        else: 
            self.get_camera_position()

        self.showMesh_addingSearchedElements(changeOpecity=False)
        if nodeplotRecursive: self.showMesh_addingSearchedNodes()
        
        
        self.plotter.show()

    def clipping(self, clipped): 
        
        if self.xClipped : 
            if self.x_revClipping: 
                clipped = clipped.clip(normal=(-1, 0, 0), value=self.xClippingShift)
            else: 
                clipped = clipped.clip(normal=(1, 0, 0), value=self.xClippingShift)
        if self.yClipped :
            if self.y_revClipping: 
                clipped = clipped.clip(normal=(0, -1, 0), value=self.yClippingShift)
            else: 
                clipped = clipped.clip(normal='y', value=self.yClippingShift)
        if self.zClipped :
            if self.z_revClipping:
                clipped = clipped.clip(normal=(0, 0, -1), value=self.zClippingShift)
            else: 
                clipped = clipped.clip(normal='z', value=self.zClippingShift)
        return clipped

    def defineColorMap(self, mesh, item, vmin, vmax, div, isSurf=False):
        if isSurf: 
            scalars = np.empty(mesh.n_points)
        else: 
            scalars = np.empty(mesh.number_of_cells)
        vgap = vmax - vmin  
        scalars[mesh[item] >= vmin + vgap * div[9] ] = 9  # red
        scalars[mesh[item] <  vmin + vgap * div[8] ] = 8  # grey
        scalars[mesh[item] <  vmin + vgap * div[7] ] = 7  # blue
        scalars[mesh[item] <  vmin + vgap * div[6] ] = 6  # blue
        scalars[mesh[item] <  vmin + vgap * div[5] ] = 5  # blue
        scalars[mesh[item] <  vmin + vgap * div[4] ] = 4  # yellow
        scalars[mesh[item] <  vmin + vgap * div[3] ] = 3  # blue
        scalars[mesh[item] <  vmin + vgap * div[2] ] = 2  # blue
        scalars[mesh[item] <  vmin + vgap * div[1] ] = 1  # blue
        scalars[mesh[item] <= vmin + vgap * div[0] ] = 0  # black
        colormap = ['gray', 'navy', 'blue', 'darkgreen', 'green', 'yellow', 'orange', 'orangered' ,'red', 'firebrick']

        return colormap, scalars 

    def replaceCells(self) :
        try: 
            picked = self.plotter.picked_cells
            self.clearPlotter()
            self.plotter.add_mesh(picked, show_edges=self.show_meshLine, color='gray', metallic=0.3, pbr=False, diffuse=1, opacity=self.opecity, smooth_shading=False, edge_color='gray') 
            lights = Mesh.lighting()
            for light in lights: 
                self.plotter.add_light(light)    

            if self.defaultColor_Background: 
                self.plotter.set_background('gray', top='white')
            else: 
                self.plotter.set_background('white')
            self.plotter.enable_parallel_projection()
            self.plotter.add_axes()

            self.plotter.show()
        except: 
            self.plotting()

    def showSearchedNodes(self): 
        self.searchedNodes=[]
        text = self.lineEdit_showNodes.text()
        self.searchedNodes = parsingIDs(text) 
        self.showMesh_addingSearchedNodes()

    def showSearchedElements(self): 
        self.searchedElements=[]
        text = self.lineEdit_showElements.text()
        self.searchedElements = parsingIDs(text)
        self.showMesh_addingSearchedElements()


    def showMesh_addingSearchedNodes(self): 
        for pts in self.searched_points: 
            self.plotter.remove_actor(pts)

        self.searched_points=[]
        self.searched_pointcloud = Mesh.generatePointCloud(self.searchedNodes, self.nodes)
        # print(self.searched_pointcloud.n_cells)
        if self.searched_pointcloud.n_cells > 0: 
            self.searched_points.append(self.plotter.add_point_labels(self.searched_pointcloud, 'label', point_size=10, font_size=10,  shape_color='gray', point_color='maroon') )  # , color='maroon', render_points_as_spheres=True)
        else: 
            self.get_OpecityValue()

    def showMesh_addingSearchedElements(self, changeOpecity=True): 

        for sCells in self.searchedCells: 
            self.plotter.remove_actor(sCells)

        self.searchedCells =[]
        for idx, elements, nodes in zip(self.idx_element, self.elements, self.nodes): 
            searched_cells = Mesh.generateMesh_searched(self.searchedElements,idx, elements, nodes)
            if not isinstance(searched_cells, type(None)): 
                self.searchedCells.append(self.plotter.add_mesh(searched_cells, color='red', line_width=2) )
        if changeOpecity: 
            self.horizontalSlider_opacity.setSliderPosition(30)
            self.opecity = self.horizontalSlider_opacity.value() / 100.0
            self.lineEdit_opecity.setText(str(int(self.opecity*100)))
                
        
def parsingIDs(text): 
    text = text.split(",")
    
    ids =[]
    for txt in text:
        txt=txt.strip()
        if 'N' in txt or 'n' in txt: 
            continue 
        try: 
            if '~' in txt: 
                t1, t2 = txt.split("~")
                for i in range(int(t1.strip()), int(t2.strip())+1) : 
                    ids.append(i) 
            elif ':' in txt: 
                t1, t2 = txt.split(":")
                for i in range(int(t1.strip()), int(t2.strip())+1) : 
                    ids.append(i) 
            elif '-' in txt: 
                t1, t2 = txt.split("-")
                for i in range(int(t1.strip()), int(t2.strip())+1) : 
                    ids.append(i) 
            elif "" == txt: 
                continue 
            else: 
                i = int(txt)
                if i <=0: continue 
                ids.append(i)

        except Exception as EX: 
            print(EX, txt )
            
            continue 
    
    return ids 

    
def writeworkingdirectory(readfile, dfile='pdir.dir'): 
    cwd=''
    drs = readfile.split("/")
    for i, dr in enumerate(drs): 
        cwd += dr + '/'
        if i == len(drs) -2 : break 
    f= open(dfile, "w")
    f.write(cwd)
    f.close()

    return cwd 
def writingError(ex): 
    fp = open('error.err', 'w')
    fp.write(str(ex))
    fp.close() 

if __name__ == "__main__":
    import sys
    
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    ui.operating()
    MainWindow.show()
    sys.exit(app.exec_())
    
