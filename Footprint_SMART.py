# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'footprint.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets, QtNetwork

import struct
from os.path import isfile 
from os import getcwd, system, remove
import math, glob, json
from PyQt5.sip import ispycreated
import numpy as np 

import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar

import paramiko as FTP 

class StdoutRedirect(QtCore.QObject):
    printOccur = QtCore.pyqtSignal(str, str, name="print")
 
    def __init__(self, *param):
        QtCore.QObject.__init__(self, None)
        self.daemon = True
        self.sysstdout = sys.stdout.write
        self.sysstderr = sys.stderr.write
 
    def stop(self):
        sys.stdout.write = self.sysstdout
        sys.stderr.write = self.sysstderr
 
    def start(self):
        sys.stdout.write = self.write
        sys.stderr.write = lambda msg : self.write(msg, color="red")
 
    def write(self, s, color="black"):
        sys.stdout.flush()
        self.printOccur.emit(s, color)

def readSDB(sdb): 

    CAMBER = [0.0]
    NLB   = []      
    NODE  = []  
    ELM2D = []
    ELM3D = []
    ELB   = []
    DISP  = []
    RR    = []
    RIM_ROAD =[]

    file = open(sdb, 'rb')

    file.seek(0,2); fend = file.tell() #find the end position of binary file
    file.seek(0);   fpos = file.tell() #find the start position of binary file
    # # print fpos, fend
    testfile = open("Node.inp","w")

    
    READ_LENGTH = 0
    
    #Read from start to end
    while file.tell() < fend:
        #distinguish each information from BlockID with 4 byte
        #each information includes title, local coordinates, nodes, elements(2D & 3D), rim, and road
        BlockID  = struct.unpack('i', file.read(4))[0]

        if BlockID == 11:
            BlockLength = struct.unpack('i', file.read(4))[0]
            
            BlockTitle = ''
            for i in range(BlockLength):    
                BlockTitle += str(struct.unpack('c', file.read(1))[0])
            # print (BlockLength, "Block Titie=%s"%(BlockTitle)) 
        elif BlockID == 12:
            #we can check the local coordinate of tire and camber angle by BlockID 12
            LocalCoord = []
            i = 0
            while i < 9:
                LocalCoord.append(struct.unpack('d', file.read(8))[0])
                i = i + 1
            CAMBER[0] = math.atan(LocalCoord[5]/LocalCoord[4])*180/math.pi
            # print CAMBER
            del LocalCoord
        elif BlockID == 21:
            #we can check the total node number(=NodesNUM) and each label & X,Y,Z coordinates by BlockID 21
            NodesNUM = struct.unpack('i', file.read(4))[0]
            i = 0
            while i < NodesNUM:
                Label = struct.unpack('i', file.read(4))[0]
                NLB.append(Label) #for making of abaqus odb file
                i = i + 1
            # print "Total Node Number =", len(NLB)
            testfile.writelines("*NODE,\n")
            i = 0
            while i < NodesNUM:
                X = struct.unpack('d', file.read(8))[0]
                Y = struct.unpack('d', file.read(8))[0]
                Z = struct.unpack('d', file.read(8))[0]
                NODE.append([NLB[i], X, Y, Z, 0.0]) #for making of abaqus odb file
                testfile.writelines(" %8d, %5.6e, %5.6e, %5.6e\n" % (NLB[i], X, Y, Z))
                i = i + 1
        elif BlockID == 31:
            #we can check the total 3d solid element number(=E3DNUM) and each label & nodes by BlockID 31
            E3DNUM = struct.unpack('i', file.read(4))[0]
            i = 0
            while i < E3DNUM:
                ID = struct.unpack('i', file.read(4))[0]
                N1 = struct.unpack('i', file.read(4))[0]
                N2 = struct.unpack('i', file.read(4))[0]
                N3 = struct.unpack('i', file.read(4))[0]
                N4 = struct.unpack('i', file.read(4))[0]
                N5 = struct.unpack('i', file.read(4))[0]
                N6 = struct.unpack('i', file.read(4))[0]
                N7 = struct.unpack('i', file.read(4))[0]
                N8 = struct.unpack('i', file.read(4))[0]
                ELM3D.append([ID, N1, N2, N3, N4, N5, N6, N7, N8])
                i  = i + 1
        elif BlockID == 32:
            #we can check the total 2d element number(=E2DNUM) and each label & nodes by BlockID 32
            E2DNUM = struct.unpack('i', file.read(4))[0]
            testfile.writelines("*ELEMENT, TYPE=M3D4R\n")
            # Surf.count = E2DNUM
            i = 0
            while i < E2DNUM:
                ID = struct.unpack('i', file.read(4))[0]
                N1 = struct.unpack('i', file.read(4))[0]
                N2 = struct.unpack('i', file.read(4))[0]
                N3 = struct.unpack('i', file.read(4))[0]
                N4 = struct.unpack('i', file.read(4))[0]
                ELM2D.append([ID, N1, N2, N3, N4])
                testfile.writelines(" %8d, %8d, %8d, %8d, %8d\n" % (ID, N1, N2, N3, N4))
                i  = i + 1
        elif BlockID == 51 or BlockID == 52:
            #we can check the elset name and each elset number(=ENUM) by BlockID 51&52
            BlockLength = struct.unpack('i', file.read(4))[0]
            Eleset = ''
            i = 0
            while i < BlockLength:
                Eleset = Eleset + str(struct.unpack('c', file.read(1))[0])
                i = i + 1
            BlockFlag   = struct.unpack('i', file.read(4))[0]
            ENUM = struct.unpack('i', file.read(4))[0]
            ESET = []
            i = 0
            while i < ENUM:
                ESET.append(struct.unpack('i', file.read(4))[0])
                i = i + 1
            # print "Finish to Read", Eleset
            del ESET
        elif BlockID == 61:
            #we can check the Rim Information by BlockID 61
            # print "Read Rim Information and Save them!"
            ControlNodeID = struct.unpack('i', file.read(4))[0]
            # print "Rim Control Node =", ControlNodeID
            X = struct.unpack('d', file.read(8))[0]
            Y = struct.unpack('d', file.read(8))[0]
            Z = struct.unpack('d', file.read(8))[0]
            R = struct.unpack('d', file.read(8))[0]
            W = struct.unpack('d', file.read(8))[0]
            G = struct.unpack('i', file.read(4))[0]
            RIM_ROAD.append([ControlNodeID, X, Y, Z])
            # # print "R, W, G =", R, W, G
            i = 0
            while i < G:
                BlockFlag   = struct.unpack('i', file.read(4))[0]
                # # print "BlockFlag = ", BlockFlag
                i = i + 1
            i = 0
            while i < G:
                X1 = struct.unpack('d', file.read(8))[0]
                Y1 = struct.unpack('d', file.read(8))[0]
                X2 = struct.unpack('d', file.read(8))[0]
                Y2 = struct.unpack('d', file.read(8))[0]
                # # print "X1, Y1, X2, Y2 =", X1*1000, Y1*1000, X2*1000, Y2*1000
                i = i + 1
        elif BlockID == 62:
            #we can check the Road Information by BlockID 62
            # print "Read Road Information and Save them!"
            Tref = struct.unpack('d', file.read(8))[0]
            ControlNodeID = struct.unpack('i', file.read(4))[0]
            # print "Road Control Node =", ControlNodeID
            X = struct.unpack('d', file.read(8))[0]
            Y = struct.unpack('d', file.read(8))[0]
            Z = struct.unpack('d', file.read(8))[0]
            R = struct.unpack('d', file.read(8))[0]
            W = struct.unpack('d', file.read(8))[0]
            L = struct.unpack('d', file.read(8))[0]
            RIM_ROAD.append([ControlNodeID, X, Y, Z])
        elif BlockID == 999:
            BlockID     = struct.unpack('i', file.read(4))[0]
            ESP         = ''
            i = 0
            while i < 4:
                ESP     = ESP+ str(struct.unpack('c', file.read(1))[0])
                i = i + 1
            RecordHead  = struct.unpack('i', file.read(4))[0]
            BlockID     = struct.unpack('i', file.read(4))[0]
            SolverInfo  = ''
            i = 0
            while i < 42:
                SolverInfo = SolverInfo+ str(struct.unpack('c', file.read(1))[0])
                i = i + 1
            i = 0
            while i < 9:
                BlockID     = struct.unpack('i', file.read(4))[0]
                i = i + 1
            SimulationType = ''
            i = 0
            while i < 26:
                SimulationType = SimulationType+ str(struct.unpack('c', file.read(1))[0])
                i = i + 1
        else:
            break

    # del NLB, XYZ, ELM2D, ELM3D, DISP
    testfile.close()
    
    for e in ELM3D: 
        if e[7] == e[8]: 
            e[4] = e[5]; e[5] = e[6]; e[6] = e[7]; e[8] = 0; e[7] =0 

    # ELM3D =  np.array(ELM3D)
    # ELM2D = np.array(ELM2D)
    # print ("Node", np.array(NODE))
    # print ("RIM ROAD", RIM_ROAD)

    if len(NODE) > 0: #and len(Surf.surflabel) > 0:
        return NODE, ELM2D, ELM3D, RIM_ROAD
    else:
        return -1

def Sorting(np_lst, item=0, reverse=False):
    tmpNode=[]
    for nd in np_lst:    tmpNode.append(nd)  

    try: arr = np_lst[:, item]
    except: 
        np_lst = np.array(np_lst)
        arr = np_lst[:, item]

    if reverse == False: args = np.argsort(arr)
    else:                args = np.argsort(arr)[::-1]
    
    sortedlist = []
    for i, arg in enumerate(args):
        sortedlist.append(tmpNode[arg])
    return  np.array(sortedlist)

def SDBResult_READ(sdbResult, NODE):
    # NODE, ELB, DISP, RR, HeatUniformGenRate, EnergyLossAccum, VisEnergy, StrainLongTerm, Deformed_RIM_ROAD
    resultsfile = open(sdbResult, 'rb')

    HeatUniformGenRate=[]; HeatHourGlassGenRate=[]
    EnergyLossAccum = []
    VisEnergy = []
    StrainLongTerm = []; StrainLongTermHourglass=[]
    Deformed_RIM_ROAD = []
    Temperature = []
    
    resultsfile.seek(0,2); fend = resultsfile.tell() #find the end position of binary file
    resultsfile.seek(0);   fpos = resultsfile.tell() #find the start position of binary file
    # print fpos, fend
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    RecordHeaderID = 0
    READ_NUM       = 0
    NodeNUM        = 0
    TREAD_ELMENTNUM= 0
    
    tmpELB = [] 
    

    DISP = []
    while resultsfile.tell() < fend:
        RecordHeaderID     = struct.unpack('i', resultsfile.read(4))[0]
        if RecordHeaderID == 13:
            RecordValue    = struct.unpack('i', resultsfile.read(4))[0]
            # print"RecordHeaderID = ", RecordHeaderID, "Record Value = ", RecordValue
            # print ("RecordHeaderID", RecordHeaderID, ", Record Value", RecordValue)
            OutputStepTime = struct.unpack('d', resultsfile.read(8))[0]
            print ("SDB Result Time=%.2f"%OutputStepTime)
            # printOutputStepTime
            OutputStepID       = struct.unpack('i', resultsfile.read(4))[0]
            # print ("Output step ID", OutputStepID)
            # printOutputStepID
            OutputStepName = ''
            i = 0 
            while i < 26:
                OutputStepName     = OutputStepName + str(struct.unpack('c', resultsfile.read(1))[0])
                i = i + 1
            # print"OutputStepName = ", OutputStepName
            # print ("output step name",OutputStepName )
            OutputStepNo      = struct.unpack('i', resultsfile.read(4))[0]
            # printOutputStepNo
            OutputStepNode    = struct.unpack('i', resultsfile.read(4))[0]
            # printOutputStepNode
            NodeNUM           = struct.unpack('i', resultsfile.read(4))[0]
            # print"NodeNUM = ", NodeNUM
            READ_NUM     = NodeNUM
            i = 0
            while i < READ_NUM:
                NodeID = int(struct.unpack('i', resultsfile.read(4))[0])
                DISP.append([0.0,0.0,0.0]) #for making of abaqus odb file
                i = i + 1
            # print"finish to read the Node Lists!"
        elif RecordHeaderID == 14:
            RecordValue    = struct.unpack('i', resultsfile.read(4))[0]
            # print ("RecordHeaderID = ", RecordHeaderID, "Record Value = ", RecordValue)

            IDATA_TYPE     = struct.unpack('i', resultsfile.read(4))[0]
            IOUT_TYPE      = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP1         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP2         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP3         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP4         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP5         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP6         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP7         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP8         = struct.unpack('i', resultsfile.read(4))[0]
            IDIRECTION     = struct.unpack('i', resultsfile.read(4))[0]
            ICALC_WARN     = struct.unpack('i', resultsfile.read(4))[0]
            IDMINV         = struct.unpack('i', resultsfile.read(4))[0]
            IDMAXV         = struct.unpack('i', resultsfile.read(4))[0]
            VMIN           = struct.unpack('d', resultsfile.read(8))[0]
            VMAX           = struct.unpack('d', resultsfile.read(8))[0]
            DATA_TITLE     = ''
            i = 0 
            while i < 26:
                DATA_TITLE = DATA_TITLE + str(struct.unpack('c', resultsfile.read(1))[0])
                i = i + 1
            # printDATA_TITLE
            i = 0
            if RecordValue == 102:
                while i < READ_NUM:
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    DISP[i][0] = Value #for making of abaqus odb file
                    NODE[i][1] = NODE[i][1] + Value
                    i = i + 1
            if RecordValue == 103:
                while i < READ_NUM:
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    DISP[i][1] = Value #for making of abaqus odb file
                    NODE[i][2] = NODE[i][2] + Value
                    i = i + 1
            if RecordValue == 104:
                while i < READ_NUM:
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    DISP[i][2] = Value #for making of abaqus odb file
                    NODE[i][3] = NODE[i][3] + Value
                    i = i + 1
            if RecordValue == 3101:
                for i in range(READ_NUM):
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    NODE[i][4] = NODE[i][4] + Value
            elif RecordValue == 900000054:
                while i < READ_NUM:
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    i = i + 1
            elif RecordValue == 900001001: # Heat Uniform Generate Rate
                while i < READ_NUM:
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    HeatUniformGenRate.append(Value)
                    i = i + 1
            elif RecordValue == 900001002: # Heat Uniform Generate Rate
                while i < READ_NUM:
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    HeatHourGlassGenRate.append(Value)
                    i = i + 1
            elif RecordValue == 900001003: # Energy Uniform Loss Accumulation
                print ("Energy Uniform Loss Accumulation")
                while i < READ_NUM:
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    EnergyLossAccum.append(Value)
                    i = i + 1
            elif RecordValue == 900001005: # Vis Energy In Uniform Storage
                print ("Vis Energy In Uniform Storage")
                while i < READ_NUM:
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    VisEnergy.append(Value)
                    ELB.append(tmpELB[i])
                    RR.append([tmpELB[i],Value])
                    i = i + 1
                del tmpELB
                tmpELB = []
            elif RecordValue == 900001007: # Strain Uniform Long Term E
                while i < READ_NUM:
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    StrainLongTerm.append(Value)
                    i = i + 1
            elif RecordValue == 900001008: # Strain Uniform Long Term E Hourglass
                while i < READ_NUM:
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    StrainLongTermHourglass.append(Value)
                    i = i + 1
            else:
                 
                while i < READ_NUM:
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    i = i + 1
        elif RecordHeaderID == 2:
            ELMENTNUM = struct.unpack('i', resultsfile.read(4))[0]
            i = 0
            while i < ELMENTNUM:
                TreadID = struct.unpack('i', resultsfile.read(4))[0]
                tmpELB.append(TreadID)
                i = i + 1
            READ_NUM     = ELMENTNUM
        elif RecordHeaderID == 1:
            ELMENT_NUM   = struct.unpack('i', resultsfile.read(4))[0]
            i = 0
            while i < ELMENT_NUM:
                ID = struct.unpack('i', resultsfile.read(4))[0]
                Deformed_RIM_ROAD.append([ID, 0.0, 0.0, 0.0])
                i = i + 1
            READ_NUM     = ELMENT_NUM
            while resultsfile.tell() < fend:
                RecordHeaderID     = struct.unpack('i', resultsfile.read(4))[0]
                RecordValue    = struct.unpack('i', resultsfile.read(4))[0]
                IDATA_TYPE     = struct.unpack('i', resultsfile.read(4))[0]
                IOUT_TYPE      = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP1         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP2         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP3         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP4         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP5         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP6         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP7         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP8         = struct.unpack('i', resultsfile.read(4))[0]
                IDIRECTION     = struct.unpack('i', resultsfile.read(4))[0]
                ICALC_WARN     = struct.unpack('i', resultsfile.read(4))[0]
                IDMINV         = struct.unpack('i', resultsfile.read(4))[0]
                IDMAXV         = struct.unpack('i', resultsfile.read(4))[0]
                VMIN           = struct.unpack('d', resultsfile.read(8))[0]
                VMAX           = struct.unpack('d', resultsfile.read(8))[0]
                DATA_TITLE     = ''
                i = 0 
                while i < 26:
                    DATA_TITLE = DATA_TITLE + str(struct.unpack('c', resultsfile.read(1))[0])
                    i = i + 1
                i = 0
                if RecordValue == 102:
                    while i < READ_NUM:
                        Value = struct.unpack('d', resultsfile.read(8))[0]
                        Deformed_RIM_ROAD[i][1] = Value
                        i = i + 1
                if RecordValue == 103:
                    while i < READ_NUM:
                        Value = struct.unpack('d', resultsfile.read(8))[0]
                        Deformed_RIM_ROAD[i][2] = Value
                        i = i + 1
                if RecordValue == 104:
                    while i < READ_NUM:
                        Value = struct.unpack('d', resultsfile.read(8))[0]
                        Deformed_RIM_ROAD[i][3] = Value
                        i = i + 1
                if RecordValue == 106:
                    while i < READ_NUM:
                        Value = struct.unpack('d', resultsfile.read(8))[0]
                        i = i + 1
                if RecordValue == 107:
                    while i < READ_NUM:
                        Value = struct.unpack('d', resultsfile.read(8))[0]
                        i = i + 1
                if RecordValue == 108:
                    while i < READ_NUM:
                        Value = struct.unpack('d', resultsfile.read(8))[0]
                        i = i + 1
                else:
                    while i < READ_NUM:
                        Value = struct.unpack('d', resultsfile.read(8))[0]
                        i = i + 1
        else:
            break

    del tmpELB
    resultsfile.close()
    
    HeatGen = [HeatUniformGenRate, HeatHourGlassGenRate]
    iSED = [StrainLongTerm, StrainLongTermHourglass]

    print ("SDB results are loaded")
    
    
    if len(HeatGen) > 0:
        return np.array(NODE), Deformed_RIM_ROAD, HeatGen, iSED
    else:
        return -1
def isNumber(s):
  try:
    float(s)
    return True
  except ValueError:
    return False
def meshgrid_in_Quadrilateral(xs, ys, num=10, endpoint=True, vs=None): 
    # xs=[x1, x2, x3, x4]; ys=[y1, y2, y3, y4]
    s = np.linspace(-1, 1, num)
    t = np.linspace(-1, 1, num)
    if not endpoint: 
        s = np.delete(s, 0, axis=0); s=np.delete(s, -1, axis=0)
        t = np.delete(s, 0, axis=0); t=np.delete(s, -1, axis=0)
    if isinstance(vs, type(None)): 
        px=[]; py=[]
        for m in s: 
            tx=[]; ty=[]
            for n in t: 
                tx.append( 0.25*((1-m)*(1-n)*xs[0] + (1+m)*(1-n)*xs[1] + (1+m)*(1+n)*xs[2] + (1-m)*(1+n)*xs[3]) )
                ty.append( 0.25*((1-m)*(1-n)*ys[0] + (1+m)*(1-n)*ys[1] + (1+m)*(1+n)*ys[2] + (1-m)*(1+n)*ys[3]) )
            px.append(tx)
            py.append(ty)

        return np.array(px), np.array(py)
    else: 
        px=[]; py=[]; vy=[]
        for m in s: 
            tx=[]; ty=[]; tv=[]
            for n in t: 
                tx.append( 0.25*((1-m)*(1-n)*xs[0] + (1+m)*(1-n)*xs[1] + (1+m)*(1+n)*xs[2] + (1-m)*(1+n)*xs[3]) )
                ty.append( 0.25*((1-m)*(1-n)*ys[0] + (1+m)*(1-n)*ys[1] + (1+m)*(1+n)*ys[2] + (1-m)*(1+n)*ys[3]) )
                tv.append( 0.25*((1-m)*(1-n)*vs[0] + (1+m)*(1-n)*vs[1] + (1+m)*(1+n)*vs[2] + (1-m)*(1+n)*vs[3]) )
            px.append(tx)
            py.append(ty)
            vy.append(tv)

        return np.array(px), np.array(py), np.array(vy)
def DistanceFromLineToNode2D(N0, nodes=[], xy=12, onlydist=0):
    x = int(xy/10)
    y = int(xy%10)

    N1=nodes[0]
    N2=nodes[1]
    N=[-1, 0, 0, 0]
    if round(N2[x]-N1[x], 8) and round(N2[y]-N1[y], 8): 
        A =  (N2[y]-N1[y])/(N2[x]-N1[x]) 
        cx = A / (A*A+1) *(N0[x]/A + N0[y] + A*N1[x] - N1[y])
        cy = A * (cx - N1[x]) + N1[y] 
        N[x] = cx
        N[y] = cy
        distance = math.sqrt((cx-N0[x])**2 + (cy-N0[y])**2)

    elif round(N2[x]-N1[x], 8) and round(N2[y]-N1[y], 8) == 0: 
        distance = abs(N0[y] - N1[y])
        N[x] = N0[x]
        N[y] = N1[y]

    else: 
        distance = abs(N0[x] - N1[x])
        
        N[x] = N1[x]
        N[y] = N0[y]
    if onlydist ==1: 
        return distance
    else: 
        return distance, N 
def findout_offset(numbers, step=10000, shift=0):
    nn =[]
    for n in numbers: 
        nn.append(n+shift)
    numbers = np.array(nn)
    imax = np.max(numbers) 
    # print (numbers, imax, shift)

    if imax < step: 
        return step
    offset=0
    steps = int(imax / step) 
    nlast = imax - steps*step 

    idxs = np.where(numbers>steps*step)[0]
    counting = len(idxs)

    # print (" Last counting", counting, steps, nlast, steps*step )

    for i in range(1, 100): 
        ix1 = np.where(numbers[:]>step*(i-1))[0]
        ix2 = np.where(numbers[:]<=step*i)[0]
        ix = np.intersect1d(ix1, ix2)
        # if i==1: print ("~%d : counting %d"%(step*i, len(ix)))
        
        if len(ix) == counting: 
            offset = i *step 
            break 
    # print (i)
    return offset 
class NODE:
    def __init__(self):
        self.Node = []
    def Add(self, d):
        self.Node.append(d)
    def NodeByID(self, n, SORT=0, **args):
        for key, value in args.items():
            if key == 'sort':
                SORT=int(value)
                
        N = len(self.Node)
        if SORT ==1:
            sorted(self.Node, key=lambda x:x[0])

        npnode = np.array(self.Node)
        idx = np.where(npnode[:,0] == n)[0]
        if len(idx) ==0: 
            print ("Cannot Find Node (%d)"%(n))
            NullList = [0, 0.0, 0.0, 0.0]
            return NullList
        else: 
            return self.Node[idx[0]]
        
    def Sort(self, item=0, reverse=False):
        tmpNode = NODE()
        try:
            arr = self.Node[:, item]
        except:
            npNode = np.array(self.Node)
            arr = npNode[:, item]
        if reverse == False: args = np.argsort(arr)
        else:                args = np.argsort(arr)[::-1]
        for nd in self.Node:    tmpNode.Add(nd) 
        sortedlist = []
        for i, arg in enumerate(args):
            self.Node[i] = tmpNode.Node[int(arg)]
            sortedlist.append(tmpNode.Node[int(arg)])
        del(tmpNode)
        sortedlist = np.array(sortedlist)
        return sortedlist
    def Combine(self, node):
        N = len(node.Node)
        for i in range(N): 
            self.Add(node.Node[i])
    
class SURFACE:
    def __init__(self):
        self.Surface=[]
    def Add(self, surf):
        self.Surface.append(surf)

    def AddName(self, name): 
        pre = 0 
        for surf in self.Surface:
            if surf[0] == name: 
                pre =1
                break 
        if pre == 0: 
            self.Surface.append([name])
    def AddSurface(self, name, number, face): 
        pre = 0 
        for i, surf in enumerate(self.Surface):
            if surf[0] == name: 
                self.Surface[i].append([number, face])
                pre =1 
                break 
        if pre ==0: 
            self.AddName(name)
            self.AddSurface(name, number, face)

class SFRIC: 
    def __init__(self):
        self.Node = NODE()
        self.Surface = SURFACE()
        self.Rim = NODE()
        self.Road = NODE()
        self.pNode = NODE()
        self.cNode = NODE()

class TIE:
    def __init__(self):
        self.Tie = []
    def Add(self, name, slave, master):
        self.Tie.append([name, slave, master])
class EDGE:
    def __init__(self):
        self.Edge = []
    def __del__(Self): 
        # print ("EDGE IS DELETED")
        pass

    def Help(self):
        print ("*********************************************************************************")
        print ("EDGE : Node1, Node2, Elset_Name, FacdID, Element_No, D")
        print (" D : -1= Edge, 0 = Free Edge, -2 = not Free Edge, 1= outer edges, Above 1(2~) = Tie No")
        print ("***************************************************************************")

    def Add(self, edge):
        self.Edge.append(edge)

    def Print(self, tail=0, head=0, **kwargs):
        Print_list(self.Edge, tail=tail, head=head, **kwargs)
        
    def Combine(self, iEdge):
        N = len(iEdge.Edge)
        for i in range(N): 
            self.Add(iEdge.Edge[i])

    def Sort(self, reverse=False):
        edges=[]
        e1 =[]; e2=[]
        for i, e in enumerate(self.Edge):
            edges.append([e[0], e[1], i])
            e1.append(e[0])
            e2.append(e[1])
            # print("%d, %d, %d"%(e[0], e[1], e[4]))

        edges = np.array(edges)
        e1 = np.array(e1)
        e2 = np.array(e2)

        
        if reverse == False:        
            e = np.setdiff1d(e1, e2) ## it remains the 1st node at the first element 
            col = 0
            ncol =1 
        else:                       
            e = np.setdiff1d(e2, e1)  ## it remains the 2nd node at the last element 
            col = 1
            ncol = 0 
        

        ## if it's is closed, there will be nothing 

        srted=[] 
        idx = np.where(edges[:,col] == e) [0]
        while len(idx)>0: 
            i = edges[ idx[0] ][2]
            # print ("sorting", self.Edge[i])
            srted.append(self.Edge[i])

            idx = np.where(edges[:,col] == self.Edge[i][ncol])[0]
        self.Edge = srted 
        return srted 
    def Image(self, Node, file='EDGE', marker ="", dpi=100):
        MembWidth = 0.5
        color = 'black'

        fig, ax = plt.subplots()
        ax.axis('equal')
        ax.axis('on')
        N = len(self.Edge)
        MinX = 100000.0
        MaxX = -100000.0
        MinY = 100000.0
        MaxY = -100000.0
        for i in range(N):
            N1 = Node.NodeByID(self.Edge[i][0])
            N2 = Node.NodeByID(self.Edge[i][1])
            x1 = N1[2]
            y1 = N1[3]
            x2 = N2[2]
            y2 = N2[3]
            plt.plot([x1, x2], [y1, y2], color, lw=MembWidth, marker=marker)
            if MinX > x1:
                MinX = x1
            if MaxX < x1:
                MaxX = x1
            if MinY > y1:
                MinY = y1
            if MaxY < y1:
                MaxY = y1
            if MinX > x2:
                MinX = x2
            if MaxX < x2:
                MaxX = x2
            if MinY > y2:
                MinY = y2
            if MaxY < y2:
                MaxY = y2
        plt.xlim(MinX - 0.01, MaxX + 0.01)
        plt.ylim(MinY - 0.01, MaxY + 0.01)
        plt.savefig(file, dpi=dpi)
class ELSET:
    def __init__(self):
        self.Elset = []

    def Print(self):
        print ("*************************************************************")
        print ("** [[Elset1, E11, E12, ..], {Elset2, E21, E22, ...], ...]")
        print ("*************************************************************")

    def AddName(self, name):
        exist = 0
        for i in range(len(self.Elset)):
            if self.Elset[i][0] == name:
                exist = 1
                break
        if exist == 0:
            self.Elset.append([name])

    def AddNumber(self, n, name):
        for i in range(len(self.Elset)):
            if self.Elset[i][0] == name:
                self.Elset[i].append(n)
    def Add(self, n, name): 
        exist = 0
        for i in range(len(self.Elset)):
            if self.Elset[i][0] == name:
                exist = 1
                self.Elset[i].append(n)
                break
        if exist == 0:
            self.Elset.append([name, n])
class ELEMENT:
    def __init__(self):
        self.Element = []
    def Add(self, e):
        self.Element.append(e)
    def Delete(self, n):
        N = len(self.Element)
        for i in range(N):
            if self.Element[i][0] == n:
                del (self.Element[i])
                break
    def DeleteDuplicate(self, id=1):
        npe = []
        for el in self.Element: 
            npe.append([el[0], el[2], el[3], el[4], el[6]])
        npe = np.array(npe)

        npe0 = npe[:,0]
        npe1 = np.unique(npe0)
        if len(npe0) != len(npe1): 
            i = 0 
            while i < len(self.Element): 
                idx = np.where(npe[:,0]==self.Element[i][0])[0]
                if len(idx) > 1: 
                    for ix in idx: 
                        if ix != i: 
                            del(self.Element[ix])
                            npe = np.delete(npe, ix, axis=0)
                            print (" >> Element %d was deleted."%(self.Element[i][0]))
                            i -= 1 
                            break 
                i += 1 

    def Nodes(self, **args):

        Node = NODE()
        for key, value in args.items():
            if key == 'Node' or key == 'node':
                Node = value


        I = len(self.Element)
        NL = []

        nds = []
        for el in self.Element: 
            nds.append(el[1]); nds.append(el[2]); 
            if el[3]>0: nds.append(el[3])
            if el[4]>0: nds.append(el[4])
        nds = np.array(nds, dtype=np.int32)
        NL = np.unique(nds)

        if len(Node.Node) == 0:  return NL
        
        npnd = np.array(Node.Node)
        NC = NODE() 
        for nd in NL: 
            ix = np.where(npnd[:,0] == nd) [0]
            if len(ix) == 1: 
                NC.Add([ int(npnd[ix[0]][0]), npnd[ix[0]][1], npnd[ix[0]][2], npnd[ix[0]][3]] )
        return NC 

    def Sort(self, item=0, reverse=False):
        sortedElement = ELEMENT()
        for i, element in enumerate(self.Element):
            sortedElement.Add(element)
            if i == 0:
                continue
            else:
                I = len(sortedElement.Element)
                for j, selement in enumerate(sortedElement.Element):
                    if reverse == True:
                        if selement[item] < element[item]:
                            del(sortedElement.Element[I-1])
                            sortedElement.Element.insert(j, element)
                            I = j 
                            break
                    else:
                        if selement[item] > element[item]:
                            del(sortedElement.Element[I-1])
                            sortedElement.Element.insert(j, element)
                            I = j 
                            break
        for i, element in enumerate(sortedElement.Element):
            self.Element[i] = element
        del(sortedElement)
    def Combine(self, element):
        N=len(element.Element)
        for i in range(N): 
            self.Add(element.Element[i])
    def AllEdge(self):
        Name = EDGE()
        N = len(self.Element)
        for i in range(N):
            if self.Element[i][6] == 4:
                Name.Add([self.Element[i][1], self.Element[i][2], self.Element[i][5], 'S1', self.Element[i][0], -1])
                Name.Add([self.Element[i][2], self.Element[i][3], self.Element[i][5], 'S2', self.Element[i][0], -1])
                Name.Add([self.Element[i][3], self.Element[i][4], self.Element[i][5], 'S3', self.Element[i][0], -1])
                Name.Add([self.Element[i][4], self.Element[i][1], self.Element[i][5], 'S4', self.Element[i][0], -1])
            elif self.Element[i][6] == 3:
                Name.Add([self.Element[i][1], self.Element[i][2], self.Element[i][5], 'S1', self.Element[i][0], -1])
                Name.Add([self.Element[i][2], self.Element[i][3], self.Element[i][5], 'S2', self.Element[i][0], -1])
                Name.Add([self.Element[i][3], self.Element[i][1], self.Element[i][5], 'S3', self.Element[i][0], -1])
        return Name
    def FreeEdge(self):
        edges = self.AllEdge()
        freeEdge = FreeEdge(edges)
        return freeEdge
    def OuterEdge(self, Node):
        FEdges = self.FreeEdge()
        OEdges = OuterEdge(FEdges, Node, self)
        return OEdges
        ## other method
        npn = np.array(Node.Node)
        free = self.FreeEdge()
        outer = EDGE()
        my = 10**7
        start = 0 
        for i, e in enumerate(free.Edge): 
            ix = np.where(npn[:,0] == e[0])[0][0]
            if npn[ix][2]> 0 and npn[ix][3]<my: 
                my = npn[ix][3]
                start = i 
        
        outer.Add(free.Edge[start])
        end = free.Edge[start][0]
        nxt = free.Edge[start]
        cnt = 0
        N=5
        while nxt[1] != end: 
            cnt +=1
            if cnt > 1000: 
                print(" Error to find outer edges")
                break 
            nt = self.NextEdge(nxt, free)
            if len(nt) ==1: 
                nxt = nt[0]
            elif len(nt) ==2: 
                fst = 0
                ne = nt[fst]
                ns = ne[0]
                for i in range(N): 
                    ne = self.NextEdge(ne, free)
                    if len(ne) ==2 : 
                        if ne[0][1] == ns or ne[1][1] == ns: 
                            fst = 1
                        break 
                    else: 
                        ne = ne[0]
                        if ne[1] == ns: 
                            fst = 1
                            break 
                nxt = nt[fst]
            outer.Add(nxt)
        return outer 
    def TieEdge(self, Node):
        FreeEdge = self.FreeEdge()
        OuterEdge(FreeEdge, Node, self)  # Don't Delete this line.
        TieNum = 1
        i = 0;        iTemp = 0;        j = 0
        connectedEdge = []
        TEdge = EDGE()
        while i < len(FreeEdge.Edge):
            if FreeEdge.Edge[i][5] < 1:
                TieNum += 1
                nodeStart = FreeEdge.Edge[i][0]
                FreeEdge.Edge[i][5] = TieNum
                TEdge.Add(FreeEdge.Edge[i])  # marked as TIE edge with No.
                iTemp = i
                while FreeEdge.Edge[iTemp][1] != nodeStart:
                    j += 1
                    if j > 100:
                        break  # in case infinite loop
                    connectedEdge = NextEdge(FreeEdge, iTemp)  # find next edge
                    if len(connectedEdge) == 1:  # in case of being found just 1 edge
                        iTemp = connectedEdge[0]
                    elif len(connectedEdge) == 2:  # when other tie is connected (2 ties are connected)
                        if FreeEdge.Edge[connectedEdge[0]][1] == nodeStart:
                            iTemp = connectedEdge[0]
                        elif FreeEdge.Edge[connectedEdge[1]][1] == nodeStart:
                            iTemp = connectedEdge[1]
                        else:
                            if FreeEdge.Edge[connectedEdge[0]][5] < 1 and FreeEdge.Edge[connectedEdge[1]][5] < 1:
                                iTemp = FindTieLoop(nodeStart, connectedEdge, FreeEdge)
                            elif FreeEdge.Edge[connectedEdge[0]][5] < 1:
                                iTemp = connectedEdge[0]
                            elif FreeEdge.Edge[connectedEdge[1]][5] < 1:
                                iTemp = connectedEdge[1]
                            else:
                                print ('[INPUT] {' + str(FreeEdge.Edge[connectedEdge[0]]) + ',' + str(FreeEdge.Edge[connectedEdge[1]]) + ' (0) TIE Conection InCompletion')
                                break
                    else:
                        print ('[INPUT] 2 or more Ties are Connected.')
                        break
                    # After finding next TIE Edge ################################
                    FreeEdge.Edge[iTemp][5] = TieNum
                    TEdge.Add(FreeEdge.Edge[iTemp])
                del connectedEdge
                connectedEdge = []
            i += 1
        return TEdge
    def MasterSlaveEdge(self, Node, Op = 0, **args):

        npn = np.array(Node.Node)
        for key, value in args.items():
            if key == 'op':
                Op = int(value)
        
        TieEdge = self.TieEdge(Node)
        iNum = 2
        mlength = 0 
        ErrRatio = 0.01
        
        NumTie = 0 
        N = len(TieEdge.Edge)
        for i in range(N):
            if TieEdge.Edge[i][5] > NumTie:
                NumTie = TieEdge.Edge[i][5]
            
        iMaster = []
        while iNum <=NumTie:
            MaxLength = 0.0
            SumLength = 0.0
            k = 0
            Save = 0
            while k < N:
                if TieEdge.Edge[k][5] == iNum:
                    # N1 = Node.NodeByID(TieEdge.Edge[k][0])
                    # N2 = Node.NodeByID(TieEdge.Edge[k][1])
                    ix = np.where(npn[:,0] == TieEdge.Edge[k][0])[0][0]; N1 = Node[ix]
                    ix = np.where(npn[:,0] == TieEdge.Edge[k][1])[0][0]; N2 = Node[ix]
                    Length = math.sqrt((N1[2]-N2[2])* (N1[2]-N2[2]) + (N1[3]-N2[3])*(N1[3]-N2[3]))
                    SumLength += Length
                    if Length > MaxLength:
                        MaxLength = Length
                        Save = k
                k += 1
            SumLength -= MaxLength
            if SumLength > MaxLength * (1+ErrRatio) or SumLength < MaxLength * (1-ErrRatio):
                print ('ERROR::PRE::TIE CREATION INCOMPLETE ON', TieEdge.Edge[Save][3])
            iMaster.append(Save)
            iNum += 1
        
        MasterEdge=EDGE()
        SlaveEdge =EDGE()
        M = len(iMaster)
        for i in range(N):
            exist = 0
            for j in range(M):
                if i == iMaster[j]:
                    MasterEdge.Add(TieEdge.Edge[i])
                    exist =1
                    break
            if exist == 0:
                SlaveEdge.Add(TieEdge.Edge[i])
        
        ## Op == 0 return MasterEdge and SlaveEdge
        ## Op == 1 return only Master Edge
        ## Op == 2 return Only Slave Edge
        if Op == 0:
            return MasterEdge, SlaveEdge
        elif Op == 1:
            return MasterEdge
        else:
            return SlaveEdge
    def Print(self, **kwargs): 
        Print_list(self.Element, **kwargs)
    def NextEdge(self, edge, edges, rev=0): 
        ed =[]
        if rev == 0: 
            for e in edges.Edge: 
                if e[0] == edge[1]: 
                    ed.append(e)
        else: 
            for e in edges.Edge: 
                if e[1] == edge[0]: 
                    ed.append(e)

        return ed 
class LAYOUT: 
    def __init__(self, meshfile): 
        self.Node = NODE()
        self.Element = ELEMENT()
        self.Elset = ELSET()
        self.Surface = SURFACE()
        self.carcassGa = 0.0
        self.moldOD=0.0
        self.GD=0.0
        self.UTG=0.0
        self.edge_outer=[]
        self.Mesh2DInformation(meshfile)

    def Mesh2DInformation(self, InpFileName):
        with open(InpFileName) as INP:
            lines = INP.readlines()
        skipComment = 0 
        for line in lines:
            if line[0] == '\n': continue 
            if '**' in line:
                if 'The List of Rebar Element sets' in line: 
                    skipComment =1 
                if skipComment ==0: 
                    if "C01" in line : 
                        w = line.split(",")
                        self.carcassGa = float(w[6].strip())
                    if 'CAVITY_OD' in line and not 'CODE' in line and not 'NODE' in line: 
                        txt = line.split(":")[1].strip()
                        self.moldOD = float(txt)/1000.0
                    if 'GROOVE DEPTH' in line : 
                        txt = line.split(":")[1].strip()
                        self.GD = float(txt)/1000.0
            
            elif '*' in line:
                word = list(line.split(','))
                if 'HEADING' in word[0].upper(): 
                    spt = 'HD'
                elif 'NODE' in word[0].upper(): 
                    spt = 'ND'
                elif 'ELEMENT' in word[0].upper():
                    # EL = list(word[1].split('='))
                    # EL = EL[1].strip()
                    if 'MGAX' in line:
                        spt = 'M1'
                    elif 'CGAX3' in line :
                        spt = 'C3'
                    elif 'CGAX4' in line :
                        spt = 'C4'
                    else:
                        spt = 'NN'
                elif 'SURFACE' in word[0].upper(): 
                    spt = 'SF'
                    name = word[2].split('=')[1].strip()
                    self.Surface.AddName(name)
                #                    print ('Name=', name, 'was stored', Surface.Surface)
                elif 'TIE' in word[0].upper(): 
                    spt = 'TI'
                    name = word[1].split('=')[1].strip()
                elif 'ELSET' in word[0].upper(): 
                    spt = 'ES'
                    name = word[1].split('=')[1].strip()
                    if name != "BETWEEN_BELTS" and name != "BD1" and name != "BetweenBelts":
                        self.Elset.AddName(name)

                elif 'NSET' in word[0].upper(): 
                    spt = 'NS'
                    name = word[1].split('=')[1].strip()

                else:
                    spt = ''
            else:
                word = list(line.strip().split(','))
                if spt == 'HD':
                    pass
                if spt == 'ND':
                    self.Node.Add([int(word[0]), float(word[3]), float(word[2]), float(word[1])])
                if spt == 'M1':
                    # Element   [EL No,                  N1,          N2,  N3, N4,'elset Name', N,  Area/length, CenterX, CenterY]
                    self.Element.Add([int(word[0]), int(word[1]), int(word[2]), 0, 0, '', 2])#, math.sqrt(math.pow(C1[1] - C2[1], 2) + math.pow(C1[2] - C2[2], 2)), (C1[1] + C2[1]) / 2.0, (C1[2] + C2[2]) / 2.0])
                if spt == 'C3':
                    self.Element.Add([int(word[0]), int(word[1]), int(word[2]), int(word[3]), 0, '', 3])#, A[0], A[1], A[2]])
                if spt == 'C4':
                    self.Element.Add([int(word[0]), int(word[1]), int(word[2]), int(word[3]), int(word[4]), '', 4])#, A[0], A[1], A[2]])
                if spt == 'NS':
                    pass
                if spt == 'ES':
                    if name.upper() != "BETWEEN_BELTS" and name.upper() != "BD1":
                        # if 'BTT' in name: print (line.strip())
                        for i in range(len(word)):
                            if isNumber(word[i]) == True:
                                self.Elset.AddNumber(int(word[i]), name)
                if spt == 'SF':
                    pass

                else:
                    pass

        for i in range(len(self.Elset.Elset)):
            for j in range(1, len(self.Elset.Elset[i])):
                for k in range(len(self.Element.Element)):
                    if self.Elset.Elset[i][j] == self.Element.Element[k][0]:
                        self.Element.Element[k][5] = self.Elset.Elset[i][0]
                        break

    def OuterEdge(self): 
        self.edge_outer = self.Element.OuterEdge(self.Node)
class PATTERN: 
    def __init__(self, filename,  test=0, start_number=10000000):
        self.GlobalXY=21
        self.Node=[]   ## float : Id, x, y, z
        self.Solid=[]  ## int : id, n1, ..., n8, 6 or 8, center (*10^6 -> make it into integer)
        self.Beam=[];         self.UpFront=[];         self.UpBack=[];         self.LowBack=[];         self.Center=[]

        self.GrooveCenter=[];        self.TranslatedNode=[]
        
        self.Surface=[]
        self.leftprofile =[];        self.rightprofile = []
        self.pitch=[];        self.pitchsequence =[] 
        
        self.NoPitch = 0;        self.ModelGD = 0.0
        self.PatternWidth =0.0;        self.TreadDesignWidth = 0.0
        self.HalfDia = 0.0;        self.diameter = 0.0 
        self.upFrontMaxY = 0.0

        self.Nstart = 10**7;        self.Estart = 10**7
        self.profilescaling = 0.001;        self.pitchscaling = 0.001

        self.surf_pattern_neg_side=[];        self.surf_pattern_pos_side=[];        self.SF_fulldepthgrooveside=[];        self.Edge_bottomSurface = []

        self.IsError = 0;        self.errorcode = 0 
        self.KerfsideSurface = [];        self.edge_top_surface = []

        self.shoulderType = 'R'

        self.GrvUpNode=[] ## nodes on up pitch surface among main groove bottom  
        self.MainGrvEdgeGroup =[]

        ####################################################################################################
        print ("############################################")
        print ("## Reading Pattern Mesh file (*.ptn)")
        print ("############################################")
        print (filename)

        result_reading = self.ReadPtn(filename)
        if result_reading >= 100 or self.TreadDesignWidth==0: 
            self.IsError = 1
            return 
        
        if result_reading ==0 : 
            print ("## Error to read pattern mesh file")
            self.IsError =  1 
            return 
        self.npn = np.array(self.Node)
        self.nps = np.array(self.Solid)

        self.Node_Origin = np.array(self.npn) 
        
        self.pitchlength = self.Pitchlength()
        self.errsolid = [] 
        self.HalfDia = round(self.HalfDia*self.profilescaling, 5)

        if len(self.UpFront) > 0: 
            ix = np.where(self.npn[:,0]== self.UpFront[0][1])[0][0]
            if self.npn[ix][3] != self.HalfDia: 
                print ("# Half diameter=%.2fmm, Guide Ht=%.2fmm"%(self.HalfDia*1000, self.npn[ix][3]*1000))
                print ("  Nodes are shifted (%.4fmm)"%((self.HalfDia - self.npn[ix][3])*1000))
                self.npn[:,3] += self.HalfDia - self.npn[ix][3]

                self.diameter = round(self.npn[ix][3] *2.0, 5)
                
            nds = []
            for nd in self.UpFront:
                nds.append(nd[1]); nds.append(nd[2])
            nds = np.array(nds)
            nds = np.unique(nds)
            upnodes=[]
            for nd in nds:
                ix = np.where(self.npn[:,0]==nd)[0][0]
                upnodes.append(self.npn[ix])
            upnodes = np.array(upnodes)
            self.upFrontMaxY = np.max(upnodes[:, 2])
        else:
            self.upFrontMaxY = self.npn[:,2]

        self.nps, self.Surface, printout, self.errsolid =  Generate_all_surfaces_on_solid(self.npn, self.nps, diameter=self.diameter)
        self.freetop, self.freebottom, self.uncheckedfree, self.Surface = self.Top_Bottom_FreeSurfacesFromAllSurfaces_01(self.Surface, \
            self.npn, radius=self.diameter/2.0, margin=1.0E-03)
        tf =  open('topsurf.tmp', 'w')
        for sf in self.freetop: 
            if sf[10] ==0: 
                tf.write("%d, %d, %d, %d, %d\n"%(sf[0], sf[7], sf[8], sf[9], sf[9]))
            else: 
                tf.write("%d, %d, %d, %d, %d\n"%(sf[0], sf[7], sf[8], sf[9], sf[10]))
        tf.close()
    def Pitchlength(self): 
        pmin = 10000.0
        pmax = -10000.0
        x = int(self.GlobalXY/10)
        y = int(self.GlobalXY%10)
        for bm in self.Center:
            if pmin > bm[3][y-1]: pmin = bm[3][y-1]
            if pmin > bm[4][y-1]: pmin = bm[4][y-1]
            if pmax < bm[3][y-1]: pmax = bm[3][y-1]
            if pmax < bm[4][y-1]: pmax = bm[4][y-1]
        return (pmax-pmin)
    def SurfaceBoundary(self, surface):
        ## surface = [El_id, Face_Id(1~6), type(3 or 4), layer, center X, y, z, n1, n2, n3, n4]
        bndedge=[]
        alledge =[]
        for sf in surface:
            alledge.append([int(sf[7]), int(sf[8]), 0, sf[0]])
            alledge.append([int(sf[8]), int(sf[9]), 0, sf[0]])
            if sf[2] == 3: alledge.append([int(sf[9]), int(sf[7]), 0, sf[0]])
            else:
                alledge.append([int(sf[9]), int(sf[10]), 0, sf[0]])
                alledge.append([int(sf[10]), int(sf[7]), 0, sf[0]])

        npedge = np.array(alledge, dtype=np.int32)
        N = len(npedge)
        for i, eg in enumerate(npedge):
            if eg[2] == -1: continue
            bnd = 1

            ind1 = np.where(npedge[:, 1] == eg[0])
            if len(ind1[0]) > 0 : 
                N = len(ind1[0])
                for j in range(N):
                    if npedge[ind1[0][j]][0] == eg[1]: 
                        npedge[i][2] = -1
                        bnd = 0 
                        break 
            if bnd ==1:
                npedge[i][2] =1
                bndedge.append(npedge[i])
        
        return np.array(bndedge)
    def Top_Bottom_FreeSurfacesFromAllSurfaces_01(self, allSurface, npn, radius=0.0, margin=1.0E-03): 

        # t0 = time.time()

        nodes =[]
        for i, sf in enumerate(allSurface):
            tnode = sf[7:]
            nodes.append(np.sort(tnode))
        nodes = np.array(nodes)
        filter_heightmargin =radius - margin ## 1mm from ht. 
        filter_heightmargin_top =radius - margin/2.0
        
        # print ("ht margin for top=%.3f"%(filter_heightmargin_top*1000))
        # print ("ht margin for btm=%.3f"%(filter_heightmargin*1000))
        # print ("Radius =%.3f"%(radius*1000))

        free = []
        bottom = []
        topfree = []
        for i, sf in enumerate(allSurface): 
            # ifree =1
            # print (" %d, %d, %d"%(sf[0]-10**7, sf[1], sf[3]))
            if sf[3] ==99: continue 
            if sf[2] == 3:
                ind1 = np.where(nodes[:, 3] == nodes[i][3])[0]  ## because nodes[i][0] == 0 
                ind2 = np.where(nodes[:, 1] == nodes[i][1])[0]
                ind3 = np.where(nodes[:, 2] == nodes[i][2])[0]
                ind = np.intersect1d(ind1, ind2, assume_unique=True)
                ind = np.intersect1d(ind,  ind3, assume_unique=True) 
                m = 3                
            else: 
                ind1 = np.where(nodes[:, 0] == nodes[i][0])[0]
                ind2 = np.where(nodes[:, 1] == nodes[i][1])[0]
                ind3 = np.where(nodes[:, 2] == nodes[i][2])[0]
                ind4 = np.where(nodes[:, 3] == nodes[i][3])[0]
                ind = np.intersect1d(ind1, ind2, assume_unique=True)
                ind = np.intersect1d(ind,  ind3, assume_unique=True) 
                ind = np.intersect1d(ind,  ind4, assume_unique=True) 
                m = 0 

            if len(ind) ==2: 
                # allSurface[i][3] = 99  ## 99: not free surface 
                allSurface[ind[0]][3] = 99
                allSurface[ind[1]][3] = 99
            #     ifree = 0
            # if ifree ==1:  ## among free surfaces 
            elif len(ind) ==1: 
                ind= ind[0]
                idx1 = np.where(npn[:,0]==nodes[ind][m])[0][0]
                idx2 = np.where(npn[:,0]==nodes[ind][1])[0][0]
                idx3 = np.where(npn[:,0]==nodes[ind][2])[0][0]
                n1 = npn[idx1]; n2=npn[idx2]; n3 = npn[idx3]

                if allSurface[i][1] == 1 and n1[3] < filter_heightmargin and n2[3] < filter_heightmargin and n3[3] < filter_heightmargin:  ## bottom surface : face = 1
                    allSurface[i][3] = 199  ## bottom surface 
                    bottom.append(sf)
                elif allSurface[i][1] == 2 and n1[3] > filter_heightmargin_top and n2[3] > filter_heightmargin_top and n3[3] > filter_heightmargin_top:  ## top surface : face = 2
                    allSurface[i][3] = 101  ## top surface 
                    topfree.append(sf)
                else: #if ht < filter_heightmargin :
                    allSurface[i][3] = 100  ## free surface 
                    free.append(sf)
        
        # print (" btm surf %d, top=%d, free=%d"%(len(bottom), len(topfree), len(free)))
        # t1 = time.time(); print ("** Top/BTM %.3f "%(t1-t0)); t0 = time.time()
        ## verifying the searching bottom surface #############

        bnd_btm = self.SurfaceBoundary(bottom)
        bnd = np.array(bnd_btm)
        self.Edge_bottomSurface = bnd_btm 

        # print (" the No. of bottom edge =%d"%(len(bnd_btm)))

        bd1 = bnd[0]
        bnd = np.delete(bnd, 0, axis=0)
        # print ("*DEL ", bd1)
        i = 0 
        groups=[]
        group=[bd1]
        added = 0 
        while i < len(bnd): 
            ix = np.where(bnd[:,0]==bd1[1])[0]
            if len(ix) > 0: 
                group.append(bnd[ix[0]])
                # print ("DEL ", bnd[ix[0]])
                bd1 = bnd[ix[0]]

                bnd = np.delete(bnd, ix[0], axis=0)
            else: 
                groups.append(group)
                group=[]
                if len(bnd)> 0: 
                    group=[bnd[0]]
                    bd1 = bnd[0]
                    # print ("*DEL ", bd1)
                    bnd = np.delete(bnd, 0, axis=0)
                    
        if len(group) > 0: 
            groups.append(group)
            group = []

        # t1 = time.time(); print ("** BTM %.3f"%(t1-t0)); t0 = time.time()
        if len(groups) > 1: 
            mg = len(groups[0])
            ibt=0 
            for i, gr in enumerate(groups): 
                if len(gr) > mg: 
                    mg = len(gr)
                    ibt = i 
            
            btm = groups[ibt] 
            btmg = []
            for bt in btm: 
                ix = np.where(npn[:,0] == bt[0])[0][0]; n1 = npn[ix]
                ix = np.where(npn[:,0] == bt[1])[0][0]; n2 = npn[ix]
                if n1[2] != n2[2]: 
                    if n1[2] > n2[2]: btmg.append([bt[0], bt[1], bt[2], bt[3], n2, n1])
                    else:             btmg.append([bt[0], bt[1], bt[2], bt[3], n1, n2]) 
            
            i = 0 
            while i < len(bottom): 
                cn = [0, bottom[i][4], bottom[i][5], bottom[i][6]]
                ix = np.where(npn[:,0] == bottom[i][7])[0][0]; n1 = npn[ix]
                ix = np.where(npn[:,0] == bottom[i][9])[0][0]; n3 = npn[ix]
                f = 0 
                for bt in btmg: 
                    d, P = DistanceFromLineToNode2D(cn, [bt[4], bt[5]], xy=23)
                    if d <= 0.2E-03 and bt[4][2] <= P[2] and P[2] <= bt[5][2] : 
                        f = 1
                        break 
                    if bt[4][2] <= n1[2] and n1[2] <= bt[5][2] and abs(bt[5][3]-bt[4][3]) > abs(bt[5][3]-n1[3]): 
                        f = 1
                        break 
                    if bt[4][2] <= n3[2] and n3[2] <= bt[5][2] and abs(bt[5][3]-bt[4][3]) > abs(bt[5][3]-n3[3]): 
                        f = 1
                        break 

                if f == 0: 
                    free.append(bottom[i])
                    # print ("del", bottom[i][0]-10**7, "f=", bottom[i][1], "dist=%.3f"%(d*1000))
                    del(bottom[i])
                    
                    i -= 1
                i += 1 

        # t1 = time.time(); print ("** FN %.3f"%(t1-t0)); t0 = time.time()
        # t2 = time.time()
        # print ("#####################################")
        # print (" TIME TO SEARCH FREE SURFACE =%.2f"%(t2-t1))
        # print ("#####################################")
        
        return np.array(topfree), np.array(bottom), np.array(free), allSurface 
    def ReadPtn(self, filename, valuereturn=0):

        with open(filename) as PTN: 
            lines = PTN.readlines()
        cmd = ""
        depths=[]
        solidname = ''
        centerbeams = []
        upAft =[]; lwAft = []; UpFwd =[]
        for line in lines:
            if "Regenerated Pattern mesh from P3DM" in line: 
                print ("* This mesh was generated by P3DM.")
                print ("  it is already bended to fit a layout \n")
                return 100

            if "**" in line: 
                continue
            elif "*" in line:
                if "*ELEMENT" in line.upper() and "CGAX4" in line.upper() : 
                    print ("* This mesh may be not a pattern mesh.")
                    print ("  This mesh can not be expanded.")
                    return 101 
                if "PROFILE_SCALING" in line.upper():
                    data = line.split(":")
                    self.profilescaling = float(data[1].strip())
                elif "GROOVE_DEPTH" in line.upper() or ("GROOVE" in line.upper() and 'DEPTH' in line.upper()):
                    data = line.split(":")
                    self.ModelGD = float(data[1].strip()) 
                elif "HALF_DIAMETER" in line.upper():
                    data = line.split(":")
                    self.diameter = float(data[1].strip()) * 2.0 
                    self.HalfDia =  float(data[1].strip())
                elif "CENTER_ANGLE" in line:
                    data = line.split(":")
                    self.centerangle = float(data[1].strip()) 
                elif "PROFILE_LHS" in line.upper():
                    cmd = 'LHS'
                elif "PROFILE_RHS" in line.upper():
                    cmd = 'RHS'
                elif "PITCH_SCALING" in line.upper():
                    data = line.split(":")
                    self.pitchscaling = float(data[1].strip()) 
                elif "TREAD_DESIGN_WIDTH" in line.upper() or ("TREAD" in line.upper() and "DESIGN" in line.upper() and "WIDTH" in line.upper()):
                    data = line.split(":")
                    self.TreadDesignWidth = float(data[1].strip())
                elif "GUIDELINE_TOLERANCE" in line.upper():
                    data = line.split(":")
                    self.guidelinetolerance = float(data[1].strip()) 
                elif "PITCH_DEFINITION_FIRST" in line:
                    cmd = 'P1'
                elif "PITCH_ARRAY_FIRST" in line.upper():
                    data = line.split(",")
                    for dt in data: 
                        if 'EIDSTART' in dt: 
                            self.Estart = int(dt.split("=")[1].strip())
                            self.Estart = 10**7
                        if 'NIDSTART' in dt: 
                            self.Nstart = int(dt.split("=")[1].strip())
                            self.Nstart = 10**7
                        if 'EIDOFFSET' in dt: 
                            self.Eoffset = int(dt.split("=")[1].strip())
                            self.Eoffset = 10000
                        if 'NIDOFFSET' in dt: 
                            self.Noffset = int(dt.split("=")[1].strip())
                            self.Noffset =10000
                        if 'ANGLE' in dt: self.Pangle = float(dt.split("=")[1].strip())
                        if 'DIRECTION' in dt: self.Direction = dt.split("=")[1].strip()
                    cmd = 'PS'
                elif "HEADING" in line.upper():
                    cmd = 'Heading'
                elif "*NODE" in line.upper() and not "FILE" in line.upper() and not 'OUTPUT' in line.upper() :
                    cmd = "ND"
                elif "ELEMENT" in line.upper() and "B31" in line.upper():
                    cmd = "BM"
                elif "ELEMENT" in line.upper() and "C3D8" in line.upper():
                    cmd = "SD8"
                elif "ELEMENT" in line.upper() and "C3D6" in line.upper():
                    cmd = "SD6"
                elif "*ELSET" in line.upper() and "SOLID" in line.upper():
                    if 'generate' in line.lower(): 
                        cmd = 'SOLG'
                        dline = line.split(",")
                        for d in dline: 
                            if "ELSET" in d.upper() and "=" in d: 
                                solidname = d.split("=")[1].strip()
                                break 
                    else:
                        cmd ="SOL"
                        dline = line.split(",")
                        for d in dline: 
                            if "ELSET" in d.upper() and "=" in d: 
                                solidname = d.split("=")[1].strip()
                                break 
                elif "*ELSET" in line.upper() and "CENTER" in line.upper():
                    if 'generate' in line.lower(): 
                        cmd = 'BCENG'
                        dline = line.split(",")
                        for d in dline: 
                            if "ELSET" in d.upper() and "=" in d: 
                                beamname = d.split("=")[1].strip()
                                break
                    else:
                        cmd ="BCEN"
                        dline = line.split(",")
                        for d in dline: 
                            if "ELSET" in d.upper() and "=" in d: 
                                beamname = d.split("=")[1].strip()
                                break 
                elif "ELSET" in line.upper() and "UPFWD" in line.upper():
                    if 'generate' in line.lower(): 
                        cmd = 'BUFG'
                        dline = line.split(",")
                        for d in dline: 
                            if "ELSET" in d.upper() and "=" in d: 
                                beamname = d.split("=")[1].strip()
                                break
                    else:   
                        cmd = "BUF"
                        dline = line.split(",")
                        for d in dline: 
                            if "ELSET" in d.upper() and "=" in d: 
                                beamname = d.split("=")[1].strip()
                                break
                elif "ELSET" in line.upper() and "UPAFT" in line.upper():
                    if 'generate' in line.lower(): 
                        cmd = 'BUAG'
                        dline = line.split(",")
                        for d in dline: 
                            if "ELSET" in d.upper() and "=" in d: 
                                beamname = d.split("=")[1].strip()
                                break
                    else:   
                        cmd = "BUA"
                        dline = line.split(",")
                        for d in dline: 
                            if "ELSET" in d.upper() and "=" in d: 
                                beamname = d.split("=")[1].strip()
                                break
                elif "ELSET" in line.upper() and "LWAFT" in line.upper():
                    if 'generate' in line.lower(): 
                        cmd = 'BLAG'
                        dline = line.split(",")
                        for d in dline: 
                            if "ELSET" in d.upper() and "=" in d: 
                                beamname = d.split("=")[1].strip()
                                break
                    else:
                        cmd = "BLA"
                        dline = line.split(",")
                        for d in dline: 
                            if "ELSET" in d.upper() and "=" in d: 
                                beamname = d.split("=")[1].strip()
                                break
                elif "TREADPTN_NIDSTART_NIDOFFSET_EIDSTART_EIDOFFSET" in line.upper(): 
                    return 0 
                else:
                    cmd =""
            else:
                if cmd =="LHS": 
                    data = line.split(",")
                    PR = round(float(data[0].strip())*self.profilescaling, 6)
                    if PR == 0.0 : PR = 10.0
                    self.leftprofile.append([PR, float(data[1].strip())*self.profilescaling])
                if cmd =="RHS": 
                    data = line.split(",")
                    PR = round(float(data[0].strip())*self.profilescaling, 6)
                    if PR == 0.0 : PR = 10.0
                    self.rightprofile.append([PR, float(data[1].strip())*self.profilescaling])
                if cmd =="P1": 
                    data = line.split(",")
                    self.pitch.append([data[0].strip(), data[4].strip(), data[5].strip(), data[6].strip(), data[7].strip(), data[8].strip()])
                if cmd =="PS":
                    data = line.split(",")
                    if len(data) == 3: 
                        self.pitchsequence.append([int(data[0].strip()), data[1].strip(), int(data[2].strip()) ])
                if cmd =="ND":
                    skip = 0 
                    data = line.split(",")
                    if len(data)>=4: 
                        if float(data[3].strip()) > 0: 
                            self.Node.append([float(int(data[0].strip()) + self.Nstart),  round(float(data[1].strip()) * self.pitchscaling, 7), \
                                        round(float(data[2].strip()) * self.pitchscaling, 7),  round(float(data[3].strip()) * self.pitchscaling, 7)])
                        else: 
                            print ("* All the Z values of the nodes should be positive")
                            print ("  This mesh can not be expanded.")
                            return 101 

                    # except:
                    #     print ("ERROR!! ", line, data)
                    #     return 101
                        

                    # if self.MaxY < float(data[2].strip()) * self.pitchscaling: self.MaxY = float(data[2].strip()) * self.pitchscaling
                    # if self.MinY > float(data[2].strip()) * self.pitchscaling: self.MinY = float(data[2].strip()) * self.pitchscaling
                if cmd == "BM": 
                    data = line.split(",")
                    if len(data) > 1: 
                        self.Beam.append([int(data[0].strip())+self.Estart, int(data[1].strip())+self.Nstart, int(data[2].strip())+self.Nstart])
                if cmd == "SD6": 
                    data = line.split(",")
                    # int(data[0].strip()) + self.Estart
                    self.Solid.append([int(data[0].strip()) + self.Estart, \
                        int(data[1].strip()) + self.Nstart, int(data[3].strip()) + self.Nstart, \
                        int(data[2].strip()) + self.Nstart, int(data[4].strip()) + self.Nstart, \
                        int(data[6].strip()) + self.Nstart, int(data[5].strip()) + self.Nstart, \
                        0, 0, 6])
                if cmd == "SD8": 
                    data = line.split(",")
                    self.Solid.append([int(data[0].strip()) + self.Estart, \
                        int(data[1].strip()) + self.Nstart, int(data[4].strip()) + self.Nstart, \
                        int(data[3].strip()) + self.Nstart, int(data[2].strip()) + self.Nstart, \
                        int(data[5].strip()) + self.Nstart, int(data[8].strip()) + self.Nstart, \
                        int(data[7].strip()) + self.Nstart, int(data[6].strip()) + self.Nstart, 8])                    
                if cmd == "BCEN":
                    data = line.split(",")
                    temp = [beamname]
                    for dt in data:
                        if dt.strip() =="": continue 
                        if dt.strip() !="": bid =  int(dt.strip()) + self.Estart
                        for bm in self.Beam: 
                            if bm[0] == bid: 
                                tmp = [bm[0], bm[1], bm[2]]
                                for nd in self.Node:
                                    if bm[1] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                for nd in self.Node:
                                    if bm[2] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                
                                self.Center.append(tmp)
                                temp.append(tmp)
                    centerbeams.append(temp)

                                
                if cmd == 'BCENG': 
                    data = line.split(",")
                    if len(data) < 3 : continue
                    data[0] = int(data[0].strip())
                    data[1] = int(data[1].strip())
                    data[2] = int(data[2].strip())
                    temp = [beamname]
                    for dn in range(data[0], data[1]+1, data[2]): 
                        bid = dn + self.Estart 
                        for bm in self.Beam: 
                            if bm[0] == bid: 
                                tmp = [bm[0], bm[1], bm[2]]
                                for nd in self.Node:
                                    if bm[1] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                for nd in self.Node:
                                    if bm[2] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                
                                self.Center.append(tmp)
                                temp.append(tmp)
                    centerbeams.append(temp)
                
                if cmd == "BUF":
                    data = line.split(",")
                    temp = [beamname]
                    for dt in data:
                        if dt.strip() =="": continue 
                        bid =  int(dt.strip()) + self.Estart
                        for bm in self.Beam: 
                            if bm[0] == bid: 
                                tmp = [bm[0], bm[1], bm[2]]
                                for nd in self.Node:
                                    if bm[1] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                for nd in self.Node:
                                    if bm[2] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                
                                self.UpFront.append(tmp)
                                temp.append(tmp)
                    UpFwd.append(temp)
                if cmd == 'BUFG': 
                    data = line.split(",")
                    if len(data) < 3 : continue
                    data[0] = int(data[0].strip())
                    data[1] = int(data[1].strip())
                    data[2] = int(data[2].strip())
                    temp = [beamname]
                    for dn in range(data[0], data[1]+1, data[2]): 
                        bid = dn + self.Estart 
                        for bm in self.Beam: 
                            if bm[0] == bid: 
                                tmp = [bm[0], bm[1], bm[2]]
                                for nd in self.Node:
                                    if bm[1] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                for nd in self.Node:
                                    if bm[2] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                
                                self.UpFront.append(tmp)  # # upAft =[]; lwAft = []; UpFwd =[]
                                temp.append(tmp)
                    UpFwd.append(temp)
                if cmd == "BUA":
                    data = line.split(",")
                    temp = [beamname]
                    for dt in data:
                        if dt.strip() =="": continue 
                        bid =  int(dt.strip()) + self.Estart
                        for bm in self.Beam: 
                            if bm[0] == bid: 
                                tmp = [bm[0], bm[1], bm[2]]
                                for nd in self.Node:
                                    if bm[1] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                for nd in self.Node:
                                    if bm[2] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                
                                self.UpBack.append(tmp) # # upAft =[]; lwAft = []; UpFwd =[]
                                temp.append(tmp)
                    upAft.append(temp)
                if cmd == 'BUAG': 
                    data = line.split(",")
                    if len(data) < 3 : continue
                    data[0] = int(data[0].strip())
                    data[1] = int(data[1].strip())
                    data[2] = int(data[2].strip())
                    temp = [beamname]
                    for dn in range(data[0], data[1]+1, data[2]): 
                        bid = dn + self.Estart 
                        for bm in self.Beam: 
                            if bm[0] == bid: 
                                tmp = [bm[0], bm[1], bm[2]]
                                for nd in self.Node:
                                    if bm[1] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                for nd in self.Node:
                                    if bm[2] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                
                                self.UpBack.append(tmp)# # upAft =[]; lwAft = []; UpFwd =[]
                                temp.append(tmp)
                    upAft.append(temp)
                if cmd == "BLA":
                    data = line.split(",")
                    temp = [beamname]
                    for dt in data:
                        if dt.strip() =="": continue 
                        bid =  int(dt.strip()) + self.Estart
                        for bm in self.Beam: 
                            if bm[0] == bid: 
                                tmp = [bm[0], bm[1], bm[2]]
                                for nd in self.Node:
                                    if bm[1] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                for nd in self.Node:
                                    if bm[2] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                
                                self.LowBack.append(tmp)# # upAft =[]; lwAft = []; UpFwd =[]
                                temp.append(tmp)
                    lwAft.append(temp)
                if cmd == 'BLAG': 
                    data = line.split(",")
                    if len(data) < 3 : continue
                    data[0] = int(data[0].strip())
                    data[1] = int(data[1].strip())
                    data[2] = int(data[2].strip())
                    temp = [beamname]
                    for dn in range(data[0], data[1]+1, data[2]): 
                        bid = dn + self.Estart 
                        for bm in self.Beam: 
                            if bm[0] == bid: 
                                tmp = [bm[0], bm[1], bm[2]]
                                for nd in self.Node:
                                    if bm[1] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                for nd in self.Node:
                                    if bm[2] == nd[0]:
                                        tmp.append([nd[1], nd[2], nd[3]])
                                        break
                                
                                self.LowBack.append(tmp)# # upAft =[]; lwAft = []; UpFwd =[]
                                temp.append(tmp)
                    lwAft.append(temp)
                # self.pitch=[P1, ELSET_NAME]
                if cmd == 'SOLG': 
                    temp = []
                    data = line.split(",")
                    if len(data) < 3 : continue
                    data[0] = int(data[0].strip())
                    data[1] = int(data[1].strip())
                    data[2] = int(data[2].strip())
                    for dn in range(data[0], data[1]+1, data[2]): 
                        temp.append(dn + self.Estart)

                    for p in self.pitch: 
                        if p[1] == solidname: 
                            if len(p) == 6: 
                                p.append(temp)
                                # print (" solidname : ", solidname, temp)
                            else: 
                                for t in temp: 
                                    p[-1].append(t)
                            # print (p)

                if cmd == 'SOL':
                    temp = [] 
                    data = line.split(",")
                    for d in data: 
                        d = d.strip()
                        if d!="": 
                            temp.append(int(d)+self.Estart)
                    
                    for p in self.pitch: 
                        
                        if p[1] == solidname:
                            if len(p) == 6: 
                                p.append(temp)
                            #     # p.append(data)
                            #     # print (" solidname", solidname, data)
                            else: 
                                for t in temp: 
                                    p[-1].append(t)

                            # print (p)


        if len(self.Node) > 100000: 
            print ("\n Too many nodes in the mesh (=%d >100,000)"%(len(self.Node)))
            return 0
        if len(self.Solid) == 0: 
            print ("\n No information of pattern mesh\n")
            return 0

        if len(self.pitch) > 1:
            p0=self.pitch[0][0] 
            s0 =self.pitch[0][1] 
            i = 1
            while i < len(self.pitch): 
                if self.pitch[i][0] != p0 and self.pitch[i][1] != s0: 
                    self.CombinePitches(self.pitch, self.pitchsequence, centerbeams, upAft, lwAft, UpFwd)
                    break 
                i += 1 
        
        self.TreadDesignWidth = round(self.TreadDesignWidth/1000, 9)

        tnode = np.array(self.Node)
        zs = tnode[:,3]
        self.diameter = np.max(zs) * 2.0

        # self.diameter = round(self.diameter * self.pitchscaling, 6)
        # self.guidelinetolerance = round(self.guidelinetolerance * self.pitchscaling, 6)
        ix = np.where(tnode[:,3] > self.diameter /2.0 - 0.0005)[0]
        wn = tnode[ix]
        ws = wn[:,2]
        wmin = np.min(ws); wmax=np.max(ws)
        self.PatternWidth = wmax - wmin 
        if self.ModelGD ==0: self.ModelGD = 1.0E-03 
        else: self.ModelGD = self.ModelGD * 0.001

        # if self.TreadDesignWidth == 0: 
        #     self.TreadDesignWidth = self.PatternWidth  - 10.0E-03 
        #     print ("*Design Width was set to 'Total width -10mm'")

        return 1 
def Generate_all_surfaces_on_solid(npn, nps, diameter=0, text=""):  ##  --> GenerateAllSurfaces(self) 
    ## before call this function, 'makenumpyarray()' should be called.

    Solid = []
    Surface=[]
    if diameter == 0: 
        zs = npn[:,3]
        diameter = np.max(zs) * 2 
    R = round(diameter / 2.0, 7)
    R1000 = R*1000
    changed = 0
    img = 0 
    topmargin = R - 0.5E-03
    topmax = 0
    btmmax = 0 
    truncation = 5
    layer = -1

    checkEL = 5841; checkEL1 = 5862

    vertLine = [0, 0, 0, 1]

    for solid in nps:

        
        if solid[9] == 6: N=7     ## solid[9] == 6
        else: N=9                 ## solid[9] == 8

        nodes_coord = []
        elementNodes = []
        angles=[]

        sx = 0.0;   sy = 0.0;      sz = 0.0
        topnode = []
        for i in range(1, N):
            index = np.where(npn[:, 0] == solid[i])
            tx = npn[index[0][0]][1]; ty=npn[index[0][0]][2]; tz =npn[index[0][0]][3]
            sx += tx;                  sy += ty;                 sz += tz 
            if abs(round(tz -R, truncation)) < 0.5E-3 : topnode.append(npn[index[0][0]][0])
            nodes_coord.append([tx,ty,tz])
            idx = index[0][0]
            elementNodes.append(npn[index[0][0]])

        SolidCenter = [round(sx/solid[9], truncation), round(sy/solid[9], truncation), round(sz/solid[9], truncation)] 

        centers = []

        top = 0 
        gap = R*2 
        
        if N == 9: 
            i = 0; j=1; m=2; n=3
            ssx = round((nodes_coord[i][0] + nodes_coord[j][0] + nodes_coord[m][0] + nodes_coord[n][0])  / 4.0, truncation)
            ssy = round((nodes_coord[i][1] + nodes_coord[j][1] + nodes_coord[m][1] + nodes_coord[n][1])  / 4.0, truncation)
            ssz = round((nodes_coord[i][2] + nodes_coord[j][2] + nodes_coord[m][2] + nodes_coord[n][2])  / 4.0, truncation)
            centers.append([ssx, ssy, ssz, 1])
            Normal = NormalVector_plane(elementNodes[i], elementNodes[j], elementNodes[m])
            angles.append(Angle_Between_Vectors(Normal, vertLine)-1.570796)
            if ssz >= topmargin and R-ssz < gap : 
                top =1 
                gap = R-ssz 

            i = 4; j=5; m=6; n=7
            ssx = round((nodes_coord[i][0] + nodes_coord[j][0] + nodes_coord[m][0] + nodes_coord[n][0])  / 4.0, truncation)
            ssy = round((nodes_coord[i][1] + nodes_coord[j][1] + nodes_coord[m][1] + nodes_coord[n][1])  / 4.0, truncation)
            ssz = round((nodes_coord[i][2] + nodes_coord[j][2] + nodes_coord[m][2] + nodes_coord[n][2])  / 4.0, truncation) 
            centers.append([ssx, ssy, ssz, 2])
            Normal = NormalVector_plane(elementNodes[i], elementNodes[j], elementNodes[m])
            angles.append(Angle_Between_Vectors(Normal, vertLine)-1.570796)

            if ssz >= topmargin and R-ssz < gap : 
                top =2 
                gap = R-ssz 

            i = 0; j=1; m=5; n=4
            ssx = round((nodes_coord[i][0] + nodes_coord[j][0] + nodes_coord[m][0] + nodes_coord[n][0])  / 4.0, truncation)
            ssy = round((nodes_coord[i][1] + nodes_coord[j][1] + nodes_coord[m][1] + nodes_coord[n][1])  / 4.0, truncation)
            ssz = round((nodes_coord[i][2] + nodes_coord[j][2] + nodes_coord[m][2] + nodes_coord[n][2])  / 4.0, truncation) 
            centers.append([ssx, ssy, ssz, 3])
            Normal = NormalVector_plane(elementNodes[i], elementNodes[j], elementNodes[m])
            angles.append(Angle_Between_Vectors(Normal, vertLine)-1.570796)
            if ssz >= topmargin and R-ssz < gap : 
                top =3 
                gap = R-ssz 

            i = 1; j=2; m=6; n=5
            ssx = round((nodes_coord[i][0] + nodes_coord[j][0] + nodes_coord[m][0] + nodes_coord[n][0])  / 4.0, truncation)
            ssy = round((nodes_coord[i][1] + nodes_coord[j][1] + nodes_coord[m][1] + nodes_coord[n][1])  / 4.0, truncation)
            ssz = round((nodes_coord[i][2] + nodes_coord[j][2] + nodes_coord[m][2] + nodes_coord[n][2])  / 4.0, truncation) 
            centers.append([ssx, ssy, ssz, 4])
            Normal = NormalVector_plane(elementNodes[i], elementNodes[j], elementNodes[m])
            angles.append(Angle_Between_Vectors(Normal, vertLine)-1.570796)
            if ssz >= topmargin and R-ssz < gap : 
                top =4 
                gap = R-ssz 

            i = 2; j=3; m=7; n=6
            ssx = round((nodes_coord[i][0] + nodes_coord[j][0] + nodes_coord[m][0] + nodes_coord[n][0])  / 4.0, truncation)
            ssy = round((nodes_coord[i][1] + nodes_coord[j][1] + nodes_coord[m][1] + nodes_coord[n][1])  / 4.0, truncation)
            ssz = round((nodes_coord[i][2] + nodes_coord[j][2] + nodes_coord[m][2] + nodes_coord[n][2])  / 4.0, truncation) 
            centers.append([ssx, ssy, ssz, 5])
            Normal = NormalVector_plane(elementNodes[i], elementNodes[j], elementNodes[m])
            angles.append(Angle_Between_Vectors(Normal, vertLine)-1.570796)
            if ssz >=topmargin and R-ssz < gap : 
                top =5 
                gap = R-ssz 

            i = 3; j=0; m=4; n=7
            ssx = round((nodes_coord[i][0] + nodes_coord[j][0] + nodes_coord[m][0] + nodes_coord[n][0])  / 4.0, truncation)
            ssy = round((nodes_coord[i][1] + nodes_coord[j][1] + nodes_coord[m][1] + nodes_coord[n][1])  / 4.0, truncation)
            ssz = round((nodes_coord[i][2] + nodes_coord[j][2] + nodes_coord[m][2] + nodes_coord[n][2])  / 4.0, truncation) 
            centers.append([ssx, ssy, ssz, 6])
            Normal = NormalVector_plane(elementNodes[i], elementNodes[j], elementNodes[m])
            angles.append(Angle_Between_Vectors(Normal, vertLine)-1.570796)
                
            if ssz >=topmargin and R-ssz < gap : 
                top =6 
                gap = R-ssz 
        else:
            i = 0; j=1; m=2
            ssx = round((nodes_coord[i][0] + nodes_coord[j][0] + nodes_coord[m][0] )  / 3.0, truncation)
            ssy = round((nodes_coord[i][1] + nodes_coord[j][1] + nodes_coord[m][1] )  / 3.0, truncation)
            ssz = round((nodes_coord[i][2] + nodes_coord[j][2] + nodes_coord[m][2] )  / 3.0, truncation) 
            centers.append([ssx, ssy, ssz, 1])
            if ssz >= topmargin and R-ssz < gap : 
                top =1 
                gap = R-ssz 

            i = 3; j=4; m=5
            ssx = round((nodes_coord[i][0] + nodes_coord[j][0] + nodes_coord[m][0] )  / 3.0, truncation)
            ssy = round((nodes_coord[i][1] + nodes_coord[j][1] + nodes_coord[m][1] )  / 3.0, truncation)
            ssz = round((nodes_coord[i][2] + nodes_coord[j][2] + nodes_coord[m][2] )  / 3.0, truncation) 
            centers.append([ssx, ssy, ssz, 2])
            if ssz >= topmargin and R-ssz < gap : 
                top =2
                gap = R-ssz 

            i = 0; j=1; m=4; n=3
            ssx = round((nodes_coord[i][0] + nodes_coord[j][0] + nodes_coord[m][0] + nodes_coord[n][0])  / 4.0, truncation)
            ssy = round((nodes_coord[i][1] + nodes_coord[j][1] + nodes_coord[m][1] + nodes_coord[n][1])  / 4.0, truncation)
            ssz = round((nodes_coord[i][2] + nodes_coord[j][2] + nodes_coord[m][2] + nodes_coord[n][2])  / 4.0, truncation) 
            centers.append([ssx, ssy, ssz, 3])
            if ssz >=topmargin and R-ssz < gap : 
                top =3 
                gap = R-ssz 

            i = 1; j=2; m=5; n=4
            ssx = round((nodes_coord[i][0] + nodes_coord[j][0] + nodes_coord[m][0] + nodes_coord[n][0])  / 4.0, truncation)
            ssy = round((nodes_coord[i][1] + nodes_coord[j][1] + nodes_coord[m][1] + nodes_coord[n][1])  / 4.0, truncation)
            ssz = round((nodes_coord[i][2] + nodes_coord[j][2] + nodes_coord[m][2] + nodes_coord[n][2])  / 4.0, truncation) 
            centers.append([ssx, ssy, ssz, 4])
            if ssz >=topmargin and R-ssz < gap : 
                top =4 
                gap = R-ssz  

            i = 2; j=0; m=3; n=5
            ssx = round((nodes_coord[i][0] + nodes_coord[j][0] + nodes_coord[m][0] + nodes_coord[n][0])  / 4.0, truncation)
            ssy = round((nodes_coord[i][1] + nodes_coord[j][1] + nodes_coord[m][1] + nodes_coord[n][1])  / 4.0, truncation)
            ssz = round((nodes_coord[i][2] + nodes_coord[j][2] + nodes_coord[m][2] + nodes_coord[n][2])  / 4.0, truncation) 
            centers.append([ssx, ssy, ssz, 5])
            if ssz >= topmargin and R-ssz < gap : 
                top =5 
                gap = R-ssz 
        
        if top == 0 or N != 9: 
            cnt = 0
            mz = 100000.0
            my1  =centers[0][1]
            my2 = centers[0][1]
            for cz in centers: 
                if cz[1] > my2: my2 = cz[1]
                if cz[1] < my1: my1 = cz[1]
            for i, cz in enumerate(centers): 
                if N == 9: 
                    if cz[2] < mz and abs(angles[i]) > 0.785398 : 
                        mz = cz[2]
                        if my1 < cz[1] and cz[1] < my2: 
                            cnt = i
                else: 
                    if cz[2] < mz  : 
                        mz = cz[2]
                        if my1 < cz[1] and cz[1] < my2: 
                            cnt = i
        elif N==9 : 
            if top == 2  :  cnt = 0 
            elif top == 1 : cnt = 1
            elif  top == 3 :cnt = 4
            elif top == 4 : cnt = 5
            elif top == 5 : cnt = 2
            else :          cnt = 3

        if N ==9: 
            if cnt == 0:   orders = [[0, 1, 4, 3, 2, 5, 8, 7, 6, 9] , [0, 1, 5, 4, 3, 2] ]  # [0, 1, 2, 3, 4, 5]  ## orders = [[el[0], N1[i]],   centers of faces ()]
            elif cnt == 1: orders = [[0, 6, 7, 8, 5, 2, 3, 4, 1, 9] , [1, 0, 3, 4, 5, 2] ]  # [[0,   6, 5, 8, 7,   2, 1, 4, 3, 9] , [1, 0,   2, 5, 4, 3] ]

            elif cnt == 2: orders = [[0, 1, 2, 6, 5, 4, 3, 7, 8, 9] , [2, 4, 0, 3, 1, 5] ]  # [[0,   1, 5, 6, 2,   4, 8, 7, 3, 9] , [2, 4,   5, 1, 3, 0] ]
            elif cnt == 3: orders = [[0, 2, 3, 7, 6, 1, 4, 8, 5, 9] , [3, 5, 0, 4, 1, 2] ]  # [[0,   2, 6, 7, 3,   1, 5, 8, 4, 9] , [3, 5,   2, 1, 4, 0] ]
            elif cnt == 4: orders = [[0, 4, 8, 7, 3, 1, 5, 6, 2, 9]  , [4, 2, 5, 1, 3, 0] ] # [[0,   4, 3, 7, 8,   1, 2, 6, 5, 9]  , [4, 2,   0, 3, 1, 5] ]
            elif cnt == 5: orders = [[0, 1, 5, 8, 4, 2, 6, 7, 3, 9] , [5, 3, 2, 1, 4, 0] ]  # [[0,   1, 4, 8, 5,   2, 3, 7, 6, 9] , [5, 3,   0, 4, 1, 2] ]
            else:  
                orders = [[0, 1, 4, 3, 2, 5, 8, 7, 6, 9] , [0, 1, 5, 4, 3, 2] ]
        else: 
            if cnt == 0: orders =   [[0, 1, 3, 2, 4, 6, 5, 7, 8, 9] , [0, 1, 4, 3, 2] ]    # [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] , [0, 1, 2, 3, 4] ]
            elif cnt == 1: orders = [[0, 4, 5, 6, 1, 2, 3, 7, 8, 9] , [1, 0, 2, 3, 4] ]    # [[0, 4, 6, 5, 1, 3, 2, 7, 8, 9] , [1, 0, 4, 3, 2] ]

            else: 
                orders =   [[0, 1, 3, 2, 4, 6, 5, 7, 8, 9] , [0, 1, 4, 3, 2] ] 
                errsolid =[solid]
        tmp = []
        for i in orders[0]: 
            tmp.append(solid[i])

        tmp.append(SolidCenter[0])
        tmp.append(SolidCenter[1])
        tmp.append(SolidCenter[2])

        for i in orders[0]: 
            if i ==9: break 
            else: 
                if N == 7 and i > 6: 
                        tmp.append(0.0);                tmp.append(0.0);                tmp.append(0.0)
                else: 
                    tmp.append(nodes_coord[i-1][0])
                    tmp.append(nodes_coord[i-1][1])
                    tmp.append(nodes_coord[i-1][2])

        margin = 0.15E-03
        pl =0 
        
        if N == 9: 
            # layer = -1
            Surface.append([tmp[0], 1, 4, layer, centers[orders[1][0]][0], centers[orders[1][0]][1], centers[orders[1][0]][2], tmp[1],tmp[2],tmp[3],tmp[4]])
            Surface.append([tmp[0],2, 4, layer, centers[orders[1][1]][0], centers[orders[1][1]][1], centers[orders[1][1]][2], tmp[5],tmp[6],tmp[7],tmp[8]])
            
            # layer = -1
            Surface.append([tmp[0],3, 4, layer, centers[orders[1][2]][0], centers[orders[1][2]][1], centers[orders[1][2]][2], tmp[1],tmp[2],tmp[6],tmp[5]])
            Surface.append([tmp[0],4, 4, layer, centers[orders[1][3]][0], centers[orders[1][3]][1], centers[orders[1][3]][2], tmp[2],tmp[3],tmp[7],tmp[6]])
            Surface.append([tmp[0],5, 4, layer, centers[orders[1][4]][0], centers[orders[1][4]][1], centers[orders[1][4]][2], tmp[3],tmp[4],tmp[8],tmp[7]])
            Surface.append([tmp[0],6, 4, layer, centers[orders[1][5]][0], centers[orders[1][5]][1], centers[orders[1][5]][2], tmp[4],tmp[1],tmp[5],tmp[8]])
        else: 
            # layer = -1
            Surface.append([tmp[0],1, 3, layer, centers[orders[1][0]][0], centers[orders[1][0]][1], centers[orders[1][0]][2], tmp[1],tmp[2],tmp[3], 0])
            Surface.append([tmp[0],2, 3, layer, centers[orders[1][1]][0], centers[orders[1][1]][1], centers[orders[1][1]][2], tmp[4],tmp[5],tmp[6],0 ])
            
            # layer = -1
            Surface.append([tmp[0],3, 4, layer, centers[orders[1][2]][0], centers[orders[1][2]][1], centers[orders[1][2]][2], tmp[1],tmp[2],tmp[5],tmp[4]])
            Surface.append([tmp[0],4, 4, layer, centers[orders[1][3]][0], centers[orders[1][3]][1], centers[orders[1][3]][2], tmp[2],tmp[3],tmp[6],tmp[5]])
            Surface.append([tmp[0],5, 4, layer, centers[orders[1][4]][0], centers[orders[1][4]][1], centers[orders[1][4]][2], tmp[3],tmp[1],tmp[4],tmp[6]])

        Solid.append(tmp)
        if cnt >0: 
            changed+=1

    del(centers)
    del(orders)
    nps = np.array(Solid, dtype=np.float64)
    Surface = np.array(Surface)
    text += "\n* The node order of PTN was checked(%dEA)\n"%(changed)
    errsolid = []
    return nps, Surface, text, errsolid

def FreeEdge(edge):
    FEdge = EDGE()
    edges = np.array(edge.Edge)
    for i, ed in enumerate(edges): 
        ix1 = np.where(edges[:,1] == ed[0])[0]
        ix2 = np.where(edges[:,0] == ed[1])[0]
        ix = np.intersect1d(ix1, ix2)
        if len(ix) ==0: 
            edge.Edge[i][5] = 0
            FEdge.Add(edge.Edge[i])
        else: 
            edge.Edge[i][5] = -2
    return FEdge
def OuterEdge(FreeEdge, Node, Element):
    N = len(FreeEdge.Edge)
    MinY = 9.9E20
    cNodes = [0]
    npn = np.array(Node.Node)
    for i in range(N):
        ix = np.where(npn[:,0]==FreeEdge.Edge[i][0])[0][0]; N1 = Node.Node[ix]
        ix = np.where(npn[:,0]==FreeEdge.Edge[i][1])[0][0]; N2 = Node.Node[ix]

        if N1[3] < MinY:
            MinY = N1[3]
            cNodes[0] = N1[0]
        if N2[3] < MinY:
            MinY = N2[3]
            cNodes[0] = N2[0]
    if cNodes[0] == 0:
        cNodes[0] = Node.NodeIDByCoordinate('z', 0.0, closest=1)

    MAX = 10000   ## max iteration for searching  error
    ShareNodePos = []
    #    connectedEdge = []
    outEdge = EDGE()

    ## Find a 1st surround edge (IL at the center)
    low = 9.9E20
    i = 0
    savei = 0
    while i < len(cNodes):
        j = 0
        while j < len(Node.Node):
            if cNodes[i] == Node.Node[j][0]:
                if Node.Node[j][3] < low:
                    low = Node.Node[j][3]
                    savei = j
            j += 1
        i += 1

    i = 0
    while i < len(FreeEdge.Edge):
        if Node.Node[savei][0] == FreeEdge.Edge[i][0]:
            break
        i += 1

    ## End of 1st Outer Edge finding (IL1)
    FreeEdge.Edge[i][5] = 1
    outEdge.Add(FreeEdge.Edge[i])
    iFirstNode = FreeEdge.Edge[i][0]

    count = 0
    #    i=  # i is no matter how big, because i is redefined when next edge is found
    while i < len(FreeEdge.Edge):
        count += 1
        if count > MAX:
            print ('[INPUT] CANNOT FIND OUTER EDGES IN THE MODEL')
            del (outEdge)
            outEdge = EDGE()
            return outEdge
        j = 0
        while j < len(FreeEdge.Edge):
            if i != j:
                if FreeEdge.Edge[i][1] == FreeEdge.Edge[j][0]:
                    # print ('edge[i][1], [j][0] ', FreeEdge.Edge[i], FreeEdge.Edge[j], 'i=', i)
                    ShareNodePos.append(j)
                    # print (ShareNodePos, FreeEdge.Edge[ShareNodePos[0]][0])
            j = j + 1
        if len(ShareNodePos) != 0:
            if FreeEdge.Edge[ShareNodePos[0]][0] == iFirstNode:
                break
        else:
            print ('[INPUT] CANNOT FIND CONNECTED FREE EDGE. CHECK TIE CONDITION')
            del (outEdge)
            outEdge = EDGE()
            return outEdge
        # print ('sharenodePos count = ', len(ShareNodePos))

        if len(ShareNodePos) == 1:
            FreeEdge.Edge[ShareNodePos[0]][5] = 1
            outEdge.Add(FreeEdge.Edge[ShareNodePos[0]])
            i = ShareNodePos[0]
            del ShareNodePos
            ShareNodePos = []
        else:
            if FreeEdge.Edge[i][4] == FreeEdge.Edge[ShareNodePos[0]][4]:
                tmpPos = ShareNodePos[1]
            else:
                SHARE = ShareEdge(FreeEdge.Edge[i][4], FreeEdge.Edge[ShareNodePos[1]][4], Element)
                if SHARE == 1:
                    tmpPos = ShareNodePos[0]
                else:
                    tmpPos = ShareNodePos[1]

                    #######################################################
                    nfe1 = 0; nfe2 = 0
                    for fe in FreeEdge.Edge:
                        if fe[4] == FreeEdge.Edge[tmpPos][4]:
                            # print (fe)
                            nfe1 += 1
                        if fe[4] == FreeEdge.Edge[ShareNodePos[0]][4]:
                            # print (fe)
                            nfe2 += 1
                    # print ("nfe=", nfe, FreeEdge[tmpPos])
                    if nfe1 < nfe2:
                        tmpPos = ShareNodePos[0]
                    elif nfe1 == nfe2:
                        tienode = FreeEdge.Edge[tmpPos][0]
                        nc = 0
                        for fe in FreeEdge.Edge:
                            if fe[4] == FreeEdge.Edge[tmpPos][4] and fe[1] == tienode: 
                                nc += 1
                                break
                        if nc == 0:   tmpPos = ShareNodePos[0]
                    ########################################################

            FreeEdge.Edge[tmpPos][5] = 1
            outEdge.Add(FreeEdge.Edge[tmpPos])
            i = tmpPos
            del ShareNodePos
            ShareNodePos = []
            
    return outEdge
def ShareEdge(m, n, Elements):
    p = ElementShape(m, Elements)
    q = ElementShape(n, Elements)
    lst = []
    if type(lst) != type(Elements): 
        N = len(Elements.Element)
        for i in range(N):
            if m == Elements.Element[i][0]:
                k = i
            if n == Elements.Element[i][0]:
                l = i

        count = 0
        for i in range(1, p+1):
            for j in range(1, q+1):
                if Elements.Element[k][i] == Elements.Element[l][j]:
                    count += 1
    else: 
        for i, el in enumerate(Elements): 
            if m == el[0]: k = i
            if n == el[0]: l = i
        count = 0 
        for i in range(1, p+1):
            for j in range(1, q+1):
                if Elements[k][i] == Elements[l][j]:
                    count += 1

    if count >= 2:
        return 1  # Edge shared
    else:
        return 0
def ElementShape(k, Elements):
    # k = element No.
    lst = []
    if type(lst) != type(Elements): 
        for el in Elements.Element: 
            if k == el[0]: return el[6]
    else: 
        for el in Elements: 
            if k == el[0]: 
                return el[6]

    print (k, 'Element was not found')
    return 0
def Delete_Close_Points(lst, point_gap, backward=False): 
    if backward: 
        i = 0 
        while i < len(lst): 
            j = i +1
            fd = False  
            while j < len(lst): 
                L = math.sqrt((lst[i][2] -lst[j][2])**2  + (lst[i][3] - lst[j][3])**2)
                if L <point_gap:
                    fd = True 
                    break 
                j +=1
            if fd: 
                del(lst[i])
                continue 
            i += 1 
    else: 
        i = 0 
        while i < len(lst): 
            j = i +1
            while j < len(lst): 
                L = math.sqrt((lst[i][2] -lst[j][2])**2  + (lst[i][3] - lst[j][3])**2)
                if L <point_gap:
                    del(lst[j]) 
                    continue 
                j +=1
            i += 1 
    return lst 

def ResultSfric(model="", result="", sfric='', deformed=1, ht=8.0E-03, sfht=1.0E-03):

    """
    Extracting the results from HK-SMART sfric file 
    sfric should be defined as a class of SFRIC -> sfric = SFRIC()
    sfric's member : self.Node, self.Surface, self.Rim, self.Road
    if deformed ==0: this reads only model file. 
    Example :
            sfric = SFRIC()
            ResultSfric(model=osfric, result=rsfric, sfric=sfric, deformed=1)
    """
    sfricfile = model 
    sfricresultfile = result 
    if sfricfile !="" or sfricresultfile !="":
        if  sfricfile == "" : sfricfile = sfricresultfile[:-3]
        ## definition variables 
        EN_SDB_TITLE=11         
        EN_SDB_LOCAL_COORD = 12        
        EN_SDB_NODE = 21
        EN_SDB_ELEM_3D = 31      
        EN_SDB_ELEM_2D = 32
        EN_SDB_NSET    = 41
        EN_SDB_ELSET3D = 51       
        EN_SDB_ELSET2D = 52
        EN_SDB_RIM     = 61    
        EN_SDB_ROAD = 62
        EN_SDB_IMPACTOR = 63
        EN_SDB_END     = 999

        EN_RESULT_TITLE = 13
        EN_RESULT=14
        EN_RESULT_ERR=1101
        EN_RESULT_DIS=101
        EN_RESULT_DIS_X=102 
        EN_RESULT_DIS_Y=103 
        EN_RESULT_DIS_Z=104
        EN_RESULT_ELEMENT = 2   
        EN_RESULT_RIGID=1
        RESULT_Temperature=3101

        RESULT_NodalArea = 900000001
        RESULT_NodalAreaPJTRatio=900000002
        RESULT_FricEnergyRateSum = 900000011
        RESULT_FricEnergyRateX=900000012
        RESULT_FricEnergyRateY=900000013
        RESULT_FricEnergyRateZ=900000014
        RESULT_SlipVelocityMag=900000021
        RESULT_SlipVelocityX=900000022
        RESULT_SlipVelocityY=900000023
        RESULT_SlipVelocityZ=900000024
        RESULT_SlipFlag=900000030
        RESULT_FricCoefficient = 900000031
        RESULT_ContactShearForceMag = 900000041
        RESULT_ContactShearForceX = 900000042
        RESULT_ContactShearForceY=900000043
        RESULT_ContactForceNormal=900000044
        RESULT_ContactShearStressMag = 900000051
        RESULT_ContactShearStressX = 900000052
        RESULT_ContactShearStressY = 900000053
        RESULT_ContactStressNormal = 900000054
        RESULT_FricEnergyAccumSum=900000061
        RESULT_FricEnergyAccumX = 900000062
        RESULT_FricEnergyAccumY = 900000063
        RESULT_FricEnergyAccumZ = 900000064
        RESULT_WEAR = 900328631
    else: 
        return 0

    if isfile(sfricfile) == False: 
        print ("No sfric model file")
        return 0
    file = open(sfricfile, 'rb')
    file.seek(0,2); fend = file.tell() #find the end position of binary file
    file.seek(0);   fpos = file.tell() #find the start position of binary file

    ### SFRIC FILE
    READ_LENGTH = 0
    # CAMBER=[0.0]
    NLB = []
    

    while file.tell() < fend:
        BlockID     = struct.unpack('i', file.read(4))[0]

        if BlockID == EN_SDB_TITLE:
            BlockLength = struct.unpack('i', file.read(4))[0]
            BlockTitle = ''
            for i in range(BlockLength): 
                BlockTitle += str(struct.unpack('c', file.read(1))[0])

        elif BlockID == EN_SDB_LOCAL_COORD:
            LocalCoord = []
            for i in range(9):
                LocalCoord.append(struct.unpack('d', file.read(8))[0])
                # CAMBER[0] = math.atan(LocalCoord[5]/LocalCoord[4])*180/math.pi

        elif BlockID == EN_SDB_NODE:
            NodesNUM = struct.unpack('i', file.read(4))[0]
            for i in range(NodesNUM):
                Label = struct.unpack('i', file.read(4))[0]
                NLB.append(Label)
            for i in range(NodesNUM):
                X = struct.unpack('d', file.read(8))[0]
                Y = struct.unpack('d', file.read(8))[0]
                Z = struct.unpack('d', file.read(8))[0]
                sfric.Node.Add([NLB[i], X, Y, Z, 0.0, 0.0])
            # print ("NODE NUM", NodesNUM)

        elif BlockID == EN_SDB_ELEM_3D:
            E3DNUM = struct.unpack('i', file.read(4))[0]
            E3D = []
            for i in range(E3DNUM): 
                ID = struct.unpack('i', file.read(4))[0]
                N1 = struct.unpack('i', file.read(4))[0]
                N2 = struct.unpack('i', file.read(4))[0]
                N3 = struct.unpack('i', file.read(4))[0]
                N4 = struct.unpack('i', file.read(4))[0]
                N5 = struct.unpack('i', file.read(4))[0]
                N6 = struct.unpack('i', file.read(4))[0]
                N7 = struct.unpack('i', file.read(4))[0]
                N8 = struct.unpack('i', file.read(4))[0]
                E3D.append([ID, N1, N2, N3, N4, N5, N6, N7, N8])

        elif BlockID == EN_SDB_ELEM_2D:
            E2DNUM = struct.unpack('i', file.read(4))[0]
            # Surf.count = E2DNUM
            tsurface = []
            for i in range(E2DNUM):
                ID = struct.unpack('i', file.read(4))[0]
                N1 = struct.unpack('i', file.read(4))[0]
                N2 = struct.unpack('i', file.read(4))[0]
                N3 = struct.unpack('i', file.read(4))[0]
                N4 = struct.unpack('i', file.read(4))[0]
                tsurface.append([ID, N1, N2, N3, N4])

        elif BlockID == EN_SDB_ELSET3D or BlockID == EN_SDB_ELSET2D:
            BlockLength = struct.unpack('i', file.read(4))[0]
            name = ''
            for i in range(BlockLength): 
                name += str(struct.unpack('c', file.read(1))[0])
            
            BlockFlag   = struct.unpack('i', file.read(4))[0]
            ENUM = struct.unpack('i', file.read(4))[0]
            ESET = []
            for i in range(ENUM):
                ESET.append(struct.unpack('i', file.read(4))[0])
            del(ESET)

        elif BlockID == EN_SDB_RIM:
            ControlNodeID = struct.unpack('i', file.read(4))[0]
            X = struct.unpack('d', file.read(8))[0]
            Y = struct.unpack('d', file.read(8))[0]
            Z = struct.unpack('d', file.read(8))[0]
            R = struct.unpack('d', file.read(8))[0]
            W = struct.unpack('d', file.read(8))[0]
            G = struct.unpack('i', file.read(4))[0]
            sfric.Rim.Add([ControlNodeID, X, Y, Z])

            for i in range(G):
                BlockFlag   = struct.unpack('i', file.read(4))[0]

            for i in range(G):
                X1 = struct.unpack('d', file.read(8))[0]
                Y1 = struct.unpack('d', file.read(8))[0]
                X2 = struct.unpack('d', file.read(8))[0]
                Y2 = struct.unpack('d', file.read(8))[0]
        
        elif BlockID == EN_SDB_ROAD:
            Tref = struct.unpack('d', file.read(8))[0]
            ControlNodeID = struct.unpack('i', file.read(4))[0]
            X = struct.unpack('d', file.read(8))[0]
            Y = struct.unpack('d', file.read(8))[0]
            Z = struct.unpack('d', file.read(8))[0]
            R = struct.unpack('d', file.read(8))[0]
            W = struct.unpack('d', file.read(8))[0]
            L = struct.unpack('d', file.read(8))[0]
            sfric.Road.Add([ControlNodeID, X, Y, Z])

        elif BlockID == EN_SDB_END:
            BlockID     = struct.unpack('i', file.read(4))[0]
            ESP         = ''

            for i in range(4):
                ESP += str(struct.unpack('c', file.read(1))[0])

            RecordHead  = struct.unpack('i', file.read(4))[0]
            BlockID     = struct.unpack('i', file.read(4))[0]
            SolverInfo  = ''

            for i in range(42): 
                SolverInfo += str(struct.unpack('c', file.read(1))[0])
            for i in range(9):
                BlockID     = struct.unpack('i', file.read(4))[0] 
            
            SimulationType = ''
            for i in range(26):
                SimulationType += str(struct.unpack('c', file.read(1))[0])

        else:
            break

    file.close()

    if len(sfric.Node.Node) == 0 : 
        print ("There is no information in 'sfric'")
        return 0
    if not deformed : return 0
    if isfile(sfricresultfile) == False: 
        print ("No sfric result file")
        return 0

    cnodes = np.array(sfric.Node.Node)
    ix1 = np.where(cnodes[:,1]> -0.0001)[0]
    ix2 = np.where(cnodes[:,1]<  0.01  )[0]
    ix1 = np.intersect1d(ix1, ix2)

    ix1 = np.where(cnodes[:,2] >= -0.0001)[0]
    ix2 = np.where(cnodes[:,2]<0.01)[0]
    ix2 = np.intersect1d(ix1, ix2)

    ix = np.intersect1d(ix1, ix2)
    midnodes = cnodes[ix]

    Ymin = np.min(midnodes[:,2])
    ix = np.where(midnodes[:,2]==Ymin)[0][0]
    cNode = midnodes[ix]


    if sfricresultfile != "":
        resultsfile = open(sfricresultfile, 'rb')
        resultsfile.seek(0,2); fend = resultsfile.tell() #find the end position of binary file
        resultsfile.seek(0);   fpos = resultsfile.tell() #find the start position of binary file
    else:
        return 0

    DISP=[]
    DeformedRigid=NODE()
    while resultsfile.tell() < fend:
        RecordHeaderID     = struct.unpack('i', resultsfile.read(4))[0]
        # print ("**", RecordHeaderID)
        if RecordHeaderID == EN_RESULT_TITLE:
            RecordValue    = struct.unpack('i', resultsfile.read(4))[0]
            OutputStepTime = struct.unpack('d', resultsfile.read(8))[0]
            OutputStepID       = struct.unpack('i', resultsfile.read(4))[0]
            OutputStepName = ''
            for i in range(26): 
                OutputStepName += str(struct.unpack('c', resultsfile.read(1))[0])
            OutputStepNo      = struct.unpack('i', resultsfile.read(4))[0]
            OutputStepNode    = struct.unpack('i', resultsfile.read(4))[0]
            NodeNUM           = struct.unpack('i', resultsfile.read(4))[0]

            for i in range(NodeNUM): 
                NodeID = int(struct.unpack('i', resultsfile.read(4))[0])
                DISP.append([NodeID, 0.0,0.0,0.0])

        elif RecordHeaderID == EN_RESULT:
            RecordValue    = struct.unpack('i', resultsfile.read(4))[0]
            IDATA_TYPE     = struct.unpack('i', resultsfile.read(4))[0]
            IOUT_TYPE      = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP1         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP2         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP3         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP4         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP5         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP6         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP7         = struct.unpack('i', resultsfile.read(4))[0]
            ICOMP8         = struct.unpack('i', resultsfile.read(4))[0]
            IDIRECTION     = struct.unpack('i', resultsfile.read(4))[0]
            ICALC_WARN     = struct.unpack('i', resultsfile.read(4))[0]
            IDMINV         = struct.unpack('i', resultsfile.read(4))[0]
            IDMAXV         = struct.unpack('i', resultsfile.read(4))[0]
            VMIN           = struct.unpack('d', resultsfile.read(8))[0]
            VMAX           = struct.unpack('d', resultsfile.read(8))[0]
            DATA_TITLE     = ''
            for i in range(26):
                DATA_TITLE += str(struct.unpack('c', resultsfile.read(1))[0])
            if RecordValue == EN_RESULT_DIS_X:
                for i in range(NodeNUM):
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    if math.isnan(Value) == False: sfric.Node.Node[i][1] += Value
                    else:
                        print ("Error in sfric result file (Del X = not a number).")
                        return 0
            elif RecordValue == EN_RESULT_DIS_Y:
                for i in range(NodeNUM):
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    sfric.Node.Node[i][2] += Value

            elif RecordValue == EN_RESULT_DIS_Z:
                for i in range(NodeNUM):
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    sfric.Node.Node[i][3] += Value

            elif RecordValue == RESULT_ContactStressNormal:
                for i in range(NodeNUM):
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    sfric.Node.Node[i][4] += Value
            elif RecordValue == RESULT_ContactForceNormal:
                for i in range(NodeNUM):
                    Value = struct.unpack('d', resultsfile.read(8))[0]
                    sfric.Node.Node[i][5] += Value
            else:
                for i in range(NodeNUM):
                    Value = struct.unpack('d', resultsfile.read(8))[0]

        elif RecordHeaderID == EN_RESULT_ELEMENT:
            TREAD_ELMENTNUM = struct.unpack('i', resultsfile.read(4))[0]
            for i in range(TREAD_ELMENTNUM): 
                TreadID = struct.unpack('i', resultsfile.read(4))[0]
        elif RecordHeaderID == EN_RESULT_RIGID:
            ELMENT_NUM   = struct.unpack('i', resultsfile.read(4))[0]
            rd = "" 

            for i in range(ELMENT_NUM): 
                ID = struct.unpack('i', resultsfile.read(4))[0]
                DeformedRigid.Add([ID, 0.0, 0.0, 0.0])

            while resultsfile.tell() < fend:
                RecordHeaderID     = struct.unpack('i', resultsfile.read(4))[0]
                RecordValue    = struct.unpack('i', resultsfile.read(4))[0]
                IDATA_TYPE     = struct.unpack('i', resultsfile.read(4))[0]
                IOUT_TYPE      = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP1         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP2         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP3         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP4         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP5         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP6         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP7         = struct.unpack('i', resultsfile.read(4))[0]
                ICOMP8         = struct.unpack('i', resultsfile.read(4))[0]
                IDIRECTION     = struct.unpack('i', resultsfile.read(4))[0]
                ICALC_WARN     = struct.unpack('i', resultsfile.read(4))[0]
                IDMINV         = struct.unpack('i', resultsfile.read(4))[0]
                IDMAXV         = struct.unpack('i', resultsfile.read(4))[0]
                VMIN           = struct.unpack('d', resultsfile.read(8))[0]
                VMAX           = struct.unpack('d', resultsfile.read(8))[0]
                DATA_TITLE     = ''
                for i in range(26): 
                    DATA_TITLE += str(struct.unpack('c', resultsfile.read(1))[0])

                if RecordValue == EN_RESULT_DIS_X:
                    for i in range(ELMENT_NUM): 
                        Value = struct.unpack('d', resultsfile.read(8))[0]
                        DeformedRigid.Node[i][1] = Value
                elif RecordValue == EN_RESULT_DIS_Y:
                    for i in range(ELMENT_NUM): 
                        Value = struct.unpack('d', resultsfile.read(8))[0]
                        DeformedRigid.Node[i][2] = Value
                elif RecordValue == EN_RESULT_DIS_Z:
                    for i in range(ELMENT_NUM): 
                        Value = struct.unpack('d', resultsfile.read(8))[0]
                        DeformedRigid.Node[i][3] = Value
                else:
                    for i in range(ELMENT_NUM): 
                        Value = struct.unpack('d', resultsfile.read(8))[0]
        else: 
            break 

    resultsfile.close()

    for rdg in DeformedRigid.Node:
        if rdg[0] == sfric.Rim.Node[0][0]:  
            sfric.Rim.Node[0][1] += rdg[1]
            sfric.Rim.Node[0][2] += rdg[2]
            sfric.Rim.Node[0][3] += rdg[3]
        if rdg[0] == sfric.Road.Node[0][0]:  
            sfric.Road.Node[0][1] += rdg[1]
            sfric.Road.Node[0][2] += rdg[2]
            sfric.Road.Node[0][3] += rdg[3]

    minz  = sfric.Node.Node[0][3]
    for nd in sfric.Node.Node:
        if minz > nd[3]: 
            minz = nd[3] 
    for nd in sfric.Node.Node:
        if nd[3] < minz + ht:
            sfric.pNode.Add(nd)   ## bottom nodes... 

    sfric.Node.Node = np.array(sfric.Node.Node)
    minz = np.min(sfric.Node.Node[:,3])
    ix = np.where (sfric.Node.Node[:,3] < minz + ht)[0]
    sfric.pNode.Node = sfric.Node.Node[ix]
    ndx = sfric.pNode.Node[:,0]

    srf = np.array(tsurface)

    bodyoffset = -1 
    sf1000 = srf[:1000]
    for s in sf1000: 
        OF1 = s[1] - s[4]; OF2 = s[2] - s[3] 
        if OF1 == OF2 and OF1%1000  == 0 and OF1 > 2000 and OF1 <10001:
            bodyoffset = abs(OF1) 

    nsurf = np.max (srf[:,1])
    if nsurf > 10**7 and  bodyoffset == 10000: 
        ix = np.where(srf[:,1]>=10**7)[0]
        srf = srf[ix]
    elif nsurf > 10**6 and bodyoffset < 10000 and bodyoffset > 2000: 
        ix = np.where(srf[:,1]>=10**6)[0]
        srf = srf[ix]

    print ("BODY OFFSET %d"%(bodyoffset))
    for sf in srf:
        coord = []
        ex =0
        for i in range(1, 5):
            re = np.where(ndx == sf[i])
            if len(re[0]) >0 and sfric.pNode.Node[re[0][0]][3] < minz+sfht:
                coord.append(sfric.pNode.Node[re[0][0]])
            else:
                ex =1
                break
        if ex ==0:
            # sfric.Surface.Add([sf[0], sf[1], sf[2], sf[3], sf[4], coord])
            sfric.Surface.Surface.append([sf[0], sf[1], sf[2], sf[3], sf[4], coord])
    print ("no of contact surface %d"%(len(sfric.Surface.Surface)))
    
    return cNode

def NormalVector_plane(n1, n2, n3): 
    a = [0, n1[1]-n2[1], n1[2]-n2[2], n1[3]-n2[3]]
    b = [0, n3[1]-n2[1], n3[2]-n2[2], n3[3]-n2[3]]

    II = a[2]*b[3] - a[3]*b[2]
    JJ = a[3]*b[1] - a[1]*b[3]
    KK = a[1]*b[2] - a[2]*b[1]

    return [0, II, JJ, KK]

def NormalVector(n1, n2):
    x1 = n1[1]; y1 = n1[2]; z1 = n1[3]
    x2 = n2[1]; y2 = n2[2]; z2 = n2[3]

    vx = y1*z2 - z1*y2 
    vy = z1*x2 - x1*z2 
    vz = x1*y2 - y1*x2 
    norm = [0, vx, vy, vz]
    return norm 
def Angle_Between_Vectors(va, vb):
    la = math.sqrt(va[1]*va[1] + va[2]*va[2] + va[3]*va[3])
    lb = math.sqrt(vb[1]*vb[1] + vb[2]*vb[2] + vb[3]*vb[3])
    cos = round((va[1]*vb[1]+va[2]*vb[2]+va[3]*vb[3]) / la/lb , 8)
    return round(math.acos(cos), 10)    
    
def CalculateAngleFrom3Node(N1, N2, Center, XY=13, **args):
    for key, value in args.items():
        if key == 'xy':
            XY = int(value)
    
    ix = int(XY/10)
    iy = int(XY)%10  
    
    V1x = N1[ix] - Center[ix]
    V1y = N1[iy] - Center[iy]
    V2x = N2[ix] - Center[ix]
    V2y = N2[iy] - Center[iy]
    
    L1 = math.sqrt(V1x*V1x + V1y*V1y)
    L2 = math.sqrt(V2x*V2x + V2y*V2y)
    
    try:
        return math.acos(round((V1x*V2x+V1y*V2y)/(L1*L2), 10))
    except: 
        
        print ("ERROR. During Calculating Angle between Nodes - a in acos(a) is over 1.0 or L1*L2 = 0")
        print ("  Length : ", L1,',', L2)
        print ("  Node 1 : ", N1)
        print ("  Node 2 : ", N2)
        print ("  Center : ", Center)
        return 0

def Area(xs=[], ys=[]): 
    x =[]; y=[]
    for px, py in zip(xs, ys):
        x.append(px)
        y.append(py)
    x.append(xs[0]); y.append(ys[0])

    A = [0.0, 0.0, 0.0]
    n = len(x)-1
    for i in range(n):
        s = x[i] * y[i + 1] - x[i + 1] * y[i]
        A[0] += s
        A[1] += (x[i] + x[i + 1]) * s
        A[2] += (y[i] + y[i + 1]) * s
    A[0] = A[0] / 2.0
    return A[0]

def Angle_3Points(xs=None, ys=None, center_index=1 ,**args):
    centerX = xs[center_index]; centerY = ys[center_index]
    idx = center_index + 1 
    if idx >=3: idx -= 3 
    V1x = xs[idx]; V1y = ys[idx]
    idx = idx + 1 
    if idx >=3: idx -= 3 
    V2x = xs[idx]; V2y = ys[idx]
    
    L1 = math.sqrt(V1x*V1x + V1y*V1y)
    L2 = math.sqrt(V2x*V2x + V2y*V2y)
    
    try:
        return math.acos(round((V1x*V2x+V1y*V2y)/(L1*L2), 10))
    except: 
        print ("ERROR. During Calculating Angle between Nodes - a in acos(a) is over 1.0 or L1*L2 = 0")
        print ("  Length : ", L1,',', L2)
        print ("  Node 1 : ", N1)
        print ("  Node 2 : ", N2)
        print ("  Center : ", Center)
        return 0

def interpolation_footprint_pressure(initSfric=None, resultSfric=None, vmin=0, vmax=100000, rotating=0.0, cmap='rainbow', displim=0.15,\
     dotNum=5, trd=10**7, savefile="", dpi=300, post=None,  centerNode_initial=None, Yshift=0.0, ptn=None, Onlyribshape=False): 
    if resultSfric and initSfric: 
        sfric = SFRIC() #ResultSfric(model="", result="", sfric='', deformed=1, ht=8.0E-03, sfht=1.0E-03)
        centerNode_initial = ResultSfric(model=initSfric, result=resultSfric,sfric=sfric, ht=0.8e-3, sfht=1.0e-3)
        nodes = np.array(sfric.Node.Node)
        node_ids = nodes[:,0]

        td_Offset = findout_offset(node_ids, step=10**4, shift=-10**7)
        print (" Tread Pitch Offset=%d"%(td_Offset))
        minZ = np.min(nodes[:,3])

        idx = np.where(nodes[:,0] > 10**7)[0]

        tdnodes = nodes[idx]
        totalContactForce = np.sum(tdnodes[:,5])

        surfaces = sfric.Surface.Surface
    elif post: 
        td_Offset = 10000

        with open(post) as DAT: 
            lines = DAT.readlines()
        cmd = None 
        for line in lines: 
            if "*" in line: 
                if "*NODE" in line : 
                    cmd = "ND"
                    nodes=[]
                elif "*ELEMENT" in line : 
                    cmd = 'EL'
                    els =[]
                else: 
                    cmd = None 
            else: 
                data = line.split(",")
                for d in data: 
                    d = d.strip()

                if cmd == 'ND': 
                    nodes.append([int(data[0]), float(data[1]), float(data[2]), float(data[3]), float(data[4]), float(data[5])])
                if cmd == "EL": 
                    els.append( [int(data[0]), int(data[1]), int(data[2]), int(data[3]), int(data[4])] )

        nodes = np.array(nodes)
        minZ = np.min(nodes[:,3])
        idx = np.where(nodes[:,0] > 10**7)[0]
        tdnodes = nodes[idx]
        totalContactForce = np.sum(tdnodes[:,5])

        surfaces =[]
        for el in els: 
            ix = np.where(nodes[:,0]==el[1])[0]
            if len(ix):  n1 = nodes[ix[0]]
            else: continue 
            ix = np.where(nodes[:,0]==el[2])[0]
            if len(ix):  n2 = nodes[ix[0]]
            else: continue 
            ix = np.where(nodes[:,0]==el[3])[0]
            if len(ix):  n3 = nodes[ix[0]]
            else: continue 
            ix = np.where(nodes[:,0]==el[4])[0]
            if len(ix):  n4 = nodes[ix[0]]
            else: continue 

            surfaces.append([el[0], el[1], el[2], el[3], el[4], [n1, n2, n3, n4]])
        # surfaces = np.array(surfaces)

    else: 
        print (" No results for footprint")
        return 

    if not isfile('topsurf.tmp'): 
        print ("## Generating topsurf.tmp ## ")
        if not ptn: 
            jobdir = getcwd()
            ptns = glob.glob(jobdir+"/*.ptn")
        if len(ptns): 
            PTN = PATTERN(ptns[0], start_number=10**7)
        else: 
            ptn = None 
                
    topsurf = 'topsurf.tmp'
    if isfile(topsurf): 
        with open(topsurf) as TF: 
            lines = TF.readlines()
        tops =[]
        for line in lines: 
            wd = line.split(",")
            tops.append([int(wd[0].strip()), int(wd[1].strip()), int(wd[2].strip()), int(wd[3].strip()), int(wd[4].strip())])
        tops = np.array(tops)

    ht = 2.0e-3
    mht = ht*2.0
    gap = 0.3e-3

    cnt = 0 
    ActualArea = 0 
    
    for sf in surfaces: 

        if (sf[5][0][3] <= minZ + ht or sf[5][1][3] <= minZ + ht or sf[5][2][3] <= minZ + ht or sf[5][3][3] <= minZ + ht) and \
            (sf[5][0][3] <= minZ + mht and sf[5][1][3] <= minZ + mht and sf[5][2][3] <= minZ + mht and sf[5][3][3] <= minZ + mht) : 
            if isfile(topsurf): 
                ix1 = np.where(tops[:, 1:] - trd == int(sf[5][0][0] - trd)%td_Offset )[0]
                ix2 = np.where(tops[:, 1:] - trd == int(sf[5][1][0] - trd)%td_Offset )[0]
                ix3 = np.where(tops[:, 1:] - trd == int(sf[5][2][0] - trd)%td_Offset )[0]
                ix4 = np.where(tops[:, 1:] - trd == int(sf[5][3][0] - trd)%td_Offset )[0]
                ix = np.intersect1d(ix1, ix2)
                ix = np.intersect1d(ix,  ix3)
                ix = np.intersect1d(ix,  ix4)
                if len(ix):
                    contacting = True 
                else: 
                    gap1 = abs(sf[5][0][3] - sf[5][1][3])
                    gap2 = abs(sf[5][1][3] - sf[5][2][3])
                    gap3 = abs(sf[5][2][3] - sf[5][3][3])
                    gap4 = abs(sf[5][3][3] - sf[5][1][3])

                    if gap1<gap and gap2<gap and gap3<gap and gap4<gap: 
                        contacting = True 
                    else: 
                        contacting = False 
            else: 
                contacting = True  
            if contacting : 
                ys = [sf[5][0][1], sf[5][1][1], sf[5][2][1], sf[5][3][1]]
                xs = [sf[5][0][2], sf[5][1][2], sf[5][2][2], sf[5][3][2]]
                vs = [sf[5][0][4], sf[5][1][4], sf[5][2][4], sf[5][3][4]]
                counting = 0 
                for m in range(4): 
                    if vs[m] > vmin: 
                        counting += 1 
                if counting >0  : 
                    if sf[5][2][0] == sf[5][3][0] : 
                        ax = [sf[5][0][1], sf[5][1][1], sf[5][2][1]]
                        ay = [sf[5][0][2], sf[5][1][2], sf[5][2][2]]
                        shape = 3 
                        if sf[5][3][4] > vmin:   counting -= 1 
                    else: 
                        ax = [sf[5][0][1], sf[5][1][1], sf[5][2][1], sf[5][3][1]]
                        ay = [sf[5][0][2], sf[5][1][2], sf[5][2][2], sf[5][3][2]]
                        shape = 4 
                    ActualArea += abs(Area(ax, ay)) * counting / shape 
                if cnt ==0: 
                    px, py, pv = meshgrid_in_Quadrilateral(xs, ys, num=dotNum, vs=vs)
                    cnt += 1
                else: 
                    ipx, ipy, ipv = meshgrid_in_Quadrilateral(xs, ys, num=dotNum, vs=vs)
                    px = np.append(px, ipx, axis=0)
                    py = np.append(py, ipy, axis=0)
                    pv = np.append(pv, ipv, axis=0)
                    cnt += 1

    # print (" Surfaces=%d, Z under=%f"%(cnt, minZ+ht))

    if rotating: 
        angle = math.radians(rotating)
        for x, y in zip(px, py): 
            x = math.cos(angle)*x - math.sin(angle)*y 
            y = math.sin(angle)*x + math.cos(angle)*y 

    ###############################################################
    ## Centering in X direction 
    ###############################################################
    
    if not Yshift:
        shift = 0.0 
        if resultSfric and initSfric: 
            init_sfric = SFRIC() 
            _ = ResultSfric(model=initSfric, result=resultSfric,sfric=init_sfric, ht=0.8e-3, sfht=1.0e-3, deformed=0)
            # tdnodes
            initNodes = np.array(init_sfric.Node.Node)
            contactheight = np.min(tdnodes[:,3])
            ix = np.where(tdnodes[:, 3] < contactheight+0.0001)[0]
            nd_contacts = tdnodes[ix] 

            if rotating:
                for x, y in zip(nd_contacts[:,2], nd_contacts[:,3]): 
                    x = math.cos(angle)*x - math.sin(angle)*y 
                    y = math.sin(angle)*x + math.cos(angle)*y 
            center_contacts=[]
            gap = 3.0e-3
            while not len(center_contacts): 
                ix1 = np.where(nd_contacts[:,1]>-gap)[0]
                ix2 = np.where(nd_contacts[:,1]< gap)[0]
                ix = np.intersect1d(ix1, ix2)
                mid_contacts = nd_contacts[ix]

                ix1 = np.where(mid_contacts[:,2]>-gap)[0]
                ix2 = np.where(mid_contacts[:,2]< gap)[0]
                ix = np.intersect1d(ix1, ix2)
                center_contacts = mid_contacts[ix]
                gap += 1e-3
                if gap > 30.0e-3: break 
            contactnode = center_contacts[0]
            idx = np.where(initNodes[:,0] == contactnode[0])[0][0]
            contactnode_init = initNodes[idx]
            shift = -contactnode[2] + contactnode_init[2] 
        elif  isfile('shift.tmp'): 
                with open('shift.tmp') as SH: 
                    line = SH.readlines()
                shift = float(line[0].strip() )
    else: 
        shift = Yshift 
    px = px.flatten(); py.flatten(); pv.flatten()
    print ("* Footprint Lateral shift =%.2fmm"%(shift*1000) )
    px += shift 
    # px.flatten(); py.flatten(); pv.flatten()
    return px.flatten(), py.flatten(), pv.flatten(), ActualArea, shift  

def footPrintWith_belt(px, py, pv, vmin=5E4, cmap='rainbow', displim=0.15, savefile="", dpi=300, nodes=None, outer=None,\
     belt=None, bead=None, carcass=None, initnode=None, shift=0): 
    size =0.3
    fig, ax = plt.subplots()
    plt.axis('equal')
    plt.xlabel("Lateral Position(m)", size=11)
    plt.ylabel("Longitudinal Position(m)", size=11)
    plt.xticks(size=10)
    plt.yticks(size=10)
    plt.title("Contact Pressure(Pa) Distribution", size=14)
    
    points = plt.scatter(px, py, c=pv, s=size, cmap=cmap, vmin=vmin, vmax=vmin*10, edgecolors=None, linewidths=0.0 )
    
    #######################################################################
    ## saving profile 
    #######################################################################
    
    fp = open(savefile+"-outerprofile.inp", 'w')
    fp.write("*NODE\n")
    for n in initnode:
        fp.write("%10d, %.7f, %.7f, %.7f\n"%(n[0], n[3], n[2], n[1]))
    iniMinZ = np.min(initnode[:, 3])
    dfmMinZ = np.max(nodes[:,3])
    zmove = iniMinZ + dfmMinZ
    ofn = 5000
    for n in nodes:
        z = math.sqrt((n[3]**2+n[1]**2))
        fp.write("%10d, %.7f, %.7f, %.7f\n"%(n[0]+ofn, z+zmove, n[2], 0.0))
    
    fp.write("*ELEMENT, TYPE=MGAX1\n")
    # cnt = 0 
    for ed in outer: 
        # cnt += 1
        # print ("out %6d :  %6d, %6d, %6d"%(cnt, ed[4], ed[0], ed[1]))
        fp.write("%10d, %10d, %10d\n"%(ed[4], ed[0], ed[1]))
        fp.write("%10d, %10d, %10d\n"%(ed[4]+ofn, ed[0]+ofn, ed[1]+ofn))
    # cnt = 0 
    for ed in belt:
        # cnt += 1
        # print ("bt %6d :  %6d, %6d, %6d"%(cnt, ed[4], ed[0], ed[1]))
        fp.write("%10d, %10d, %10d\n"%(ed[4], ed[0], ed[1]))
        fp.write("%10d, %10d, %10d\n"%(ed[4]+ofn, ed[0]+ofn, ed[1]+ofn))
    # cnt = 0 
    for ed in bead:
        # cnt += 1
        # print ("bd %6d :  %6d, %6d, %6d"%(cnt, ed[4], ed[0], ed[1]))
        fp.write("%10d, %10d, %10d\n"%(ed[4], ed[0], ed[1]))
        fp.write("%10d, %10d, %10d\n"%(ed[4]+ofn, ed[0]+ofn, ed[1]+ofn))
    # cnt = 0 
    for ed in carcass:
        # cnt += 1
        # print ("cc %6d :  %6d, %6d, %6d"%(cnt, ed[4], ed[0], ed[1]))
        fp.write("%10d, %10d, %10d\n"%(ed[4], ed[0], ed[1]))
        fp.write("%10d, %10d, %10d\n"%(ed[4]+ofn, ed[0]+ofn, ed[1]+ofn))
    fp.write("*ELSET, ELSET=initial\n")
    cnt = 0 
    for ed in outer: 
        cnt += 1 
        if cnt%10 : fp.write("%10d, "%(ed[4]))
        else:  fp.write("%10d\n"%(ed[4]))
    if cnt%10: 
        fp.write("\n")
    fp.write("*ELSET, ELSET=deformed\n")
    cnt = 0 
    for ed in outer: 
        cnt += 1 
        if cnt%10 : fp.write("%10d, "%(ed[4]+ofn))
        else:  fp.write("%10d\n"%(ed[4]+ofn))
    if cnt%10: 
        fp.write("\n")
    fp.write("*ELSET, ELSET=BT_initial\n")
    cnt = 0 
    for ed in belt: 
        cnt += 1 
        if cnt%10 : fp.write("%10d, "%(ed[4]))
        else:  fp.write("%10d\n"%(ed[4]))
    if cnt%10: 
        fp.write("\n")
    fp.write("*ELSET, ELSET=BT_deformed\n")
    cnt = 0 
    for ed in belt: 
        cnt += 1 
        if cnt%10 : fp.write("%10d, "%(ed[4]+ofn))
        else:  fp.write("%10d\n"%(ed[4]+ofn))
    if cnt%10: 
        fp.write("\n")

    fp.write("*ELSET, ELSET=BD_initial\n")
    cnt = 0 
    for ed in bead: 
        cnt += 1 
        if cnt%10 : fp.write("%10d, "%(ed[4]))
        else:  fp.write("%10d\n"%(ed[4]))
    if cnt%10: 
        fp.write("\n")
    fp.write("*ELSET, ELSET=BD_deformed\n")
    cnt = 0 
    for ed in bead: 
        cnt += 1 
        if cnt%10 : fp.write("%10d, "%(ed[4]+ofn))
        else:  fp.write("%10d\n"%(ed[4]+ofn))
    if cnt%10: 
        fp.write("\n")

    fp.write("*ELSET, ELSET=CC_initial\n")
    cnt = 0 
    for ed in bead: 
        cnt += 1 
        if cnt%10 : fp.write("%10d, "%(ed[4]))
        else:  fp.write("%10d\n"%(ed[4]))
    if cnt%10: 
        fp.write("\n")
    fp.write("*ELSET, ELSET=CC_deformed\n")
    cnt = 0 
    for ed in bead: 
        cnt += 1 
        if cnt%10 : fp.write("%10d, "%(ed[4]+ofn))
        else:  fp.write("%10d\n"%(ed[4]+ofn))
    if cnt%10: 
        fp.write("\n")

    fp.close()
    ###########################################################

    dmax = np.max(py)
    
    lw = 0.2
    
    xs=[]; ys=[]
    
    for ed in outer: 
        ix1=np.where(nodes[:, 0] == ed[0])[0][0]
        ix2=np.where(nodes[:, 0] == ed[1])[0][0]
        xs.append([nodes[ix1][2]+shift, nodes[ix2][2]+shift])
        ys.append([ -math.sqrt (nodes[ix1][1]**2+nodes[ix1][3]**2), -math.sqrt (nodes[ix2][1]**2+nodes[ix2][3]**2)])

    xs = np.array(xs); ys = np.array(ys)
    lmin = np.min(ys)
    lmax = np.max(ys)
    lift = dmax - lmin + 0.05
    ys += lift 
    for tpx, tpy in zip(xs, ys): 
        plt.plot(tpx, tpy, 'black', lw=lw)

    nymax = np.max(ys)

    layout_Y = []
    xs=[]; ys=[]
    for ed in outer: 
        ix1=np.where(initnode[:, 0] == ed[0])[0][0]
        ix2=np.where(initnode[:, 0] == ed[1])[0][0]
        xs.append([  initnode[ix1][2]+shift,  initnode[ix2][2]+shift])
        ys.append([ -initnode[ix1][3], -initnode[ix2][3]])

    xs = np.array(xs); ys = np.array(ys)
    lmax = np.max(ys)
    lift_init = nymax - lmax
    ys += lift_init 
    for tpx, tpy in zip(xs, ys): 
        plt.plot(tpx, tpy, 'lightgray', lw=lw)

    bmin=0; bmax=0 
    neg=[]; pos=[]
    
    for ed in belt: 
        ix1=np.where(nodes[:, 0] == ed[0])[0][0]
        ix2=np.where(nodes[:, 0] == ed[1])[0][0]
        xs=[nodes[ix1][2]+shift, nodes[ix2][2]+shift]
        ys=[ -math.sqrt (nodes[ix1][1]**2+nodes[ix1][3]**2) +lift,-math.sqrt (nodes[ix2][1]**2+nodes[ix2][3]**2) +lift]
        plt.plot(xs, ys, 'red', lw=lw)
        if bmin > xs[0]:  
            neg = [xs[0], ys[0]]
            bmin = xs[0]
        if bmin > xs[1]:  
            neg = [xs[1], ys[1]]
            bmin = xs[1]
        if bmax < xs[0]:  
            pos = [xs[0], ys[0]]
            bmax = xs[0]
        if bmax < xs[1]:  
            pos = [xs[1], ys[1]]
            bmax = xs[1]

    displim *=2
    
    plt.plot([neg[0], neg[0]], [neg[1], 0], 'b:', lw=lw)
    plt.plot([pos[0], pos[0]], [pos[1], 0], 'b:', lw=lw)
    BeltMaxWidth = bmax - bmin 
    plt.text(0, nymax+0.01, "Max BT Width(deformed): %.1fmm"%(BeltMaxWidth*1000), fontsize=6, color='black', ha='center')

    ix1 = np.where(py> -0.005)[0]
    ix2 = np.where(py<  0.005)[0]
    ix = np.intersect1d(ix1, ix2)
    mid_py = py[ix];            mid_px = px[ix]
    mid_mn = np.min(mid_px);    mid_mx = np.max(mid_px)
    Max_ContactWidth = mid_mx-mid_mn 
    dmin = np.min(py)

    plt.text(0, dmin-0.04,   "Contact Width: %.1fmm"%(Max_ContactWidth*1000), fontsize=6, color='black', ha='center')

    plt.ylim(dmin-0.08, nymax*1.2)
    plt.xlim(-displim*2, displim*2)
    plt.text(-displim/2-displim*0.1, nymax*1.1, 'Original Image', fontsize=10, color='r')
    # print (" display Y lim max", nymax*1.2)
    # divider = make_axes_locatable(ax)
    # cax = divider.append_axes("right", size="1%", pad=0.1)
    # cbar = plt.colorbar(points, cax)
    cbar = plt.colorbar(points)
    cbar.ax.tick_params(labelsize=5)

    plt.savefig(savefile+"-Footshape_Original_Belt.png", dpi=dpi)
    plt.clf()

def contPress(px, py, pv, vmin=50000,  displim=0.15, savefile=None, dpi=300):
    yRange=0.001
    ix1 = np.where(py>-yRange)[0]
    ix2 = np.where(py< yRange)[0]
    ix = np.intersect1d(ix1, ix2)
    dx=px[ix]; dv=pv[ix]

    pos = -displim
    step = 1e-3 
    cp=[]
    
    while pos <=displim: 
        ix1 = np.where(dx>=pos     )[0]
        ix2 = np.where(dx<=pos+step)[0]
        ix = np.intersect1d(ix1, ix2) 
        if len(ix): 
            tv = dv[ix]
            vmax = np.max(tv)/10**6  ## unit : MPa
            cp.append([pos, vmax])
        else: 
            cp.append([pos, 0.0])
        pos+= step
    cp = np.array(cp)

    if savefile: 
        plt.plot(cp[:,0], cp[:,1], c='blue', lw=1.0)
        pMax = np.max(cp[:,1])
        ix = np.where(cp[:,1]==pMax)[0][0]
        maxValue = cp[ix]
        txt = "Max: %.3fMPa at %.3f(m)"%(maxValue[1], maxValue[0])

        minX = 0.0 
        txtPosition = [minX, maxValue[1]*1.05]
        if maxValue[0] < 0:     txtAlign = 'left'
        else: txtAlign = 'right'
        plt.annotate(txt, xy=(maxValue[0], maxValue[1]), xytext=(txtPosition[0], txtPosition[1]), \
            fontsize=10, arrowprops=dict(facecolor='black', shrink=0.05, width=1.0, headwidth=5), ha=txtAlign)

        plt.title("Contact Pressure Distribution", size=14)
        plt.ylabel("Contact Pressure(MPa)", size=10)
        plt.xlabel("Lateral Position(m)", size=10)
        plt.xticks(size=9)
        plt.yticks(size=9)

        plt.grid(True)
        plt.rc('grid', linestyle="--", color='black', linewidth=0.2)
        plt.xlim(-displim, displim)
        plt.ylim(0, maxValue[1]*1.1)
        plt.savefig(savefile+"-CpressGraph.png",dpi=dpi)
        plt.clf()

    fp = open("CpressAlongCenter.txt", "w")
    for p in cp: 
        fp.write("'%3.7f\t%3.7f\t%3.7f\n"%(0.0, p[0], p[1]*10**6))
    fp.close()
    return cp 

def Cropping_footprint_dots(ptx=None, pty=None, ptv=None, xrange=None, yrange=None): 

    if xrange: 
        ix1 = np.where(ptx>=xrange[0])[0]
        ix2 = np.where(ptx<=xrange[1])[0]
        ix  = np.intersect1d(ix1, ix2) 
    if yrange: 
        iy1 = np.where(pty>=yrange[0])[0]
        iy2 = np.where(pty<=yrange[1])[0]
        iy  = np.intersect1d(iy1, iy2) 
    if xrange and yrange: 
        idx = np.intersect1d(ix, iy)
    elif xrange: 
        idx = ix 
    elif yrange: 
        idx = iy 
    else: 
        return ptx, pty, ptv 
    return ptx[idx], pty[idx], ptv[idx]

def contactLength(PointsUp, PointsDown, maxes, position=50, half=False): 
    
    maxwidth = maxes[0]-maxes[1]
    maxlength = maxes[2]-maxes[3]
    halfWidth = maxwidth/2.0 

    mid = (maxes[0]+maxes[1])/2.0 
    cloeset = maxes[0] 

    uppoint  =0.0

    positions=[position]
    for lpos in positions: 
        specificposition   = -halfWidth + lpos *  maxwidth / 100 
        sclose = 10**7
        spoint1 = 0.0
        for pt in PointsUp:
            if abs(mid - pt[0]) < cloeset : 
                cloeset = abs(mid-pt[0])
                uppoint = pt[1]
            if abs(specificposition-pt[0]) < sclose: 
                sclose = abs(specificposition-pt[0])
                spoint1 = pt[1]

        cloeset = maxes[0] 
        sclose = 10**7
        downpoint  =0.0
        spoint2 = 0.0
        for pt in PointsDown:
            if abs(mid - pt[0]) < cloeset : 
                cloeset = abs(mid-pt[0])
                downpoint = pt[1]
            if abs(specificposition-pt[0]) < sclose: 
                sclose = abs(specificposition-pt[0])
                spoint2 = pt[1]

        centerlength = uppoint - downpoint 
        slength = spoint1 - spoint2
        lx = specificposition
        ly1 = spoint1
        ly2 = spoint2
        if half == 'up': 
            return spoint1
        elif half == 'down': 
            return -spoint2
        else: 
            return slength 

def contactWidth(PointsPos, PointsNeg, maxes, position=50): 
    maxwidth = maxes[0]-maxes[1]
    maxlength = maxes[2]-maxes[3]

    mid = (maxes[0]+maxes[1])/2.0 
    cloeset = maxes[0] 

    pointsX2 = np.append( PointsPos[:, 0], PointsNeg[:, 0])
    pointsY2 = np.append( PointsPos[:, 1], PointsNeg[:, 1])

    uppoint  =0.0
    positions=[position]
    for wpos in positions:
        mid = (maxes[2]+maxes[3])/2.0 
        specificposition = maxes[2] - maxlength * wpos / 100.0
        sclose = maxes[2]
        spoint1 = 0.0
        for pt in PointsPos:
            if abs(specificposition-pt[1]) < sclose: 
                sclose = abs(specificposition-pt[1])
                spoint1 = pt[0]

        sclose = maxes[2]
        spoint2 = 0.0
        for pt in PointsNeg:
            if abs(specificposition-pt[1]) < sclose: 
                sclose = abs(specificposition-pt[1])
                spoint2 = pt[0]

        return spoint1 - spoint2
    
def FPC(px, py, pv, cp=None, savefile="", displim=0.15, fitting=6,\
     cmap='rainbow', vmin=50000, vmax=100000, dpi=300, ActualArea=0.0,\
          ProductLine='PCR', contactForce=0, comparing=False): 

    yRange=0.001
    ix1 = np.where(py>-yRange)[0]
    ix2 = np.where(py< yRange)[0]
    ix = np.intersect1d(ix1, ix2)
    dx=px[ix]; dv=pv[ix]

    xMinCnt = np.min(dx)
    xMaxCnt = np.max(dx)
    Center_ContactWidth = xMaxCnt - xMinCnt 

    xMin = np.min(px)
    xMax = np.max(px)
    Max_ContactWidth = xMax - xMin 

    ix = np.where(py>0)[0]
    upX = px[ix]; upY = py[ix]; upP = pv[ix]
    ix = np.where(py<0)[0]
    downX = px[ix]; downY = py[ix]; downP = pv[ix]

    maxY = np.max(upY)
    minY = np.min(downY)
    Max_ContactLength = maxY - minY 

    xRange = 0.5e-3   
    step = 0.5e-3
    while xRange < 30E-3: 
        ix1 = np.where(px>-xRange)[0]
        ix2 = np.where(px< xRange)[0]
        ix = np.intersect1d(ix1, ix2)
        if len(ix) > 1000: 
            cLine = py[ix]
            yMax = np.max(cLine)
            yMin = np.min(cLine)
            Center_ContactLength = yMax - yMin 
            break 
        xRange += step 

    fittingmargin = 0.001 
    fittingmargin_gap=fittingmargin/100.0
    point_gap = 3.0e-3

    fpcX, fpcY, fpcV = Cropping_footprint_dots(ptx=px, pty=py, ptv=pv, xrange=[xMinCnt*1.2, xMaxCnt*1.2])
    if comparing: return fpcX, fpcY

    PointsUp, PointsDown, PointsPos, PointsNeg, maxes =\
         SearchPoints(fpcX, fpcY, fitting=fitting, fittingmargin=fittingmargin, dist=point_gap, savefig=False, delete='max')

    pointsX2 = np.append( PointsUp[:, 0], PointsDown[:, 0])
    pointsY2 = np.append( PointsUp[:, 1], PointsDown[:, 1])

    # plt.scatter(px, py)
    savefig = False 
    if savefig: 
        plt.scatter(pointsX2, pointsY2, edgecolors=None, linewidths=0.0, s=0.5, c='gray')
        
    
    # xMaxC - xMinC 
    if abs(xMaxCnt) < abs(xMinCnt): 
        maxes[0] = xMaxCnt 
        maxes[1] = -xMaxCnt 
        halfWidth = abs(xMaxCnt)
    else: 
        maxes[0] = -xMinCnt 
        maxes[1] = xMinCnt 
        halfWidth = abs(xMinCnt)
    maxes[2] = maxY
    maxes[3] = minY 

    maxwidth = maxes[0]-maxes[1]
    maxlength = maxes[2]-maxes[3]

    print ("* Max Length=%.1f, Width=%.1f"%(maxlength*1000, maxwidth*1000))
    
    mid = (maxes[0]+maxes[1])/2.0 
    cloeset = maxes[0] 

    pointsX1 = np.append( PointsUp[:, 0], PointsDown[:, 0])
    pointsY1 = np.append( PointsUp[:, 1], PointsDown[:, 1])

    pointsX2 = np.append( PointsPos[:, 0], PointsNeg[:, 0])
    pointsY2 = np.append( PointsPos[:, 1], PointsNeg[:, 1])

    if savefig:
        plt.scatter(pointsX1, pointsY1, edgecolors=None, linewidths=0.0, s=0.3, c='black')
        plt.scatter(pointsX2, pointsY2, edgecolors=None, linewidths=0.0, s=0.3, c='pink')
        plt.savefig("FPC_Length_width.png")
        plt.clf()

    uppoint  =0.0

    # positions=[15, 25, 50, 75, 85, 5, 10, 20, 30, 35, 40, 45, 55, 60, 65, 70, 80, 90, 95, 0, 100]
    positions = range(0, 105, 5)
    Lengths=[]

    lines = []
    
    poscounting = 0 
    maxLength = 0 
    for lpos in positions: 
        poscounting += 1 
        specificposition   = -halfWidth + lpos *  maxwidth / 100 
        sclose = 10**7
        spoint1 = 0.0
        for pt in PointsUp:
            if abs(mid - pt[0]) < cloeset : 
                cloeset = abs(mid-pt[0])
                uppoint = pt[1]
            if abs(specificposition-pt[0]) < sclose: 
                sclose = abs(specificposition-pt[0])
                spoint1 = pt[1]

        cloeset = maxes[0] 
        sclose = 10**7
        downpoint  =0.0
        spoint2 = 0.0
        for pt in PointsDown:
            if abs(mid - pt[0]) < cloeset : 
                cloeset = abs(mid-pt[0])
                downpoint = pt[1]
            if abs(specificposition-pt[0]) < sclose: 
                sclose = abs(specificposition-pt[0])
                spoint2 = pt[1]

        centerlength = uppoint - downpoint 
        slength = spoint1 - spoint2
        lx = specificposition
        ly1 = spoint1
        ly2 = spoint2
        if True: 
            lengthX=[]; lengthY=[]
            lengthX.append(lx); lengthY.append(ly1)
            lengthX.append(lx); lengthY.append(ly2)
            # plt.plot(lengthX, lengthY, color='darkgreen', lw=0.5)
            # plt.text(lx, ly2-0.01, "L%.1f"%(slength*1000), size=5)

            lines.append([lengthX, lengthY, [lx, ly2-0.01, "L%.1f"%(slength*1000)] ])
            
            Lengths.append(slength*1000)
        if maxLength < slength: 
            maxLength = slength 
        print ("    POS %.1f%%, length=%.2f"%(lpos, slength*1000))
        
        ## if contour == True: 
        mid = (maxes[2]+maxes[3])/2.0 
        specificposition = maxes[2] - maxlength * 0.5
        sclose = maxes[2]
        spoint1 = 0.0
        for pt in PointsPos:
            if abs(specificposition-pt[1]) < sclose: 
                sclose = abs(specificposition-pt[1])
                spoint1 = pt[0]

        sclose = maxes[2]
        spoint2 = 0.0
        for pt in PointsNeg:
            if abs(specificposition-pt[1]) < sclose: 
                sclose = abs(specificposition-pt[1])
                spoint2 = pt[0]


        centerwidth = spoint1 - spoint2

    print (" >> Max Length=%.1f"%(maxLength*1000))
    maxlength = maxLength 
    ### width at specific position 
    Widths=[]
    posPositions=[]; negPositions=[]
    poscounting = 0 
    maxWidth = 0 
    for wpos in positions:
        poscounting += 1
        mid = (maxes[2]+maxes[3])/2.0 
        specificposition = maxes[2] - maxlength * wpos / 100.0
        sclose = maxes[2]
        spoint1 = 0.0
        for pt in PointsPos:
            if abs(specificposition-pt[1]) < sclose: 
                sclose = abs(specificposition-pt[1])
                spoint1 = pt[0]

        sclose = maxes[2]
        spoint2 = 0.0
        for pt in PointsNeg:
            if abs(specificposition-pt[1]) < sclose: 
                sclose = abs(specificposition-pt[1])
                spoint2 = pt[0]

        swidth = spoint1 - spoint2

        posPositions.append([spoint1, specificposition])
        negPositions.append([spoint2, specificposition])

        ly = specificposition
        lx1 = spoint1
        lx2 = spoint2
        if True: 
            lengthX=[]; lengthY=[]
            lengthX.append(lx1); lengthY.append(ly)
            lengthX.append(lx2); lengthY.append(ly)
            # plt.plot(lengthX, lengthY, color='blue', lw=0.5)
            # plt.text(lx1+0.01, ly, "W%.1f"%(swidth*1000), size=5)
            lines.append([lengthX, lengthY, [lx1+0.01, ly, "W%.1f"%(swidth*1000)] ])
            
            Widths.append(swidth*1000)
        if maxWidth < swidth: 
            maxWidth = swidth 
        print ("    POS %.1f%%, Width=%.2f"%(wpos, swidth*1000))
    print (" >> Max Width=%.1f"%(maxWidth*1000))
    Max_ContactWidth = maxWidth
    updown_points_Calculation_margin = 0.03
    downnode = NODE()
    cnt =1
    for nd in PointsDown:
        # print ("%.2f < %.2f < %.2f"%((maxes[1] + maxwidth * 0.06)*1000, nd[0]*1000, ( maxes[0] - maxwidth * 0.06)*1000))
        # if nd[0] >  maxes[1] + maxwidth * updown_points_Calculation_margin and nd[0] <  maxes[0] - maxwidth * updown_points_Calculation_margin:
            downnode.Add([cnt, 0.0, nd[0], nd[1]])
            cnt+=1
    downnode.Sort(item=2, reverse=False)

    upnode = NODE()
    for nd in PointsUp:
        # if nd[0] >  maxes[1] + maxwidth * updown_points_Calculation_margin and nd[0] <  maxes[0] - maxwidth * updown_points_Calculation_margin:
            upnode.Add([cnt, 0.0, nd[0], nd[1]])
            cnt+=1
    upnode.Sort(item=2, reverse=True)


    posnode = NODE()
    cnt = 0 
    for pn in posPositions:
        posnode.Add([cnt, 0.0, pn[0], pn[1]])
        cnt+=1

    posnode.Sort(item=3, reverse=False)
    negnodeUp = NODE()
    negnodeDown = NODE()
    cnt = 100 
    for pn in negPositions:
        if pn[1]>0: 
            negnodeUp.Add([cnt, 0.0, pn[0], pn[1]])
        else: 
            negnodeDown.Add([cnt, 0.0, pn[0], pn[1]])
        cnt+=1
    negnodeUp.Sort(item=3, reverse=True)
    negnodeDown.Sort(item=3, reverse=True)


    areanode = NODE()
    areanode.Combine(downnode)
    areanode.Combine(posnode)
    areanode.Node = Delete_Close_Points(areanode.Node, point_gap, backward=False )
    areanode.Combine(upnode)
    areanode.Node = Delete_Close_Points(areanode.Node, point_gap, backward=True )
    areanode.Combine(negnodeUp)
    areanode.Node = Delete_Close_Points(areanode.Node, point_gap, backward=False )
    areanode.Combine(negnodeDown)
    areanode.Node = Delete_Close_Points(areanode.Node, point_gap, backward=True )

    if savefig: 
        unNx=[];unNy=[]
        for nd in areanode.Node: 
            unNx.append(nd[2])
            unNy.append(nd[3])
    
    i = 1 
    PL=0 
    while i < len(areanode.Node)-1:
        L1 = math.sqrt((areanode.Node[i][2] - areanode.Node[i-1][2])**2  + (areanode.Node[i][3] - areanode.Node[i-1][3])**2)
        L2 = math.sqrt((areanode.Node[i][2] - areanode.Node[i+1][2])**2  + (areanode.Node[i][3] - areanode.Node[i+1][3])**2)
        
        if i>2 and L1 > PL * 2 and L1 > point_gap*2 and L2 > point_gap*2: 
            # print ("** del", areanode.Node[i])
            del(areanode.Node[i]) 
            # continue 
        PL = L1 
        i += 1

    upx = []; upy=[]
    dwx = []; dwy=[]
    for nd in areanode.Node: 
        if nd[3] >= 0: 
            upx.append(nd[2])
            upy.append(nd[3])
        elif nd[3] < 0: 
            dwx.append(nd[2])
            dwy.append(nd[3])
    deletedx=[]; deletedy=[]

    unsortedNode=[]
    i = 1
    while i < len(upx): 
        cangle = Angle_Between_Vectors([0, 0, 1, 0], [0, 0, upx[i], upy[i]])
        # print ("** Angle %.2f"%(math.degrees(cangle)) )
        if i > 2: 
            if cangle <pangle or abs(cangle - pangle) > 0.2 : 
                deletedx.append(upx[i]); deletedy.append(upy[i])
                upx = np.delete(upx, i)
                upy = np.delete(upy, i)
                # print ("             deleted")
                continue
        unsortedNode.append([cangle, upx[i], upy[i]])
        pangle = cangle  
        

        i += 1 
    # print ("************************* ")
    i = 1
    while i < len(dwx): 
        cangle = Angle_Between_Vectors([0, 0, -1, 0], [0, 0, dwx[i], dwy[i]])
        # print ("* Angle %.2f"%(math.degrees(cangle)))
        if i > 2: 
            if math.degrees(cangle) < 30.0 and math.degrees(pangle) > 150: 
                pangle = 0 
            if cangle < pangle or abs(cangle - pangle) > 0.2: 
                deletedx.append(dwx[i]); deletedy.append(dwy[i])
                dwx = np.delete(dwx, i)
                dwy = np.delete(dwy, i)
                # print ("             deleted")
                continue
        pangle = cangle  
        unsortedNode.append([cangle+math.pi, dwx[i], dwy[i]])

        i += 1 

    sortedNode = Sorting(unsortedNode)

    nlist = []
    totalareapointx=[]
    totalareapointy=[]
    for n in sortedNode: 
        # print (" Angle %f"%(n[0]))
        totalareapointx.append(n[1])
        totalareapointy.append(n[2])

    totalarea = Area(totalareapointx, totalareapointy)
    print ("** Total Area = %.2f"%(totalarea*10000))
    
    
    if savefig:  

        size = 0.3

        plt.axis('equal')
        plt.xlabel("Lateral Position(m)", size=11)
        plt.ylabel("Longitudinal Position(m)", size=11)
        plt.xticks(size=10)
        plt.yticks(size=10)
        plt.title("Contact Pressure(Pa) Distribution", size=14)
        plt.text(-displim + displim*0.1 , displim - displim*0.15, 'Original Image', fontsize=10, color='r')
        plt.xlim(-displim, displim)
        plt.ylim(-displim, displim)
        points = plt.scatter(px, py, c=pv, s=size, cmap=cmap, vmin=vmin, vmax=vmin*10, edgecolors=None, linewidths=0.0 )
        cbar = plt.colorbar(points)
        cbar.ax.tick_params(labelsize='small')
        # cbar.set_label("", size=8)
        
        # plt.scatter(totalareapointx, totalareapointy, c='black', s=size*10, edgecolors=None, linewidths=0 )
        plt.plot(totalareapointx, totalareapointy, color='black', marker='o', lw=0.5, markersize=1, linestyle="-")
        
        plt.savefig(savefile+"-FittingCurve.png", dpi=dpi)
        plt.clf()


        plt.scatter(unNx, unNy, color='black', s=1)
        plt.scatter(totalareapointx, totalareapointy, color='red', s=0.5)
        plt.scatter(deletedx, deletedy, color='blue', s=0.5, marker='+')
        plt.savefig("AreaDots.png")

    # if maxlength < Lengths[2]/1000:  maxlength  = Lengths[2]/1000
    # if Max_ContactWidth < Widths[2]/1000:  Max_ContactWidth  = Widths[2]/1000
    if savefig: 
        fp = open(savefile+"-FPC_Original.txt", 'w')
        
        if ProductLine == 'TBR': 
            fp.write("ContactLength(mm) max/center/15%%/85%%=\t%5.1f/%5.1f/%5.1f/%5.1f\n"%(maxlength*1000, Lengths[2], Lengths[0], Lengths[4]))
            fp.write("ContactWidth(mm)  max/center/25%%/75%%=\t%5.1f/%5.1f/%5.1f/%5.1f\n"%(Max_ContactWidth*1000, Widths[2], Widths[0], Widths[4]))
            fp.write("SquareRatio(%%)=\t%.1f\n"%((Lengths[0]+Lengths[4])/Lengths[2]*50))
        else: 
            fp.write("ContactLength(mm) max/center/25%%/75%%=\t%5.1f/%5.1f/%5.1f/%5.1f\n"%(maxlength*1000, Lengths[2], Lengths[1], Lengths[3]))
            fp.write("ContactWidth(mm)  max/center/25%%/75%%=\t%5.1f/%5.1f/%5.1f/%5.1f\n"%(Max_ContactWidth*1000, Widths[2], Widths[1], Widths[3]))
            fp.write("SquareRatio(%%)=\t%.1f\n"%((Lengths[1]+Lengths[3])/Lengths[2]*50))
        fp.write("ContactRatio(%%)=\t%.1f\n"%(ActualArea/totalarea*100))
        roundness = (totalarea)/(maxlength*Max_ContactWidth)
        fp.write("Roundness(%%)=\t%.1f\n"%(roundness*100))
        fp.write("ActualContactArea(cm^2)=\t%.1f\n"%(ActualArea*10000))
        fp.write("TotalContactArea(cm^2)=\t%.1f\n"%(totalarea*10000))
        fp.write("DetailedContactLength(mm) 15/25/50/75/85=\t%.1f/%.1f/%.1f/%.1f/%.1f\n"%(Lengths[0], Lengths[1], Lengths[2], Lengths[3], Lengths[4]))
        fp.write("DetailedContactWidth(mm) 15/25/50/75/85=\t%.1f/%.1f/%.1f/%.1f/%.1f\n"%(Widths[0], Widths[1], Widths[2], Widths[3], Widths[4]))

        AvgContactPress = contactForce/ActualArea
        fp.write("\nFrom\tTo\tContact Length(mm)\tActual Contact Area(cm^2)\tContact Pressure(pa)\tContact Force(N)\n")
        fp.write("%.2f\t%.2f\t%.4f\t%.4f\t%.4f\n"%(xMax*1000, xMin*1000, ActualArea*10000, AvgContactPress, contactForce))


        fp.write('\nIn-OutContactLength=\t0.0\n') ## for Wear Sensitivity simulation 

    Roundness = (totalarea)/(maxlength*Max_ContactWidth)
    contactRatio = ActualArea/totalarea*100
    if ActualArea : 
        AvgContactPress = contactForce/ActualArea
    else: 
        AvgContactPress = 0 
    

    # ActualArea 

    cwd = getcwd()
    if savefig:  
        rpt = glob.glob(cwd+"/REPORT/frc*.rpt")[0]

        with open(rpt) as IN: 
            lines = IN.readlines()
        for line in lines: 
            if "FY_AVE" in line:
                wd = line.split(":")
                FY = wd[1]
            if "FZ_AVE" in line:
                wd = line.split(":")
                FZ = wd[1]
        fp.write("\nReaction Force!\n")
        fp.write("Fy(Lateraldir.,N)=%s\n"%(FY.strip()))
        fp.write("Fz(Verticaldir.,N)=%s\n\n"%(FZ.strip()))


    positions=[75, 77.5, 80, 82.5, 85, 87.5, 90, 92.5, 95, 97.5]
    FootPrintRatio=[]
    print ("** Contact Ratio from 75%~97.5%")
    for pos in positions: 
        length1 = contactLength(PointsUp, PointsDown, maxes, position=pos)
        pos_opp = 100 -pos
        length2 = contactLength(PointsUp, PointsDown, maxes, position=pos_opp)
        length = (length1+length2)/2
        FootPrintRatio.append(length/maxlength)
        print ("    position %d%%, Length=%.2f Footprint ratio=%.2f"%(pos, length*1000, length/maxlength))

    if savefig: 
        fp.write("Footprint Ratios - (50%% - 95%% in 5%% increments)=\t%5.1f/%5.1f/%5.1f/%5.1f/%5.1f/%5.1f/%5.1f/%5.1f/%5.1f/%5.1f\n"%(FootPrintRatio[0]*100, \
            FootPrintRatio[1]*100, FootPrintRatio[2]*100, FootPrintRatio[3]*100, FootPrintRatio[4]*100, FootPrintRatio[5]*100, FootPrintRatio[6]*100, FootPrintRatio[7]*100, \
                FootPrintRatio[8]*100, FootPrintRatio[9]*100))

    del(FootPrintRatio[-1])
    Gullwing_ShapeFactor = 1 - max(FootPrintRatio) 
    print ("** GullWing Shape Factor = %.3f"%(Gullwing_ShapeFactor))

    ## Gullwing Local Shape Factor : ave. slope of Shoulder Rib Leading Edge 
    length_Up=[]
    for pos in positions: 
        length_Up.append(contactLength(PointsUp, PointsDown, maxes, position=pos, half='up'))
    delW = Center_ContactWidth  * 0.025
    slopes=[]
    for i, lg in enumerate(length_Up): 
        if i ==0: 
            plg = lg 
            continue 
        slopes.append((-lg+plg)/delW)
        plg = lg 
    Gullwing_localShapeFactor = np.average(np.array(slopes))
    print ("** GullWing Local Shape Factor = %.3f"%(Gullwing_localShapeFactor))
    ## suppose 
    ## Center_ContactWidth 


    ## Roundness shape factor 
    ## 2nd-order Polynominal fit for center 50% of footprint 
    ## Roundness = Coef of 2nd-order term 
    fpcX, fpcY, fpcV = Cropping_footprint_dots(ptx=px, pty=py, ptv=pv, xrange=[xMinCnt*0.5, xMaxCnt*0.5])
    fitting = 2 
    PointsUp, PointsDown, PointsPos, PointsNeg, _, coefs =\
         SearchPoints(fpcX, fpcY, fitting=fitting, fittingmargin=fittingmargin, coef=True, savefig=False)
    RoundnessShapeFactor = coefs[0][0]   
    print ("** Roundness Shape Factor=%.3f"%(RoundnessShapeFactor))

    Squareness_ShapeFactor = maxlength / Max_ContactWidth
    print ("** Squareness Shape Factor=%.3f"%(Squareness_ShapeFactor))
    Coef_variation_cPress = None 
    if not isinstance(cp, type(None)): 
        idx = np.where(cp[:,1]>0)[0]
        pres = cp[idx]
        avgPres = np.average(pres[:,1])
        stdPres = np.std(pres[:,1])
        Coef_variation_cPress = stdPres / avgPres 
        print ('** Coef. Of Variation of CPress=%.3f'%(Coef_variation_cPress))
        print ("   - Avg=%.2f, Std=%.2f"%(avgPres, stdPres ))

    areapoints=[totalareapointx, totalareapointy]
    basicFPC = [Lengths, Widths, ActualArea, totalarea, Roundness, contactRatio, AvgContactPress]
    advFPC = [Gullwing_ShapeFactor, Gullwing_localShapeFactor, RoundnessShapeFactor, Squareness_ShapeFactor, Coef_variation_cPress]

    return areapoints, basicFPC, advFPC, lines 
# areapoints=[totalareapointx, totalareapointy]
# basicFPC = [Lengths, Widths, ActualArea, totalarea, Roundness, contactRatio, AvgContactPress]
# advFPC = [Gullwing_ShapeFactor, Gullwing_localShapeFactor, RoundnessShapeFactor, Squareness_ShapeFactor, Coef_variation_cPress]

    if savefig: 
        fp.write('Gullwing Global Shape Factor=%6.3f\n' % Gullwing_ShapeFactor)
        fp.write('Gullwing Local Shape Factor=%6.3f\n' % Gullwing_localShapeFactor )
        fp.write('Roundness Shape Factor=%6.3f\n' % RoundnessShapeFactor)
        fp.write('Squareness Shape Factor=%6.3f\n' % Squareness_ShapeFactor)
        fp.write('Coef. Of Variation of CPress=%5.2f\n' % Coef_variation_cPress)
            
        fp.write("\n\nSuccess::Post::[Simulation Result] This simulation result was created successfully!!\n")
        fp.close()

        with open(savefile+"-FPC_Original.txt") as FP: 
            lines = FP.readlines()

        fp = open(savefile+"-FPC.txt", 'w')
        for line in lines: 
            fp.write(line)
        fp.close()

        ############################################################################
        fpATC = open(savefile+"-FPC-Detail.txt", 'w')
        fpATC.writelines('---------RIB-BY-RIB ANALYSIS---------\n')
        fpATC.writelines('# of Ribs Detected = 0\t(Pattern Tire)\n')
        fpATC.writelines('\n')
        fpATC.writelines('Average Pressures (pa/psi)\n')
        fpATC.writelines("\t%.2f\t/   %.3f\n"%(AvgContactPress, AvgContactPress*0.000145038))

        fpATC.writelines('Max Contact Length of each Rib (mm/in)\n')
        fpATC.writelines("\t%.2f\t/   %.3f\n"%(maxlength*1000, maxlength*39.3701))
        fpATC.writelines('Actual / Total Contact Area (cm^2/in^2)\n')
        fpATC.writelines("\t%.2f\t%.2f\t/   %.3f\t%.3f\n"%(ActualArea*10000, totalarea*10000, ActualArea*1550, totalarea*1550))
        fpATC.writelines('Contact Force (N/lbs)\n')
        fpATC.writelines("\t%.2f\t/   %.3f\n"%(contactForce, contactForce*0.224809))
        fpATC.writelines('\n')

        fpATC.writelines('Gullwing Global Shape Factor =%6.3f\n' % Gullwing_ShapeFactor)
        fpATC.writelines('Gullwing Local Shape Factor	=%6.3f\n' % Gullwing_localShapeFactor)
        fpATC.writelines('Roundness Shape Factor		=%6.3f\n' % RoundnessShapeFactor)
        fpATC.writelines('Squareness Shape Factor		=%6.3f\n' % Squareness_ShapeFactor)
        fpATC.writelines('Coef. Of Variation of CPress =%6.2f\n' % Coef_variation_cPress)
        fpATC.writelines('\n')
        fpATC.writelines('Success::Post::[Simulation Result] This simulation result was created successfully!!\n')
        fpATC.close()
    ############################################################################

def Filtering_Up_Down_points(pointsX, pointsY, mht=5e-3): 
    i= 2 
    mht = 5e-3
    while i < len(pointsX)-2: 
        dy1 = 100.0; dy2 = 100.0
        if abs(pointsX[i] - pointsX[i-1]) :#<= dist*2: 
            dy1 = abs(pointsY[i] - pointsY[i-1])
        if abs(pointsX[i+1] - pointsX[i]) :#<= dist*2: 
            dy2 = abs(pointsY[i+1] - pointsY[i])
        # pslp =abs((pointsY[i-1]-pointsY[i-2])/(pointsX[i-1]-pointsX[i-2]))
        cslp =abs((pointsY[i]-pointsY[i-1])/(pointsX[i]-pointsX[i-1]))
        nslp =abs((pointsY[i+1]-pointsY[i])/(pointsX[i+1]-pointsX[i-1]))

        if abs((nslp-cslp)/cslp) > 1.0 or dy1 <100 or dy2 <100: 
            if dy1 <100 and dy2 <100: 
                
                if dy1 > mht and dy2 > mht : 
                    pointsX = np.delete(pointsX, i)
                    pointsY = np.delete(pointsY, i)
                    continue 
            elif dy1 ==100: 
                if dy2 > mht: 
                    pointsX = np.delete(pointsX, i+1)
                    pointsY = np.delete(pointsY, i+1)
                    i += 1 
                    continue 
            elif dy2 ==100: 
                if dy1 > mht: 
                    pointsX = np.delete(pointsX, i-1)
                    pointsY = np.delete(pointsY, i-1)
                    continue 

        i += 1 
    return pointsX, pointsY 


def searchbounarypoints(px=[], py=[], pxy=[], pos="updown", dist=5.0E-3, ix=0, iy=1):
    try:
        if pos =="updown": 
            px = np.array(px); py=np.array(py)
        else:
            pt = np.array(py); py=np.array(px)
            px = pt 
    except: 
        pxy = np.array(pxy)
        if pos =="updown": 
            px = pxy[:,ix]
            py = pxy[:,iy]
        else:
            px = pxy[:,iy]
            py = pxy[:,ix]


    HighValulePoint=[]
    LowValuePoint = []
    vmax = px.max()
    vmin = px.min()
    len = abs(vmax-vmin)

    pN = px.size

    N = int(len/dist)+1
    
    position = vmin
    for i in range(N): 
        cnt = 0 
        ymax =0; ymin = 0
        id1 = np.where(px>=position)[0]
        id2 = np.where(px<position+dist)[0]
        id = np.intersect1d(id1, id2)
        tpy = py[id]
        ymax = tpy.max()
        ymin = tpy.min()
        cnt = len(tpy)

        if cnt > 3: 
            if pos =="updown": 
                HighValulePoint.append([position, ymax])
                LowValuePoint.append([position, ymin])
            else: 
                HighValulePoint.append([ymax, position])
                LowValuePoint.append([ymin, position])
                
        position += dist 

    return HighValulePoint, LowValuePoint, N

def SearchPoints(px=[], py=[], dist=5.0E-03, fitting=6, fittingmargin=0.001, \
    coef=False, savefig=False, delete='max', nofitting=False ): 
    # print ("no for search", len(px))
    print ("** Curve Fitting Order=%d"%(fitting))
    case=0 ## case 0 is more faster 

    marginoferr =fittingmargin  # 1mm 
    margin_gap = fittingmargin / 1000.0 # 0.001mm
    removedotstoabsolute = 1E-03  #3E-3 
    # debug =1
    xmax = px.max()
    xmin = px.min()
    ymax = py.max()
    ymin = py.min()

    pN = len(px)
    LengthPointUp=[]
    LengthPointDown=[]
    WidthPositionPos=[]
    WidthPositionNeg=[]

    ################################################################
    if nofitting : dist = 1.0e-3
    xmid = (xmax + xmin) / 2.0
    xlen = abs(xmax-xmid)
    N = int(xlen/dist) + 1
    uN = N 
    # if debug == 1: print (N, "x mid ", xmid)
    position = xmid
    subN  = 3
    dd = dist/subN 
    for i in range(N): 
        cnt = 0 
        yx =0; ym = 0
        if case== 0:
            id1 = np.where(px >= position)[0]
            id2 = np.where(px < position + dist)[0]
            ids = np.intersect1d(id1, id2)
            # print (len(id1), len(id2), ids)
            tpy = py[ids]; tpx = px[ids]
            if len(ids)>0: 
                ix = np.where(tpy>0)[0];    uy = tpy[ix];  subX = tpx[ix]
                tp = position 
                subY = []
                for k in range(int(subN)): 
                    id1 = np.where(subX >= tp)[0]
                    id2 = np.where(subX < tp +dd)[0]
                    idn = np.intersect1d(id1, id2)
                    
                    if len(idn): 
                        mx = np.max(uy[idn])
                        subY.append(mx)
                    tp += dd 
                if len(subY): 
                    avgY = np.average(np.array(subY))
                    LengthPointUp.append([position+dist*0.5, avgY])
                elif len(uy): 
                    avgY = np.max(uy)
                    LengthPointUp.append([position+dist*0.5, avgY])

                ix = np.where(tpy<0)[0];    dy = tpy[ix];  subX = tpx[ix]
                tp = position 
                subY = []
                for k in range(int(subN)): 
                    id1 = np.where(subX >= tp)[0]
                    id2 = np.where(subX < tp +dd)[0]
                    idn = np.intersect1d(id1, id2)
                    if len(idn): 
                        subY.append(np.min(dy[idn]))
                    tp += dd 
                if len(subY): 
                    avgY = np.average(np.array(subY))
                    LengthPointDown.append([position+dist*0.5, avgY])
                elif len(dy): 
                    avgY = np.min(dy)
                    LengthPointDown.append([position+dist*0.5, avgY])
            position += dist 

    xlen = abs(xmid-xmin)
    N = int(xlen/dist) + 1
    dN = N
    # if debug == 1: print (N)
    position = xmid
    for i in range(N): 
        cnt = 0 
        yx =0; ym = 0#; yxx = 0; ymx = 0
        if case ==0: 
            id1 = np.where(px < position)[0]
            id2 = np.where(px >= position - dist)[0]
            ids = np.intersect1d(id1, id2)
            tpy = py[ids]; tpx = px[ids]
            if len(ids)>0:
                ix = np.where(tpy > 0)[0];    uy = tpy[ix];  subX = tpx[ix]
                tp = position 
                subY = []
                for k in range(int(subN)): 
                    id1 = np.where(subX < tp)[0]
                    id2 = np.where(subX >= tp -dd)[0]
                    idn = np.intersect1d(id1, id2)
                    if len(idn): 
                        subY.append(np.max(uy[idn]))
                    tp -= dd 
                if len(subY): 
                    avgY = np.average(np.array(subY))
                    LengthPointUp.append([position-dist*0.5, avgY])
                elif len(dy): 
                    avgY = np.max(dy)
                    LengthPointUp.append([position-dist*0.5, avgY])

                ix = np.where(tpy<0)[0];    dy = tpy[ix];  subX = tpx[ix]
                tp = position 
                subY = []
                for k in range(int(subN)): 
                    id1 = np.where(subX < tp)[0]
                    id2 = np.where(subX >= tp -dd)[0]
                    idn = np.intersect1d(id1, id2)
                    if len(idn): 
                        subY.append(np.min(dy[idn]))
                    tp -= dd 
                if len(subY): 
                    avgY = np.average(np.array(subY))
                    LengthPointDown.append([position-dist*0.5, avgY])
                elif len(dy): 
                    avgY = np.min(dy)
                    LengthPointDown.append([position-dist*0.5, avgY])
            position -= dist
    
    LengthPointUp = Sorting(LengthPointUp)
    p1 = np.array(LengthPointUp)
    pointsX = p1[:, 0]
    pointsY = p1[:, 1]

    if nofitting : 
        rawX = np.array(pointsX); rawY = np.array(pointsY)
        p2 = np.array(LengthPointDown)
        pointsX = p2[:, 0]
        pointsY = p2[:, 1]
        rawX = np.append(rawX, pointsX); rawY = np.append(rawY, pointsY)
        return rawX, rawY

    if savefig: 
        plt.axis('equal')
        plt.scatter(px, py, label="raw", edgecolors=None, linewidths=0.0, color='gray')
        # plt.scatter(pointsX, pointsY)
    

    ################################################################
    ymid = (ymax + ymin) / 2.0
    ylen = abs(ymax-ymid)
    N = int(ylen/dist) + 1
    # if debug == 1: print (N, "y mid ", ymid, "Points=", pN, "dist", dist)
    position = ymid
    for i in range(N): 
        cnt = 0 
        xx =0.0; xm = 0.0#; xxy = 0; xmy = 0
        # if case ==0: 
        id1 = np.where(py >= position)[0]
        id2 = np.where(py < position + dist)[0]
        ids = np.intersect1d(id1, id2)
        tpx = px[ids]
        if len(ids): 
            try: 
                maxarg = np.argmax(tpx)
                minarg = np.argmin(tpx)
                xx = tpx[maxarg]
                xm = tpx[minarg]
                WidthPositionPos.append([xx, position+0.5*dist])
                WidthPositionNeg.append([xm, position+0.5*dist])
            except: 
                pass 
        position += dist 

    ylen = abs(ymid-ymin)
    N = int(ylen/dist) + 1
    # if debug == 1: print (N)
    position = ymid
    for i in range(N): 
        cnt = 0 
        xx =0; xm = 0
        id1 = np.where(py < position)[0]
        id2 = np.where(py > position - dist)[0]
        ids = np.intersect1d(id1, id2)
        tpx = px[ids]
        if len(ids): 
            try: 
                maxarg = np.argmax(tpx)
                minarg = np.argmin(tpx)
                xx = tpx[maxarg]
                xm = tpx[minarg]
                WidthPositionPos.append([xx, position-0.5*dist])
                WidthPositionNeg.append([xm, position-0.5*dist])
            except: 
                pass 
        position -= dist 
    # print ("W Pos", WidthPositionPos)
    # print ("W Neg", WidthPositionNeg)
    ordern = fitting
    WidthPositionPos = Sorting(WidthPositionPos)
    WidthPositionNeg = Sorting(WidthPositionNeg)
    ###################################################
    print ("** Curving Fitting Up points")
    pointsX, pointsY = Filtering_Up_Down_points(pointsX, pointsY, mht=5e-3)
    A, err, err_value = curvefitting(pointsX, pointsY, order=ordern)
    ptx = pointsX
    pty = pointsY
    ermax = err.max()

    cnt = 0
    perr = 0.0
    # print (err_value)
    N = len(pty)
    while abs(perr - err_value) > margin_gap:  
        
        if delete=='max': ermaxindx =  np.argmax(err)
        else: ermaxindx =  np.argmin(err)
        tx = np.delete(ptx, ermaxindx)
        ty = np.delete(pty, ermaxindx )

        perr = err_value
        A, err, err_value = curvefitting(tx, ty, order=ordern)
        ptx = tx
        pty = ty
        cnt += 1
        
        if err_value > perr: break
        if err_value / len(err) <  marginoferr: break
        if cnt > N/2: break
    print ("* Fitting Coefficient: ", A)
    if savefig:
        plt.scatter(pointsX, pointsY, label="points for fitting", edgecolors=None, linewidths=0.0, color='blue')
        plt.scatter(ptx, pty, label="filtered after fitting", edgecolors=None, linewidths=0.0, color='black')
        s = np.min(px)
        widthmax = np.max(px)
        d = 0.01
        ptx = []; pty=[]
        while s < widthmax: 
            yt = 0.0
            for i in range(ordern+1):
                yt += A[i]*pow(s, float(i))
            ptx.append(s)
            pty.append(yt)
            s += d 
        plt.scatter(ptx, pty, label="Fitted points", edgecolors=None, linewidths=0.0, color='red')
        # print ("Final Fitting coefficient", A)
        plt.legend(loc=4)
        plt.xlim(-0.3, 0.3)
        plt.savefig("fitting_dots.png")
        plt.clf()
    # print (f"Up - Fitting Error {round(err_value, 6)} (iter-{cnt-1}, {len(ptx)})") 
    print (" Up - Fitting Error %.6f, (iteration %d, %d)"%(err_value, cnt-1, len(ptx)))
    # print (" Coefficients")
    # print (A)
    if coef: 
        coefs =[A]
    
    # plt.scatter(ptx, pty) 
    p1 =[]
    position = xmid
    # for k in range(uN-1): 
    for k in range(uN-1):
        yt = 0.0
        for i in range(ordern+1):
            yt += A[i]*pow(position, float(i))
        p1.append([position, yt]) 
        position += dist
    position = xmid
    for k in range(dN-1): 
        yt = 0.0
        for i in range(ordern+1):
            yt += A[i]*pow(position, float(i))
        p1.append([position, yt]) 
        position -= dist

    ###################################################
    print ("** Curving Fitting Down points")
    p2 = np.array(LengthPointDown)
    pointsX = p2[:, 0]
    pointsY = p2[:, 1]
    pointsX, pointsY = Filtering_Up_Down_points(pointsX, pointsY, mht=5e-3)
    
    A, err, err_value = curvefitting(pointsX, pointsY, order=ordern)
    ptx = pointsX
    pty = pointsY
    ermax = err.min()

    cnt = 0
    perr = 0.0
    N = len(pty)
    while abs(perr - err_value) > margin_gap:  
        tx = ptx
        ty = pty 
        if delete=='max': erminindx =  np.argmin(err)
        else: erminindx =  np.argmax(err)
        
        tx = np.delete(tx, erminindx)
        ty = np.delete(ty, erminindx)

        perr = err_value
        A, err, err_value = curvefitting(tx, ty, order=ordern)

        ptx = tx
        pty = ty
        cnt += 1
        if err_value > perr: break
        if err_value / len(err) <  marginoferr: break
        if cnt > N/2: break
    # print (f"Down - Fitting Error {round(err_value, 6)} (iter-{cnt-1}, {len(ptx)})") 
    print ("* Fitting Coefficient: ", A)
    print (" Down - Fitting Error %.6f, (iteration %d, %d)"%(err_value, cnt-1, len(ptx)))  
    # print (" Coefficients")
    # print (A)
    if coef: 
        coefs.append(A)
    # plt.scatter(ptx, pty) 
    p2 =[]
    position = xmid
    for k in range(uN-1): 
        yt = 0.0
        for i in range(ordern+1):
            yt += A[i]*pow(position, float(i))
        p2.append([position, yt]) 
        # print ("%f, %f"%(position, yt))
        position += dist
    position = xmid
    for k in range(dN-1): 
        yt = 0.0
        for i in range(ordern+1):
            yt += A[i]*pow(position, float(i))
        p2.append([position, yt]) 
        # print ("%f, %f"%(position, yt))
        position -= dist

    ymax = max(p1[1])
    ymin = min(p2[1]) 
    if coef: 
        return np.array(p1), np.array(p2), np.array(WidthPositionPos), np.array(WidthPositionNeg), [xmax, xmin, ymax, ymin], coefs
    else: 
        return np.array(p1), np.array(p2), np.array(WidthPositionPos), np.array(WidthPositionNeg), [xmax, xmin, ymax, ymin]

def curvefitting(nx=[], ny=[], order=1):

    S = int(order) + 1
    N = len(nx)

    sx = []; sxy =[]
    for i in range(int(S*2)):
        tsx =0.0
        tsy =0.0 
        for j in range(N): 
            tsx += pow(nx[j], float(i))
            if (i<int(S)): tsy += pow(nx[j], float(i)) * ny[j]
        sx.append(tsx)
        if (i<int(S)): sxy.append(tsy)
    matrix = np.zeros((int(S), int(S)))
    for i in range(int(S)):
        for j in range(int(S)):
            matrix[i][j] = sx[i+j]
    try:
        RM = np.linalg.inv(matrix)
        A = np.matmul(RM, sxy)
    except:
        # print(matrix)
        return np.zeros(S), np.zeros(N), 0.0

    err = []
    evalue = 0.0
    for i in range(N): 
        y =0 
        for j in range(int(S)):
            y += A[j] * pow(nx[i], float(j))
        evalue += abs(ny[i]-y)
        err.append(-ny[i]+y)
    if type(evalue) == np.ndarray : 
        evalue = evalue.max()
    return A, np.array(err), evalue

def LayoutMesh_From_axi(axi="", limit=10000, output="" ):
    print (" AXI FILE : %s"%(axi))
    with open(axi) as I: 
        lines = I.readlines()
    fp = open(output, 'w')
    fp.write("**************************************\n")
    fp.write("** TIRE MESH from AXI \n")
    fp.write("**************************************\n")

    SectorNodes = 0;     AllNodes = 0;     Node_Sectors = 0; 
    SectorEls = 0; AllElements = 0; EL_Sectors = 0 

    nodes=[]
    elements=[]
    

    cmd=None 
    for line in lines: 
        if "**" in line  :
            continue 
        if "*" in line: 

            if "*NODE" in line.upper(): 
                cmd ="ND"
                fp.write("*NODE, SYSTEM=R\n")
            elif "*ELEMENT" in line.upper() and "M3D4" in line.upper(): 
                cmd = 'RB'
                fp.write("*ELEMENT, TYPE=MGAX1\n")
            elif "*ELEMENT" in line.upper() and "C3D6" in line.upper(): 
                cmd = 'C6'
                fp.write("*ELEMENT, TYPE=CGAX3H\n")
            elif "*ELEMENT" in line.upper() and "C3D8" in line.upper(): 
                cmd = 'C8'
                fp.write("*ELEMENT, TYPE=CGAX4H\n")
            elif "*ELSET," in line.upper() and "ELSET=" in line.upper(): 
                cmd = 'ES'
                fp.write(line)
            elif "*SURFACE," in line.upper() and "NAME=PRESS" in line.upper(): 
                cmd = 'PS'
                fp.write(line)
            elif "*SURFACE," in line.upper() and "NAME=RIC_R" in line.upper(): 
                cmd = 'PR'
                fp.write(line)
            elif "*SURFACE," in line.upper() and "NAME=RIC_L" in line.upper(): 
                cmd = 'PL'
                fp.write(line)
            elif "*SURFACE," in line.upper() and "NAME=TIREBODY" in line.upper(): 
                cmd = 'BD'
                fp.write(line)
            elif "*SURFACE," in line.upper() and ("NAME=TIE_M" in line.upper() or ("NAME=" in line.upper() and "_TIE" in line.upper())): 
                cmd = 'TM'
                fp.write(line)
            elif "*SURFACE," in line.upper() and ("NAME=TIE_S" in line.upper() or ("NAME=" in line.upper() and "_TIE" in line.upper())):  
                cmd = 'TS'
                fp.write(line)
            elif "*TIE," in line.upper() : 
                cmd = 'TD'
                fp.write(line)
            elif "NIDOFFSET" in line.upper(): 
                cmd = None 
            else: 
                cmd = None 
        else: 

            if cmd=="ND" : 
                data = line.split(",")
                if int(data[0]) < limit: 
                    fp.write("%s, %s, %s, %s\n"%(data[0], data[3].strip(), data[2], data[1]))
                    SectorNodes += 1 
                AllNodes += 1 
                nodes.append([int(data[0].strip()), float(data[1].strip()), float(data[2].strip()), float(data[3].strip())])
            elif cmd =="RB": 
                data = line.split(",")
                if int(data[0]) < limit:
                    fp.write("%s, %s, %s\n"%(data[0], data[1], data[2].strip()))
                    SectorEls+= 1
                AllElements += 1  
                elements.append([int(data[0].strip()), int(data[1].strip()), int(data[2].strip()), int(data[3].strip()), int(data[4].strip()), 0, 0, 0, 0])  
            elif cmd =="C6": 
                data = line.split(",")
                if int(data[0]) < limit:
                    fp.write("%s, %s, %s, %s\n"%(data[0], data[4], data[5].strip(), data[6].strip()))
                    SectorEls+= 1
                AllElements += 1  

                elements.append([int(data[0].strip()), int(data[1].strip()), int(data[2].strip()), int(data[3].strip()), int(data[4].strip()), int(data[5].strip()), int(data[6].strip()), 0, 0])
            elif cmd =="C8": 
                data = line.split(",")
                if int(data[0]) < limit:
                    fp.write("%s, %s, %s, %s, %s\n"%(data[0], data[5], data[6].strip(), data[7].strip(), data[8].strip()))
                    SectorEls+= 1
                AllElements += 1  
                elements.append([int(data[0].strip()), int(data[1].strip()), int(data[2].strip()), int(data[3].strip()), int(data[4].strip()), int(data[5].strip()), int(data[6].strip()), int(data[7].strip()), int(data[8].strip())])
            elif cmd =="ES": 
                data = line.split(",")
                cnt = 0 
                for d in data: 
                    d = d.strip()
                    if d != "": 
                        if int(d) < limit: 
                            cnt += 1
                            fp.write("%s,"%(d))
                if cnt > 0: fp.write("\n")

            elif cmd =="PS": 
                data = line.split(",")
                if int(data[0]) < limit: 
                    if "S3" in data[1]: fp.write("%s, S1\n"%(data[0]))
                    if "S4" in data[1]: fp.write("%s, S2\n"%(data[0]))
                    if "S5" in data[1]: fp.write("%s, S3\n"%(data[0]))
                    if "S6" in data[1]: fp.write("%s, S4\n"%(data[0]))
            elif cmd =="PR": 
                data = line.split(",")
                if int(data[0]) < limit: 
                    if "S3" in data[1]: fp.write("%s, S1\n"%(data[0]))
                    if "S4" in data[1]: fp.write("%s, S2\n"%(data[0]))
                    if "S5" in data[1]: fp.write("%s, S3\n"%(data[0]))
                    if "S6" in data[1]: fp.write("%s, S4\n"%(data[0]))
            elif cmd =="PL": 
                data = line.split(",")
                if int(data[0]) < limit: 
                    if "S3" in data[1]: fp.write("%s, S1\n"%(data[0]))
                    if "S4" in data[1]: fp.write("%s, S2\n"%(data[0]))
                    if "S5" in data[1]: fp.write("%s, S3\n"%(data[0]))
                    if "S6" in data[1]: fp.write("%s, S4\n"%(data[0]))
            elif cmd =="BD": 
                data = line.split(",")
                if int(data[0]) < limit: 
                    if "S3" in data[1]: fp.write("%s, S1\n"%(data[0]))
                    if "S4" in data[1]: fp.write("%s, S2\n"%(data[0]))
                    if "S5" in data[1]: fp.write("%s, S3\n"%(data[0]))
                    if "S6" in data[1]: fp.write("%s, S4\n"%(data[0]))
            elif cmd =="TM": 
                data = line.split(",")
                if int(data[0]) < limit: 
                    if "S3" in data[1]: fp.write("%s, S1\n"%(data[0]))
                    if "S4" in data[1]: fp.write("%s, S2\n"%(data[0]))
                    if "S5" in data[1]: fp.write("%s, S3\n"%(data[0]))
                    if "S6" in data[1]: fp.write("%s, S4\n"%(data[0]))
            elif cmd =="TS": 
                data = line.split(",")
                if int(data[0]) < limit: 
                    if "S3" in data[1]: fp.write("%s, S1\n"%(data[0]))
                    if "S4" in data[1]: fp.write("%s, S2\n"%(data[0]))
                    if "S5" in data[1]: fp.write("%s, S3\n"%(data[0]))
                    if "S6" in data[1]: fp.write("%s, S4\n"%(data[0]))
            elif cmd =="TD": 
                fp.write(line)
            else: 
                continue 
            
    fp.close()

    Node_Sectors = AllNodes / SectorNodes 
    EL_Sectors = AllElements / SectorEls 

    print ("\n ** Sector No. check ")
    print (" All Nodes = %d\n Nodes per Sector = %d\n Sectors = %.1f"%(AllNodes, SectorNodes, Node_Sectors))
    print (" All ELs   = %d\n ELs per Sector   = %d\n Sectors = %.1f"%(AllElements, SectorEls, EL_Sectors))

    nodes = np.array(nodes)
    elements = np.array(elements)


    idx = np.where(nodes[:,0]<limit)[0]
    sectornodes = nodes[idx]

    idx = np.where(elements[:,0]<limit)[0]
    s1els = elements[idx]

    sectornodes = nodes 
    return sectornodes 


def readBodyLayout(meshfile=None): 
    # print ("Mesh file", meshfile)
    layout = LAYOUT(meshfile)
    layout.OuterEdge()

    beltEdge =[]   # print ("EDGE : Node1, Node2, Elset_Name, FacdID, Element_No, D")
    carcass =[]
    BDR = ELEMENT()
    BDL = ELEMENT()
    npn = np.array(layout.Node.Node)

    for el in layout.Element.Element: 
        if 'BT1' in el[5] or 'BT2' in el[5] or 'BT3' in el[5]: 
            beltEdge.append([el[1], el[2], el[5], 0, el[0], 0])
        if 'C01' in el[5]: 
            carcass.append([el[1], el[2], el[5], 0, el[0], 0])
        if 'BEAD_L' in el[5] or 'BEAD_R' in el[5]:
            ix = np.where(npn[:, 0]==el[1])[0][0]
            if npn[ix][2]>0: 
                BDR.Add(el)
            else:
                BDL.Add(el)

    edge_BD = BDR.OuterEdge(layout.Node)
    edge_BDL = BDL.OuterEdge(layout.Node)
    # edge_BD.Image(layout.Node, file="RBead.png")
    # edge_BDL.Image(layout.Node, file="LBead.png")
    # print (len(edge_BD.Edge));     print (len(edge_BDL.Edge))
    edge_BD.Combine(edge_BDL)
    # print (len(edge_BD.Edge))
    # layout.edge_outer.Image(layout.Node, file='outer.png')
    # print (layout.edge_outer)
    fp = open('outer.tmp', 'w')
    for ed in layout.edge_outer.Edge: 
        fp.write("%d, %d, 0, 0, %d, 0\n"%(ed[0], ed[1], ed[4]))
    fp.close()
    fp = open('belt.tmp', 'w')
    for ed in beltEdge: 
        fp.write("%d, %d, 0, 0, %d, 0\n"%(ed[0], ed[1], ed[4]))
    fp.close()
    fp = open('bead.tmp', 'w')
    for ed in edge_BD.Edge: 
        fp.write("%d, %d, 0, 0, %d, 0\n"%(ed[0], ed[1], ed[4]))
    for ed in edge_BDL.Edge: 
        fp.write("%d, %d, 0, 0, %d, 0\n"%(ed[0], ed[1], ed[4]))
    fp.close()
    fp = open('carcass.tmp', 'w')
    for ed in carcass: 
        fp.write("%d, %d, 0, 0, %d, 0\n"%(ed[0], ed[1], ed[4]))
    fp.close()
    try: 
        topsurf_edges = GrooveDetectionFromEdge(layout.edge_outer, layout.Node)
        no_tread = 10**7
        ffname = 'topsurf.tmp'
        tfp = open(ffname, 'w')
        for ed in topsurf_edges.Edge:
            if ed[7] == 0: 
                tfp.write("%10d, %10d, %10d, %10d, %10d\n"%(ed[4]+ no_tread, ed[0]+no_tread, ed[1]+no_tread, ed[1]+no_tread, ed[0]+no_tread))
        tfp.close()
    
    except: 
        print ("** NO Groove FOUND. Mesh was generated from axi.")
        pass 
        
    return layout.edge_outer.Edge, beltEdge, edge_BD.Edge, carcass 

def readSDBResults(sdbmodel, sdbresult, btm=True, sectors=240, offset=10**4, rotating=0): 
    npn, np2d, np3d, rim_road = readSDB(sdbmodel) 
    d_npn, deformed_Rim_road, iELD, iSED =SDBResult_READ(sdbresult, npn)
    
    idx = np.where(d_npn[:,0]<10**7)[0]
    bdn = d_npn[idx]

    if btm: 
        zmax = np.max(bdn[:,3])
        ix = np.where(bdn[:,3]==zmax)[0][0]
        tn = bdn[ix]
        tsector = int(tn[0]/offset)
        bsector = tsector + int(sectors/2)
        if bsector >= sectors: bsector -= sectors 
        ix1 = np.where(bdn[:,0]>offset*bsector)[0]
        ix2 = np.where(bdn[:,0]<offset*bsector+offset)[0]
        idx = np.intersect1d(ix1, ix2)
        btm_sector_node = bdn[idx]
        btm = []
        if not rotating: 
            for bm in btm_sector_node: 
                nid = int(bm[0])%offset 
                btm.append([nid, bm[1], bm[2], bm[3]])
        else: 
            angle = math.radians(rotating)
            for bm in btm_sector_node:
                nid = int(bm[0])%offset 

                r = math.sqrt(bm[1]**2 + bm[3]**2)

                x = math.cos(angle)*bm[2] - math.sin(angle)*r
                y = math.sin(angle)*bm[2] + math.cos(angle)*r

                btm.append([nid, 0.0, x, y])

        fp=open('deformed.tmp', 'w')
        for n in btm: 
            fp.write("%d, %.7f, %7f, %7f\n"%(n[0], n[1], n[2], n[3]))
        fp.close()

        return np.array(btm)

def GrooveDetectionFromEdge(oEdge, node, OnlyTread=1, TreadNumber=10000000, **args):
    for key, value in args.items():
        if key == 'onlytread' or key == 'tread':
            OnlyTread = int(value)
        if key == 'treadno' or key == 'Treadno' or key == 'Treadstartno' or key == 'TreadStartNo':
            TreadNumber = int(value)
        # if key == 'offset':
            # Offset = int(value)
        # if key == 'step':
            # Step = int(value)

    N = len(oEdge.Edge)
    LengthOfEdge = len(oEdge.Edge[0])

    
    # print 'oEDGE - ', oEdge.Edge[5], len(oEdge.Edge)
    # print '        ', node.NodeByID(oEdge.Edge[5][0]), node.NodeByID(oEdge.Edge[5][1])
    # Reverse = 0
     # Original Edge : [Node 1, Node 2, Elset Name, Face ID, Tie No]
    # Edge from INP(Mesh file) : Add Groove/Tread Edge Mark
    # Data to Add : Edge Length, Groove Mark for Node 1, Groove Mark for Node 2, Tread Mark]
    # Groove Mark : 0 - node not in Groove, 1 - node in Groove
    # Tread Mark : 0 - Edge not on Tread, 2 - Edge on Tread

    TreadElset = ['CTB', 'SUT', 'CTR', 'UTR']#, 'TRW']
    TN = len(TreadElset)
    cEdge = EDGE()
    counting = 0
    for i in range(N):
        TreadID = 0
        for j in range(TN):
            if oEdge.Edge[i][2] == TreadElset[j]:
                TreadID = 2
                cEdge.Add(oEdge.Edge[i])
                N1 = node.NodeByID(oEdge.Edge[i][0])
                N2 = node.NodeByID(oEdge.Edge[i][1])
                length = NodeDistance(N1, N2, xy=0)
                cEdge.Edge[counting][-1] = length
                cEdge.Edge[counting].append(0)
                cEdge.Edge[counting].append(0)
                cEdge.Edge[counting].append(TreadID)
                counting += 1
                break


    CriticalAngle = 45.0   ### if there is an error to detect grooves, check this angle... 
    N = len(cEdge.Edge)
    cEdge.Edge[0][6] = 0
    PA = 0.0  # Previous Angle
    PN = 0  # Previous Node Groove ID : 0 - Not in the groove, 1 - in the groove
    for i in range(1, N):
        N1 = node.NodeByID(cEdge.Edge[i][0])
        N2 = node.NodeByID(cEdge.Edge[i][1])
        if N2[2] - N1[2] != 0: 
            A = math.degrees(math.atan((N2[3] - N1[3]) / (N2[2] - N1[2])))
        else: 
            A = 90.0
            
        if N2[2] < N1[2]:
            A = -A
        cEdge.Edge[i][3] = round(A, 2)

        if i == 1:
            if A > CriticalAngle:
                cEdge.Edge[0][6] = 1  ## To see if TBR shoulder side part
                PN = cEdge.Edge[0][7] = 0
                PA = A
                continue
            else:
                PN = cEdge.Edge[i][7] = 0
                PA = A
                continue
        else:
            cEdge.Edge[i][6] = PN
            if PN == 0:
                if PA > CriticalAngle:
                    if A > CriticalAngle:
                        cEdge.Edge[i][6] = 1
                        PN = cEdge.Edge[i][7] = 0
                        PA = A
                        continue
                    else:  # if  (a < CriticalAngle and a > -CriticalAngle)
                        PN = cEdge.Edge[i][7] = 0
                        PA = A
                        continue
                else:
                    if A < CriticalAngle and A > -CriticalAngle:
                        PN = cEdge.Edge[i][7] = 0
                        PA = A
                        continue
                    elif A < -CriticalAngle and abs(PA - A) > CriticalAngle:
                        PN = cEdge.Edge[i][7] = 1
                        PA = A
                        continue
                    else:  # a > CriticalAngle:
                        PN = cEdge.Edge[i][7] = 1
                        PA = A
                        continue
            else:
                if PA > CriticalAngle:
                    if A < CriticalAngle and A > -CriticalAngle:
                        cEdge.Edge[i][6] = 1
                        PN = cEdge.Edge[i][7] = 0
                        PA = A
                        continue
                    else:
                        PN = cEdge.Edge[i][7] = 1
                        PA = A
                        continue
                else:
                    PN = cEdge.Edge[i][7] = 1
                    PA = A
                    continue

                    
    for i in range(N-1, 0, -1):
        if (cEdge.Edge[i][6] == 0 and cEdge.Edge[i][7] == 0):
            break
        elif cEdge.Edge[i][6] == 1 and cEdge.Edge[i][7] == 1:
            cEdge.Edge[i][6] = 1
            cEdge.Edge[i][7] = 0
        elif cEdge.Edge[i][6] == 0 and cEdge.Edge[i][7] == 1:    
            cEdge.Edge[i][6] = 1
            cEdge.Edge[i][7] = 0
            break
    
    for i in range(N): 
        N1 = node.NodeByID(cEdge.Edge[i][0])
        N2 = node.NodeByID(cEdge.Edge[i][1])
        DIST = NodeDistance(N1,N2, xy=23)
        cEdge.Edge[i][5]=DIST
        N1 = node.NodeByID(cEdge.Edge[i][0])
        N2 = node.NodeByID(cEdge.Edge[i][1])
        N3 = [9999, N1[1], N1[2]+0.1, N1[3]]

        Angle = Angle_3Points(xs=[N1[2], N2[2], N3[2]], ys=[N1[3], N2[3], N3[3]], center_index=1 )
        # Angle = Angle_3nodes(N3, N2, N1, xy=23)
        cEdge.Edge[i][3]=Angle*180.0/3.141592

    # sys.exit()
    
    return cEdge

def NodeDistance(N1, N2, xy=0): 
    if xy > 10: 
        x = int(xy/10); y=int(xy%10)
        return math.sqrt((N2[x] - N1[x])**2 + (N2[y] - N1[y])**2)
    else: 
        return math.sqrt((N2[1] - N1[1])**2 + (N2[2] - N1[2])**2+ (N2[3] - N1[3])**2)

def getCWD(filename): 
    cwd=''
    drs = filename.split("/")
    for i, dr in enumerate(drs): 
        cwd += dr + '/'
        if i == len(drs) -2 : break
    return cwd 

def makingFullFilePath_linux(cwd=None, file=None): 
    if isinstance(cwd, type(None)): 
        cwd = getcwd()
    if cwd[-1] != "/": cwd+='/'

    if "../" in file: 
        names  =file.strip().split("../")
        cnt = 0 
        for name in names: 
            if "" in name: 
                cnt += 1 
        dirs = cwd.split("/")
        path =""
        for i in range(len(dirs)-cnt): 
            if dirs[i]=='':
                path +='/'
            else:
                path += dirs[i]+'/'
        for name in names: 
            if name != "": 
                path += name 
    elif '/home' == file[:5]: 
        path = file 
    elif '' == file: 
        return cwd
    else: 
        if '/' == file[0]: 
            file = file[1:]
        path = cwd + file 

    return path 

def rotatePoints(px, py, angle=0): 
    radian_angle = math.radians(angle)
    xs = np.cos(radian_angle) * px - np.sin(radian_angle) * py
    ys = np.sin(radian_angle) * px + np.cos(radian_angle) * py 
    return xs, ys 

def getNode_2dMesh(meshfile): 
    with open(meshfile) as DFM: 
        lines = DFM.readlines()
    
    cmd = None 
    NODE=[]
    for line in lines: 
        if "**" in line : continue 
        if "*" in line :
            if "*NODE" in line: 
                cmd = 'ND'
            else: 
                cmd = None 
        else: 
            if cmd == 'ND': 
                wd = line.split(",")
                NODE.append([int(wd[0].strip()), float(wd[3].strip()), float(wd[2].strip()), float(wd[1].strip())])

    return np.array(NODE)

class FOOTPRINT(): 
    def __init__(self) :
        self.px =[];         self.py =[];        self.pv =[]
        self.xs=[]; self.ys=[]; self.vs =[]
        self.centerPress=[]

        self.file = ""
        self.ptn =None ;     self.mesh = None;   self.smart = None 
        self.isPTN = False
        self.sfric = False 
        self.workingfile = None 
        
        self.angle = 0.0
        self.lateralShift = 0.0 
        
        self.vmin = 50000
        self.vmax = 500000
        self.density = 20 
        self.group = 'pcr'

        self.fitting = 6 

        self.totalArea = 0.0
        self.actualArea = 0.0 
        self.roundness = 0.0
        self.lengths=[]
        self.widths=[]
        self.GWShape = 0.0
        self.localGWShape = 0
        self.roundnessShape = 0
        self.squarenessShape = 0
        self.FPClines =[]
        self.boundary=[]
        self.areaPoints=[]

        self.ISLM_totalArea = 0.0
        self.ISLM_actualArea = 0.0 
        self.ISLM_roundness = 0.0
        self.ISLM_lengths=list(range(20))
        self.ISLM_widths=list(range(20))
        self.ISLM_GWShape = 0.0
        self.ISLM_localGWShape = 0
        self.ISLM_roundnessShape = 0
        self.ISLM_squarenessShape = 0
        self.ISLM_FPC=None 
        self.ISLM_FPC_detail = None 
        self.ISLM_boundary=None 
        self.ISLM_boundary_Init=None 

    def inputBoardValues(self, vmin=0,\
         vmax=0, density=0, group="",\
              file="", angle=0, shift=0): 
        self.vmin = vmin
        self.vmax = vmax 
        self.density = density  
        self.group = group 
        self.file = file 
        self.angle = 0
        self.lateralShift = shift 
    def inputFitting(self, fitting): 
        self.fitting = fitting 

    def inputISLM_FPC(self, fname): 
        # print (" ISLM FPC Input")
        with open(fname) as F: 
            lines = F.readlines()
        for line in lines: 
            if 'ActualContactArea' in line: 
                wd = line.split("=")[1].strip()
                self.ISLM_actualArea = float(wd)/10000
                print ('* ActualContactArea', self.ISLM_actualArea)
            if 'TotalContactArea' in line: 
                wd = line.split("=")[1].strip()
                self.ISLM_totalArea = float(wd)/10000
                print ('* TotalContactArea', self.ISLM_totalArea)
            if 'Roundness(%)=' in line: 
                wd = line.split("=")[1].strip()
                self.ISLM_roundness = float(wd)/100
                print ('* Roundness', self.ISLM_roundness)
            if 'DetailedContactLength(mm)' in line: 
                wd = line.split("=")[1].strip()
                ws = wd.split("/")
                # foot.lengths[3], foot.lengths[5], foot.lengths[10], foot.lengths[15], foot.lengths[17]
                self.ISLM_lengths[3] = float(ws[0].strip())
                self.ISLM_lengths[5] = float(ws[1].strip())
                self.ISLM_lengths[10] = float(ws[2].strip())
                self.ISLM_lengths[15] = float(ws[3].strip())
                self.ISLM_lengths[17] = float(ws[4].strip())
                print ("* LENGTHS", self.ISLM_lengths)
            if 'DetailedContactWidth(mm)' in line: 
                wd = line.split("=")[1].strip()
                ws = wd.split("/")
                self.ISLM_widths[3] = float(ws[0].strip())
                self.ISLM_widths[5] = float(ws[1].strip())
                self.ISLM_widths[10] = float(ws[2].strip())
                self.ISLM_widths[15] = float(ws[3].strip())
                self.ISLM_widths[17] = float(ws[4].strip())
                print ("* WIDTHS", self.ISLM_widths)
            if 'Gullwing Global Shape Factor' in line: 
                wd = line.split("=")[1].strip()
                self.ISLM_GWShape = float(wd)
                print ("* Gullwing Global Shape Factor", self.ISLM_GWShape)
            if 'Gullwing Local Shape Factor' in line: 
                wd = line.split("=")[1].strip()
                self.ISLM_localGWShape = float(wd)
                print ("* Gullwing Local Shape Factor", self.ISLM_GWShape)
            if 'Roundness Shape Factor' in line: 
                wd = line.split("=")[1].strip()
                self.ISLM_roundnessShape = float(wd)
                print ("* Roundness Shape Factor", self.ISLM_GWShape)
            if 'Squareness Shape Factor' in line: 
                wd = line.split("=")[1].strip()
                self.ISLM_squarenessShape = float(wd)
                print ("* Squareness Shape Factor", self.ISLM_GWShape)

    def inputInitalFootprint(self, px, py, pv, actualArea): 
        self.px = px 
        self.py = py 
        self.pv = pv
        self.actualArea = actualArea 

    def inputCenterPressure(self, lst): 
        self.centerPress=lst 

    def inputFPC(self, areaPts, basic, adv, lines): 
        self.totalArea = basic[3] 
        self.actualArea = basic[2] 
        self.roundness = basic[4] 
        self.lengths = basic[0]
        self.widths = basic[1]
        self.GWShape = adv[0]
        self.localGWShape = adv[1]
        self.roundnessShape = adv[2] 
        self.squarenessShape = adv[3] 
        self.FPClines = lines 
        self.areaPoints=areaPts 
    def inputBoundary(self, xs, ys): 
        self.boundary = [xs, ys]
        
class Ui_MainWindow(object):
    
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1200, 994)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout(self.centralwidget)
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.verticalLayout_image = QtWidgets.QVBoxLayout()
        self.verticalLayout_image.setSizeConstraint(QtWidgets.QLayout.SetMaximumSize)
        self.verticalLayout_image.setObjectName("verticalLayout_image")
        # self.label_imageBox = QtWidgets.QLabel(self.centralwidget)
        # self.label_imageBox.setMinimumSize(QtCore.QSize(810, 0))
        # self.label_imageBox.setText("")
        # self.label_imageBox.setObjectName("label_imageBox")
        # self.verticalLayout_image.addWidget(self.label_imageBox)
        self.horizontalLayout_9.addLayout(self.verticalLayout_image)
        self.verticalLayout_menu = QtWidgets.QVBoxLayout()
        self.verticalLayout_menu.setObjectName("verticalLayout_menu")
        self.Group_connection = QtWidgets.QGroupBox(self.centralwidget)
        self.Group_connection.setMinimumSize(QtCore.QSize(330, 30))
        self.Group_connection.setMaximumSize(QtCore.QSize(330, 30))
        self.Group_connection.setTitle("")
        self.Group_connection.setObjectName("Group_connection")
        self.lineEdit_address = QtWidgets.QLineEdit(self.Group_connection)
        self.lineEdit_address.setGeometry(QtCore.QRect(59, 4, 91, 23))
        self.lineEdit_address.setMaximumSize(QtCore.QSize(100, 30))
        self.lineEdit_address.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_address.setObjectName("lineEdit_address")
        self.label_ID = QtWidgets.QLabel(self.Group_connection)
        self.label_ID.setGeometry(QtCore.QRect(156, 5, 21, 21))
        self.label_ID.setMaximumSize(QtCore.QSize(150, 25))
        self.label_ID.setObjectName("label_ID")
        self.lineEdit_hpc_ID = QtWidgets.QLineEdit(self.Group_connection)
        self.lineEdit_hpc_ID.setGeometry(QtCore.QRect(173, 4, 70, 23))
        self.lineEdit_hpc_ID.setMaximumSize(QtCore.QSize(100, 30))
        self.lineEdit_hpc_ID.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_hpc_ID.setObjectName("lineEdit_hpc_ID")
        self.push_connection = QtWidgets.QPushButton(self.Group_connection)
        self.push_connection.setGeometry(QtCore.QRect(250, 4, 71, 23))
        self.push_connection.setMaximumSize(QtCore.QSize(200, 30))
        self.push_connection.setObjectName("push_connection")
        self.check_FTP = QtWidgets.QCheckBox(self.Group_connection)
        self.check_FTP.setGeometry(QtCore.QRect(3, 5, 51, 23))
        self.check_FTP.setMaximumSize(QtCore.QSize(110, 25))
        self.check_FTP.setObjectName("check_FTP")
        self.verticalLayout_menu.addWidget(self.Group_connection)
        self.pushButton_GeneratngFoot = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_GeneratngFoot.setMaximumSize(QtCore.QSize(330, 30))
        self.pushButton_GeneratngFoot.setObjectName("pushButton_GeneratngFoot")
        self.verticalLayout_menu.addWidget(self.pushButton_GeneratngFoot)
        self.group_SimulationType = QtWidgets.QGroupBox(self.centralwidget)
        self.group_SimulationType.setMinimumSize(QtCore.QSize(330, 40))
        self.group_SimulationType.setMaximumSize(QtCore.QSize(330, 40))
        self.group_SimulationType.setTitle("")
        self.group_SimulationType.setObjectName("group_SimulationType")
        self.radio_Single = QtWidgets.QRadioButton(self.group_SimulationType)
        self.radio_Single.setGeometry(QtCore.QRect(20, 10, 81, 17))
        self.radio_Single.setChecked(True)
        self.radio_Single.setObjectName("radio_Single")
        self.radio_DOE = QtWidgets.QRadioButton(self.group_SimulationType)
        self.radio_DOE.setGeometry(QtCore.QRect(110, 10, 61, 17))
        self.radio_DOE.setObjectName("radio_DOE")
        self.lineEdit_DOE_ID = QtWidgets.QLineEdit(self.group_SimulationType)
        self.lineEdit_DOE_ID.setGeometry(QtCore.QRect(170, 5, 80, 28))
        self.lineEdit_DOE_ID.setMinimumSize(QtCore.QSize(80, 0))
        self.lineEdit_DOE_ID.setMaximumSize(QtCore.QSize(80, 30))
        self.lineEdit_DOE_ID.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_DOE_ID.setObjectName("lineEdit_DOE_ID")
        self.radio_Manual = QtWidgets.QRadioButton(self.group_SimulationType)
        self.radio_Manual.setGeometry(QtCore.QRect(260, 10, 61, 17))
        self.radio_Manual.setObjectName("radio_Manual")
        self.verticalLayout_menu.addWidget(self.group_SimulationType)
        self.horizontalLayou_min_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayou_min_2.setObjectName("horizontalLayou_min_2")
        self.lineEdit_0_Location = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_0_Location.setMinimumSize(QtCore.QSize(40, 0))
        self.lineEdit_0_Location.setMaximumSize(QtCore.QSize(40, 30))
        self.lineEdit_0_Location.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_0_Location.setObjectName("lineEdit_0_Location")
        self.horizontalLayou_min_2.addWidget(self.lineEdit_0_Location)
        self.lineEdit_1_VT_Number = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_1_VT_Number.setMinimumSize(QtCore.QSize(80, 0))
        self.lineEdit_1_VT_Number.setMaximumSize(QtCore.QSize(80, 30))
        self.lineEdit_1_VT_Number.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_1_VT_Number.setObjectName("lineEdit_1_VT_Number")
        self.horizontalLayou_min_2.addWidget(self.lineEdit_1_VT_Number)
        self.lineEdit_3_VT_Serial = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_3_VT_Serial.setMinimumSize(QtCore.QSize(40, 0))
        self.lineEdit_3_VT_Serial.setMaximumSize(QtCore.QSize(40, 30))
        self.lineEdit_3_VT_Serial.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_3_VT_Serial.setObjectName("lineEdit_3_VT_Serial")
        self.horizontalLayou_min_2.addWidget(self.lineEdit_3_VT_Serial)
        self.lineEdit_2_VT_Revision = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_2_VT_Revision.setMinimumSize(QtCore.QSize(20, 0))
        self.lineEdit_2_VT_Revision.setMaximumSize(QtCore.QSize(20, 30))
        self.lineEdit_2_VT_Revision.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_2_VT_Revision.setObjectName("lineEdit_2_VT_Revision")
        self.horizontalLayou_min_2.addWidget(self.lineEdit_2_VT_Revision)
        self.lineEdit_4_Sim_Type = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_4_Sim_Type.setMinimumSize(QtCore.QSize(60, 0))
        self.lineEdit_4_Sim_Type.setMaximumSize(QtCore.QSize(60, 30))
        self.lineEdit_4_Sim_Type.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_4_Sim_Type.setObjectName("lineEdit_4_Sim_Type")
        self.horizontalLayou_min_2.addWidget(self.lineEdit_4_Sim_Type)
        self.lineEdit_5_Sim_Num = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_5_Sim_Num.setMinimumSize(QtCore.QSize(30, 0))
        self.lineEdit_5_Sim_Num.setMaximumSize(QtCore.QSize(30, 30))
        self.lineEdit_5_Sim_Num.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_5_Sim_Num.setObjectName("lineEdit_5_Sim_Num")
        self.horizontalLayou_min_2.addWidget(self.lineEdit_5_Sim_Num)
        self.verticalLayout_menu.addLayout(self.horizontalLayou_min_2)
        self.lineEdit_jobDir = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_jobDir.setMinimumSize(QtCore.QSize(330, 0))
        self.lineEdit_jobDir.setMaximumSize(QtCore.QSize(330, 30))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(9)
        self.lineEdit_jobDir.setFont(font)
        self.lineEdit_jobDir.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.lineEdit_jobDir.setObjectName("lineEdit_jobDir")
        self.verticalLayout_menu.addWidget(self.lineEdit_jobDir)
        
        self.lineEdit_smartFile = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_smartFile.setMinimumSize(QtCore.QSize(330, 0))
        self.lineEdit_smartFile.setMaximumSize(QtCore.QSize(330, 30))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(9)
        self.lineEdit_smartFile.setFont(font)
        self.lineEdit_smartFile.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.lineEdit_smartFile.setObjectName("lineEdit_smartFile")
        self.verticalLayout_menu.addWidget(self.lineEdit_smartFile)
        
        self.lineEdit_patternMesh = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_patternMesh.setMinimumSize(QtCore.QSize(330, 0))
        self.lineEdit_patternMesh.setMaximumSize(QtCore.QSize(330, 30))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(9)
        self.lineEdit_patternMesh.setFont(font)
        self.lineEdit_patternMesh.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.lineEdit_patternMesh.setObjectName("lineEdit_patternMesh")
        self.verticalLayout_menu.addWidget(self.lineEdit_patternMesh)
        
        self.lineEdit_jobFile = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_jobFile.setMinimumSize(QtCore.QSize(330, 0))
        self.lineEdit_jobFile.setMaximumSize(QtCore.QSize(330, 30))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(9)
        self.lineEdit_jobFile.setFont(font)
        self.lineEdit_jobFile.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.lineEdit_jobFile.setObjectName("lineEdit_jobFile")
        self.verticalLayout_menu.addWidget(self.lineEdit_jobFile)
        
        
        self.filename = QtWidgets.QLabel(self.centralwidget)
        self.filename.setMaximumSize(QtCore.QSize(330, 30))
        self.filename.setFrameShape(QtWidgets.QFrame.Box)
        self.filename.setObjectName("filename")
        self.verticalLayout_menu.addWidget(self.filename)
        self.groupBox = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox.setMinimumSize(QtCore.QSize(330, 45))
        self.groupBox.setMaximumSize(QtCore.QSize(330, 45))
        self.groupBox.setObjectName("groupBox")
        self.layoutWidget = QtWidgets.QWidget(self.groupBox)
        self.layoutWidget.setGeometry(QtCore.QRect(0, 18, 331, 19))
        self.layoutWidget.setObjectName("layoutWidget")
        self.horizontalLayout_SelectImage = QtWidgets.QHBoxLayout(self.layoutWidget)
        self.horizontalLayout_SelectImage.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_SelectImage.setObjectName("horizontalLayout_SelectImage")
        self.radioButton_print1 = QtWidgets.QRadioButton(self.layoutWidget)
        self.radioButton_print1.setObjectName("radioButton_print1")
        self.horizontalLayout_SelectImage.addWidget(self.radioButton_print1)
        self.radioButton_print2 = QtWidgets.QRadioButton(self.layoutWidget)
        self.radioButton_print2.setObjectName("radioButton_print2")
        self.horizontalLayout_SelectImage.addWidget(self.radioButton_print2)
        self.radioButton_print3 = QtWidgets.QRadioButton(self.layoutWidget)
        self.radioButton_print3.setObjectName("radioButton_print3")
        self.horizontalLayout_SelectImage.addWidget(self.radioButton_print3)
        self.radioButton_print4 = QtWidgets.QRadioButton(self.layoutWidget)
        self.radioButton_print4.setObjectName("radioButton_print4")
        self.horizontalLayout_SelectImage.addWidget(self.radioButton_print4)
        self.radioButton_print5 = QtWidgets.QRadioButton(self.layoutWidget)
        self.radioButton_print5.setObjectName("radioButton_print5")
        self.horizontalLayout_SelectImage.addWidget(self.radioButton_print5)
        self.verticalLayout_menu.addWidget(self.groupBox)
        self.groupBox_2 = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_2.setMinimumSize(QtCore.QSize(330, 45))
        self.groupBox_2.setMaximumSize(QtCore.QSize(330, 45))
        self.groupBox_2.setObjectName("groupBox_2")
        self.layoutWidget1 = QtWidgets.QWidget(self.groupBox_2)
        self.layoutWidget1.setGeometry(QtCore.QRect(0, 20, 331, 19))
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.horizontalLayout_SelectImage_2 = QtWidgets.QHBoxLayout(self.layoutWidget1)
        self.horizontalLayout_SelectImage_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_SelectImage_2.setObjectName("horizontalLayout_SelectImage_2")
        self.checkBox = QtWidgets.QCheckBox(self.layoutWidget1)
        self.checkBox.setObjectName("checkBox")
        self.horizontalLayout_SelectImage_2.addWidget(self.checkBox)
        self.checkBox_2 = QtWidgets.QCheckBox(self.layoutWidget1)
        self.checkBox_2.setObjectName("checkBox_2")
        self.horizontalLayout_SelectImage_2.addWidget(self.checkBox_2)
        self.checkBox_3 = QtWidgets.QCheckBox(self.layoutWidget1)
        self.checkBox_3.setObjectName("checkBox_3")
        self.horizontalLayout_SelectImage_2.addWidget(self.checkBox_3)
        self.checkBox_4 = QtWidgets.QCheckBox(self.layoutWidget1)
        self.checkBox_4.setObjectName("checkBox_4")
        self.horizontalLayout_SelectImage_2.addWidget(self.checkBox_4)
        self.checkBox_5 = QtWidgets.QCheckBox(self.layoutWidget1)
        self.checkBox_5.setObjectName("checkBox_5")
        self.horizontalLayout_SelectImage_2.addWidget(self.checkBox_5)
        self.verticalLayout_menu.addWidget(self.groupBox_2)
        self.pushButton_compare = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_compare.setMaximumSize(QtCore.QSize(330, 30))
        self.pushButton_compare.setObjectName("pushButton_compare")
        self.verticalLayout_menu.addWidget(self.pushButton_compare)
        self.group_TIRE = QtWidgets.QGroupBox(self.centralwidget)
        self.group_TIRE.setMinimumSize(QtCore.QSize(330, 30))
        self.group_TIRE.setMaximumSize(QtCore.QSize(330, 30))
        self.group_TIRE.setTitle("")
        self.group_TIRE.setObjectName("group_TIRE")
        self.radio_PC = QtWidgets.QRadioButton(self.group_TIRE)
        self.radio_PC.setGeometry(QtCore.QRect(20, 7, 91, 17))
        self.radio_PC.setChecked(True)
        self.radio_PC.setObjectName("radio_PC")
        self.radioTB = QtWidgets.QRadioButton(self.group_TIRE)
        self.radioTB.setGeometry(QtCore.QRect(210, 7, 91, 17))
        self.radioTB.setObjectName("radioTB")
        self.radioLT = QtWidgets.QRadioButton(self.group_TIRE)
        self.radioLT.setGeometry(QtCore.QRect(120, 7, 81, 17))
        self.radioLT.setObjectName("radioLT")
        self.verticalLayout_menu.addWidget(self.group_TIRE)
        self.pushButton_Redraw = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_Redraw.setMaximumSize(QtCore.QSize(330, 30))
        self.pushButton_Redraw.setObjectName("pushButton_Redraw")
        self.verticalLayout_menu.addWidget(self.pushButton_Redraw)
        self.pushButton_Range = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_Range.setMaximumSize(QtCore.QSize(330, 30))
        self.pushButton_Range.setObjectName("pushButton_Range")
        self.verticalLayout_menu.addWidget(self.pushButton_Range)
        self.horizontalLayou_min = QtWidgets.QHBoxLayout()
        self.horizontalLayou_min.setObjectName("horizontalLayou_min")
        self.label_min = QtWidgets.QLabel(self.centralwidget)
        self.label_min.setMaximumSize(QtCore.QSize(60, 25))
        self.label_min.setAlignment(QtCore.Qt.AlignCenter)
        self.label_min.setObjectName("label_min")
        self.horizontalLayou_min.addWidget(self.label_min)
        self.lineEdit_min_colorRange = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_min_colorRange.setMaximumSize(QtCore.QSize(80, 30))
        self.lineEdit_min_colorRange.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_min_colorRange.setObjectName("lineEdit_min_colorRange")
        self.horizontalLayou_min.addWidget(self.lineEdit_min_colorRange)
        self.label_max = QtWidgets.QLabel(self.centralwidget)
        self.label_max.setMaximumSize(QtCore.QSize(60, 25))
        self.label_max.setAlignment(QtCore.Qt.AlignCenter)
        self.label_max.setObjectName("label_max")
        self.horizontalLayou_min.addWidget(self.label_max)
        self.lineEdit_max_colorRange = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_max_colorRange.setMaximumSize(QtCore.QSize(100, 30))
        self.lineEdit_max_colorRange.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_max_colorRange.setObjectName("lineEdit_max_colorRange")
        self.horizontalLayou_min.addWidget(self.lineEdit_max_colorRange)
        self.verticalLayout_menu.addLayout(self.horizontalLayou_min)
        self.horizontalLayout_max = QtWidgets.QHBoxLayout()
        self.horizontalLayout_max.setObjectName("horizontalLayout_max")
        self.verticalLayout_menu.addLayout(self.horizontalLayout_max)
        self.horizontalLayout_ptSize = QtWidgets.QHBoxLayout()
        self.horizontalLayout_ptSize.setObjectName("horizontalLayout_ptSize")
        self.pushPointSize = QtWidgets.QPushButton(self.centralwidget)
        self.pushPointSize.setMaximumSize(QtCore.QSize(200, 30))
        self.pushPointSize.setObjectName("pushPointSize")
        self.horizontalLayout_ptSize.addWidget(self.pushPointSize)
        self.lineEdit_pointSize = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_pointSize.setMaximumSize(QtCore.QSize(100, 30))
        self.lineEdit_pointSize.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_pointSize.setObjectName("lineEdit_pointSize")
        self.horizontalLayout_ptSize.addWidget(self.lineEdit_pointSize)
        self.verticalLayout_menu.addLayout(self.horizontalLayout_ptSize)
        self.horizontalLayout_ptDensity = QtWidgets.QHBoxLayout()
        self.horizontalLayout_ptDensity.setObjectName("horizontalLayout_ptDensity")
        self.pushPointsDensity = QtWidgets.QPushButton(self.centralwidget)
        self.pushPointsDensity.setMaximumSize(QtCore.QSize(200, 30))
        self.pushPointsDensity.setObjectName("pushPointsDensity")
        self.horizontalLayout_ptDensity.addWidget(self.pushPointsDensity)
        self.lineEdit_PointsDensity = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_PointsDensity.setMaximumSize(QtCore.QSize(100, 30))
        self.lineEdit_PointsDensity.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_PointsDensity.setObjectName("lineEdit_PointsDensity")
        self.horizontalLayout_ptDensity.addWidget(self.lineEdit_PointsDensity)
        self.verticalLayout_menu.addLayout(self.horizontalLayout_ptDensity)
        self.horizontalLayout_angle = QtWidgets.QHBoxLayout()
        self.horizontalLayout_angle.setObjectName("horizontalLayout_angle")
        self.push_Rotating = QtWidgets.QPushButton(self.centralwidget)
        self.push_Rotating.setMaximumSize(QtCore.QSize(200, 30))
        self.push_Rotating.setObjectName("push_Rotating")
        self.horizontalLayout_angle.addWidget(self.push_Rotating)
        self.lineEdit_rotating = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_rotating.setMaximumSize(QtCore.QSize(100, 30))
        self.lineEdit_rotating.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_rotating.setObjectName("lineEdit_rotating")
        self.horizontalLayout_angle.addWidget(self.lineEdit_rotating)
        self.verticalLayout_menu.addLayout(self.horizontalLayout_angle)
        self.horizontalLayout_angle_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_angle_2.setObjectName("horizontalLayout_angle_2")
        self.push_lateralShift = QtWidgets.QPushButton(self.centralwidget)
        self.push_lateralShift.setMaximumSize(QtCore.QSize(200, 30))
        self.push_lateralShift.setObjectName("push_lateralShift")
        self.horizontalLayout_angle_2.addWidget(self.push_lateralShift)
        self.lineEdit_lateralShift = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_lateralShift.setMaximumSize(QtCore.QSize(100, 30))
        self.lineEdit_lateralShift.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_lateralShift.setObjectName("lineEdit_lateralShift")
        self.horizontalLayout_angle_2.addWidget(self.lineEdit_lateralShift)
        self.verticalLayout_menu.addLayout(self.horizontalLayout_angle_2)
        self.horizontalLayout_fitting = QtWidgets.QHBoxLayout()
        self.horizontalLayout_fitting.setObjectName("horizontalLayout_fitting")
        self.check_showFittingPoints = QtWidgets.QCheckBox(self.centralwidget)
        self.check_showFittingPoints.setMaximumSize(QtCore.QSize(110, 25))
        self.check_showFittingPoints.setObjectName("check_showFittingPoints")
        self.horizontalLayout_fitting.addWidget(self.check_showFittingPoints)
        self.label_fittingOrder = QtWidgets.QLabel(self.centralwidget)
        self.label_fittingOrder.setMaximumSize(QtCore.QSize(90, 25))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.label_fittingOrder.setFont(font)
        self.label_fittingOrder.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_fittingOrder.setObjectName("label_fittingOrder")
        self.horizontalLayout_fitting.addWidget(self.label_fittingOrder)
        self.lineEdit_fittingOrder = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_fittingOrder.setMaximumSize(QtCore.QSize(80, 30))
        self.lineEdit_fittingOrder.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_fittingOrder.setObjectName("lineEdit_fittingOrder")
        self.horizontalLayout_fitting.addWidget(self.lineEdit_fittingOrder)
        self.verticalLayout_menu.addLayout(self.horizontalLayout_fitting)
        self.check_ISLM_FPC = QtWidgets.QCheckBox(self.centralwidget)
        self.check_ISLM_FPC.setMaximumSize(QtCore.QSize(110, 25))
        self.check_ISLM_FPC.setObjectName("check_ISLM_FPC")
        self.verticalLayout_menu.addWidget(self.check_ISLM_FPC)
        self.Blank_1 = QtWidgets.QLabel(self.centralwidget)
        self.Blank_1.setMaximumSize(QtCore.QSize(330, 30))
        self.Blank_1.setFrameShape(QtWidgets.QFrame.Box)
        self.Blank_1.setFrameShadow(QtWidgets.QFrame.Raised)
        self.Blank_1.setText("")
        self.Blank_1.setObjectName("Blank_1")
        self.verticalLayout_menu.addWidget(self.Blank_1)
        self.Blank_2 = QtWidgets.QLabel(self.centralwidget)
        self.Blank_2.setMaximumSize(QtCore.QSize(330, 30))
        self.Blank_2.setFrameShape(QtWidgets.QFrame.Box)
        self.Blank_2.setFrameShadow(QtWidgets.QFrame.Raised)
        self.Blank_2.setText("")
        self.Blank_2.setObjectName("Blank_2")
        self.verticalLayout_menu.addWidget(self.Blank_2)
        self.Blank_3 = QtWidgets.QLabel(self.centralwidget)
        self.Blank_3.setMaximumSize(QtCore.QSize(330, 30))
        self.Blank_3.setFrameShape(QtWidgets.QFrame.Box)
        self.Blank_3.setFrameShadow(QtWidgets.QFrame.Raised)
        self.Blank_3.setText("")
        self.Blank_3.setObjectName("Blank_3")
        self.verticalLayout_menu.addWidget(self.Blank_3)
        self.Blank_4 = QtWidgets.QLabel(self.centralwidget)
        self.Blank_4.setMaximumSize(QtCore.QSize(330, 30))
        self.Blank_4.setFrameShape(QtWidgets.QFrame.Box)
        self.Blank_4.setFrameShadow(QtWidgets.QFrame.Raised)
        self.Blank_4.setText("")
        self.Blank_4.setObjectName("Blank_4")
        self.verticalLayout_menu.addWidget(self.Blank_4)
        self.Blank_5 = QtWidgets.QLabel(self.centralwidget)
        self.Blank_5.setMaximumSize(QtCore.QSize(330, 30))
        self.Blank_5.setFrameShape(QtWidgets.QFrame.Box)
        self.Blank_5.setFrameShadow(QtWidgets.QFrame.Raised)
        self.Blank_5.setText("")
        self.Blank_5.setObjectName("Blank_5")
        self.verticalLayout_menu.addWidget(self.Blank_5)
        self.Blank_6 = QtWidgets.QLabel(self.centralwidget)
        self.Blank_6.setMaximumSize(QtCore.QSize(330, 30))
        self.Blank_6.setFrameShape(QtWidgets.QFrame.Box)
        self.Blank_6.setFrameShadow(QtWidgets.QFrame.Raised)
        self.Blank_6.setText("")
        self.Blank_6.setObjectName("Blank_6")
        self.verticalLayout_menu.addWidget(self.Blank_6)
        self.horizontalLayout_9.addLayout(self.verticalLayout_menu)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1200, 21))
        self.menubar.setObjectName("menubar")
        self.menuFILE = QtWidgets.QMenu(self.menubar)
        self.menuFILE.setObjectName("menuFILE")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionOpen = QtWidgets.QAction(MainWindow)
        self.actionOpen.setObjectName("actionOpen")
        self.actionClose = QtWidgets.QAction(MainWindow)
        self.actionClose.setObjectName("actionClose")
        self.actionOpen_dat_from_sfric = QtWidgets.QAction(MainWindow)
        self.actionOpen_dat_from_sfric.setObjectName("actionOpen_dat_from_sfric")
        self.menuFILE.addAction(self.actionOpen)
        self.menuFILE.addAction(self.actionOpen_dat_from_sfric)
        self.menuFILE.addAction(self.actionClose)
        self.menubar.addAction(self.menuFILE.menuAction())

        self.retranslateUi(MainWindow)
        self.actionClose.triggered.connect(MainWindow.close)
        self.actionOpen.triggered.connect(MainWindow.update)
        self.pushButton_Range.clicked.connect(self.lineEdit_min_colorRange.copy)
        self.pushButton_Range.clicked.connect(self.lineEdit_max_colorRange.copy)
        self.pushPointSize.clicked.connect(self.lineEdit_pointSize.copy)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        MainWindow.setTabOrder(self.lineEdit_address, self.lineEdit_hpc_ID)
        MainWindow.setTabOrder(self.lineEdit_hpc_ID, self.push_connection)
        MainWindow.setTabOrder(self.push_connection, self.pushButton_GeneratngFoot)
        MainWindow.setTabOrder(self.pushButton_GeneratngFoot, self.radio_Single)
        MainWindow.setTabOrder(self.radio_Single, self.radio_DOE)
        MainWindow.setTabOrder(self.radio_DOE, self.lineEdit_DOE_ID)
        MainWindow.setTabOrder(self.lineEdit_DOE_ID, self.radio_Manual)
        MainWindow.setTabOrder(self.radio_Manual, self.lineEdit_0_Location)
        MainWindow.setTabOrder(self.lineEdit_0_Location, self.lineEdit_1_VT_Number)
        MainWindow.setTabOrder(self.lineEdit_1_VT_Number, self.lineEdit_3_VT_Serial)
        MainWindow.setTabOrder(self.lineEdit_3_VT_Serial, self.lineEdit_2_VT_Revision)
        MainWindow.setTabOrder(self.lineEdit_2_VT_Revision, self.lineEdit_4_Sim_Type)
        MainWindow.setTabOrder(self.lineEdit_4_Sim_Type, self.lineEdit_5_Sim_Num)
        MainWindow.setTabOrder(self.lineEdit_5_Sim_Num, self.lineEdit_jobDir)
        MainWindow.setTabOrder(self.lineEdit_jobDir, self.lineEdit_jobFile)
        MainWindow.setTabOrder(self.lineEdit_jobFile, self.lineEdit_patternMesh)
        MainWindow.setTabOrder(self.lineEdit_patternMesh, self.lineEdit_smartFile)
        MainWindow.setTabOrder(self.lineEdit_smartFile, self.radioButton_print1)
        MainWindow.setTabOrder(self.radioButton_print1, self.radioButton_print2)
        MainWindow.setTabOrder(self.radioButton_print2, self.radioButton_print3)
        MainWindow.setTabOrder(self.radioButton_print3, self.radioButton_print4)
        MainWindow.setTabOrder(self.radioButton_print4, self.radioButton_print5)
        MainWindow.setTabOrder(self.radioButton_print5, self.checkBox)
        MainWindow.setTabOrder(self.checkBox, self.checkBox_2)
        MainWindow.setTabOrder(self.checkBox_2, self.checkBox_3)
        MainWindow.setTabOrder(self.checkBox_3, self.checkBox_4)
        MainWindow.setTabOrder(self.checkBox_4, self.checkBox_5)
        MainWindow.setTabOrder(self.checkBox_5, self.pushButton_compare)
        MainWindow.setTabOrder(self.pushButton_compare, self.radio_PC)
        MainWindow.setTabOrder(self.radio_PC, self.radioLT)
        MainWindow.setTabOrder(self.radioLT, self.radioTB)
        MainWindow.setTabOrder(self.radioTB, self.pushButton_Redraw)
        MainWindow.setTabOrder(self.pushButton_Redraw, self.pushButton_Range)
        MainWindow.setTabOrder(self.pushButton_Range, self.lineEdit_min_colorRange)
        MainWindow.setTabOrder(self.lineEdit_min_colorRange, self.lineEdit_max_colorRange)
        MainWindow.setTabOrder(self.lineEdit_max_colorRange, self.lineEdit_pointSize)
        MainWindow.setTabOrder(self.lineEdit_pointSize, self.lineEdit_PointsDensity)
        MainWindow.setTabOrder(self.lineEdit_PointsDensity, self.lineEdit_rotating)
        MainWindow.setTabOrder(self.lineEdit_rotating, self.push_Rotating)
        MainWindow.setTabOrder(self.push_Rotating, self.lineEdit_lateralShift)
        MainWindow.setTabOrder(self.lineEdit_lateralShift, self.push_lateralShift)
        MainWindow.setTabOrder(self.push_lateralShift, self.check_showFittingPoints)
        MainWindow.setTabOrder(self.check_showFittingPoints, self.lineEdit_fittingOrder)
        MainWindow.setTabOrder(self.lineEdit_fittingOrder, self.check_ISLM_FPC)
        MainWindow.setTabOrder(self.check_ISLM_FPC, self.pushPointSize)
        MainWindow.setTabOrder(self.pushPointSize, self.pushPointsDensity)
        MainWindow.setTabOrder(self.pushPointsDensity, self.check_FTP)


        self.radio_Single.clicked.connect(self.jobStatus)
        self.radio_DOE.clicked.connect(self.jobStatus)
        self.radio_Manual.clicked.connect(self.jobStatus)
        
        self.pushButton_GeneratngFoot.clicked.connect(self.loadImage)
        self.pushButton_Redraw.clicked.connect(self.redrawing)
        self.check_showFittingPoints.stateChanged.connect(self.viewRefPoints)

        self.push_Rotating.clicked.connect(self.reCalculatingFPC)
        self.push_lateralShift.clicked.connect(self.reCalculatingFPC)
        self.pushButton_Range.clicked.connect(self.reCalculatingFPC)

        self.lineEdit_DOE_ID.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_0_Location.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_1_VT_Number.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_3_VT_Serial.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_2_VT_Revision.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_4_Sim_Type.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_5_Sim_Num.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_jobDir.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_jobFile.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_patternMesh.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_smartFile.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_min_colorRange.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_max_colorRange.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_pointSize.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_PointsDensity.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_address.editingFinished.connect(self.writeSettingValueChange)
        self.lineEdit_hpc_ID.editingFinished.connect(self.writeSettingValueChange)

        self.radio_PC.clicked.connect(self.writeSettingValueChange)
        self.radioTB.clicked.connect(self.writeSettingValueChange)
        self.radio_Single.clicked.connect(self.writeSettingValueChange)
        self.radio_DOE.clicked.connect(self.writeSettingValueChange)
        self.radio_Manual.clicked.connect(self.writeSettingValueChange)

        self.radioButton_print1.clicked.connect(self.changeFootprint)
        self.radioButton_print2.clicked.connect(self.changeFootprint)
        self.radioButton_print3.clicked.connect(self.changeFootprint)
        self.radioButton_print4.clicked.connect(self.changeFootprint)
        self.radioButton_print5.clicked.connect(self.changeFootprint)

        self.radio_PC.clicked.connect(self.setColorRange)
        self.radioTB.clicked.connect(self.setColorRange)
        self.radioLT.clicked.connect(self.setColorRange)

        self.check_FTP.setDisabled(True)
        self.push_connection.clicked.connect(self.connectFTP)
        
        self.check_ISLM_FPC.stateChanged.connect(self.printFPC)
        
        self.pushButton_compare.clicked.connect(self.addComparingBoundary)
        self.comparings=[]
        self.px=[]; self.py=[];  self.pv=[]
        self.angle = 0
        self.vmin = 0 
        self.vmax = 0 
        self.size = 0.3 
        self.connectionStatus = False 
        self.cwd = getcwd()
        self.smart=None
        self.ptn = None
        self.mesh = None 
        self.foots = []
        self.current =[]
        self.checkboxes=[]
        self.FN = 5 
        self.fn = -1 

        self.log='footprint.log'
        logf = open(self.log, 'w')
        logf.close()

        self.localSMART = 'local_SMART.inp' 
        self.localMesh = 'local_2dMesh.inp'
        self.localDat = 'local-postfoot.dat'
        self.localSfric = 'local_sfric.sfric'
        self.localSfricResult = 'local_sfricResult.sfric010'
        self.localPtn = None 
        self.localAxi= 'localAxi.axi'
        self.localISLMPoints = 'localISLMPoints.dat'
        self.localISLMFPC = "ISLM_FPC_Original.txt"
        self.localDeformed = 'DeformedShape.inp'

        self.Starting()
        self.jobStatus()

        self._stdout = StdoutRedirect()
        self._stdout.start()
        self._stdout.printOccur.connect(lambda x : self._append_text(x))

    def _append_text(self, msg): 
        logf = open(self.log, 'a')
        logf.write("%s"%(msg))
        logf.close()

    def connectFTP(self): 
        host = self.lineEdit_address.text().strip()
        pw = user = self.lineEdit_hpc_ID.text().strip()
        
        if not self.connectionStatus: 
            if ":" in host: 
                ips = host.split(":")
                host = ips[0]
                port = int(ips[1])
            else: 
                port =22
            print ("Connecting to %s, port=%d, ID=%s"%(host, port, user), end= ", ")

            try: 
                self.filename.setText( "Connecting")
                self.ftp = FTP.SSHClient()
                self.ftp.set_missing_host_key_policy(FTP.AutoAddPolicy())
                try:
                    self.ftp.connect(host, username=user, password=pw, port=port)
                except: 
                    pw = user = 'h20200155'
                    print ("\nConnecting to %s, port=%d, ID=%s"%(host, port, user), end= ", ")
                    self.ftp.connect(host, username=user, password=pw, port=port)
                
                self.connectionStatus = True
                self.filename.setText("Connected!!")
                self.check_FTP.setChecked(True)
                self.push_connection.setText("Disconnect")
                self.group_SimulationType.setEnabled(True)
                self.jobStatus()
                self.sftp = self.ftp.open_sftp()
                print ("Success!!")
            except: 
                self.connectionStatus = False 
                self.filename.setText("Failed to connect!!")
                self.push_connection.setText("Connect")
                self.group_SimulationType.setEnabled(False)
                print ("Fail!!")

        else: 
            self.check_FTP.setChecked(False)
            self.connectionStatus = False 
            self.push_connection.setText("Connect")
            self.group_SimulationType.setEnabled(False)
            self.jobStatus()
            self.filename.setText("Disconnected!!")
            print ("Disconnecting SFTP!")

    def addComparingBoundary(self): 
        boundaries =[]
        if self.checkBox.isChecked(): 
            if len(self.foots[0].boundary): boundaries.append(self.foots[0].boundary)
            else:                           self.checkBox.setChecked(False) 
        if self.checkBox_2.isChecked(): 
            if len(self.foots[1].boundary): boundaries.append(self.foots[1].boundary)
            else:                           self.checkBox_2.setChecked(False) 
        if self.checkBox_3.isChecked(): 
            if len(self.foots[2].boundary): boundaries.append(self.foots[2].boundary)
            else:                           self.checkBox_3.setChecked(False) 
        if self.checkBox_4.isChecked(): 
            if len(self.foots[3].boundary): boundaries.append(self.foots[3].boundary)
            else:                           self.checkBox_4.setChecked(False) 
        if self.checkBox_5.isChecked(): 
            if len(self.foots[4].boundary): boundaries.append(self.foots[4].boundary)
            else:                           self.checkBox_5.setChecked(False) 
        
        self.figure.plotComparing(boundaries)
        self.filename.setText("Boundaries plotted")
        
    def setColorRange(self): 
        if self.radio_PC.isChecked(): 
            self.lineEdit_min_colorRange.setText("50000")
            self.lineEdit_max_colorRange.setText("500000")
        elif self.radioLT.isChecked(): 
            self.lineEdit_min_colorRange.setText("50000")
            self.lineEdit_max_colorRange.setText("800000")
        else: 
            self.lineEdit_min_colorRange.setText("100000")
            self.lineEdit_max_colorRange.setText("1000000")

    def writeSettingValueChange(self): 
        self.writeSetting(default=False)

    # def copySourcefiles(self): 


    def loadImage(self):
        self.comparings=[]
        self.check_showFittingPoints.setChecked(False)
        # self.filename.setText("Image Mode")
        self.fn += 1 
        if self.fn >= self.FN: 
            self.fn -= self.FN 
        print ("######################################")
        print ("## Loading Footprint %d"%(self.fn))
        print ("######################################")
        
        self.foots[self.fn].ISLM_FPC  =None

        ISLM_boundary_points = None 
        local2dMesh = None 
        if self.connectionStatus: 
            workingDirectory = '/home/users/fiper/ISLM/ISLM_JobFolder/'
            DOE = self.lineEdit_DOE_ID.text()
            loc = self.lineEdit_0_Location.text()
            vt = self.lineEdit_1_VT_Number.text()
            vtSerial = int(self.lineEdit_3_VT_Serial.text())
            vtRevision = self.lineEdit_2_VT_Revision.text()
            simType = self.lineEdit_4_Sim_Type.text()
            simNum = int(self.lineEdit_5_Sim_Num.text())

            vtNumber = vt + "VT" + str(format(vtSerial, '05')) + "-" + vtRevision
            simulationID = loc + "-" + vtNumber + '-' + simType + "-" + str(format(simNum, '04'))

            if self.radio_Manual.isChecked():
                workingDirectory = jobDir = self.lineEdit_jobDir.text().strip()
                if workingDirectory[-1]!="/": workingDirectory+="/"
                try: 
                    dirList =self.sftp.listdir(workingDirectory)
                except: 
                    self.filename.setText("The directory is not found.")
                    self.fn -= 1
                    return 

                smart =  self.lineEdit_smartFile.text().strip()
                for name in dirList: 
                    if ".inp" == name[-4:].lower(): 
                        remoteSmart = makingFullFilePath_linux(workingDirectory, name)
                        self.sftp.get(remoteSmart, self.localSMART)
                        if checkSMART_File(self.localSMART): 
                            simulationID = name[:-4] 
                            break 
                else: 
                    self.filename.setText("The smart input was not found.")
                    self.fn -= 1
                    return 
                
                jobFile = self.getRemoteFiles(workingDirectory, simulationID, manual=True)
                
            else: 
                if self.radio_Single.isChecked(): 
                    jobDir = loc+"/"+vt + "/SingleProcess/" + vtNumber + "/" + simulationID 
                    workingDirectory += jobDir 

                else: 
                    jobDir = loc +"/" + vt + "/DOE" + DOE + "/"+ vtNumber + "/" + simulationID 
                    workingDirectory += jobDir 

                try: 
                    dirList =self.sftp.listdir(workingDirectory)
                except: 
                    self.filename.setText("The directory is not found.")
                    self.fn -= 1
                    return 

                for name in dirList: 
                    if ".inp" == name[-4:].lower(): 
                        remoteSmart = makingFullFilePath_linux(workingDirectory, name)
                        self.sftp.get(remoteSmart, self.localSMART)
                        if checkSMART_File(self.localSMART): 
                            simulationID = name[:-4] 
                            break 
                else: 
                    self.filename.setText("The smart input was not found.")
                    self.fn -= 1
                    return

                jobFile = self.getRemoteFiles(workingDirectory, simulationID, manual=False)

            self.filename.setText( simulationID )
        else: 
            isPTN =False
            jobFile, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Select File", self.cwd, "File Open(*.sfric0* *.dat)")
            if jobFile: 
                self.cwd = getCWD(jobFile)
                self.writeSetting()

        self.vmin = float(self.lineEdit_min_colorRange.text())
        self.vmax = float(self.lineEdit_max_colorRange.text())
        self.size = float(self.lineEdit_pointSize.text())
        self.density = int(self.lineEdit_PointsDensity.text())
        self.angle = float(self.lineEdit_rotating.text())
        self.lateralShift = float(self.lineEdit_lateralShift.text())/1000.0
        self.cmap = 'rainbow'
        
        if self.connectionStatus: 
            fname = simulationID
        else: 
            fname = jobFile.split("/")[-1].strip()
            
        self.foots[self.fn].inputBoardValues(vmin=self.vmin, vmax=self.vmax, \
            density=self.density, angle=self.angle, \
            shift=self.lateralShift, file=fname, group='')
        
        if jobFile: 
            self.filename.setText("Generating footprint")
            if '-postfoot.dat' in  jobFile:    
                if self.connectionStatus:  
                    self.mesh = self.localMesh
                    self.smart = self.localSMART
                    self.ptn = self.localPtn
                    self.workingFile = self.localDat
                else: 
                    self.mesh = None
                    self.smart = None
                    self.workingFile = jobFile
                self.current[self.fn].setChecked(True)
                    
                self.foots[self.fn].sfric = False 
                self.filename.setText(jobFile) 
                self.px, self.py, self.pv, self.ActualArea, shift = self.datFootprint(self.workingFile.strip(),\
                     mesh=self.mesh, ptn=self.ptn, smart=self.smart, angle=self.angle)
                shift *= -1
            elif '.sfric' in  jobFile:
                if self.connectionStatus: 
                    if not self.radio_Manual.isChecked(): 
                        if workingDirectory[-1] != "/": 
                            if not smart : self.smart = workingDirectory  + "/"  + simulationID+".inp"
                            else: self.smart =  smart
                        else: 
                            if not smart : self.smart = workingDirectory   + simulationID+".inp"
                    else: 
                        self.smart = remoteSmart
                    jobFile = self.localSfricResult

                try: 
                    self.filename.setText(simulationID)
                except: 
                    self.filename.setText(jobFile.split("/")[-1])
                self.px, self.py, self.pv, self.ActualArea, shift = self.sfricFootprint(jobFile, mesh=self.mesh, ptn=self.ptn, smart=self.smart, angle=self.angle)
                self.foots[self.fn].sfric = True 

            if isfile(self.localISLMFPC): 
                self.foots[self.fn].ISLM_FPC = True 
                print ("* Loading ISLM FPC")
                self.foots[self.fn].inputISLM_FPC(self.localISLMFPC)
                self.check_ISLM_FPC.setChecked(True)
            else: 
                self.check_ISLM_FPC.setChecked(False)

            if isfile(self.localISLMPoints): 
                with open(self.localISLMPoints) as PT: 
                    lines = PT.readlines()
                ptx =[]; pty=[]
                for line in lines : 
                    wds = line.split("\t")
                    cnt = 0 
                    for w in wds: 
                        if not w == '': 
                            cnt += 1 
                            if cnt ==3: 
                                ptx.append(float(w.strip()))
                            if cnt ==4: 
                                pty.append(float(w.strip()))
                self.foots[self.fn].ISLM_boundary=[np.array(ptx)+shift, np.array(pty)]
                self.foots[self.fn].ISLM_boundary_Init=[np.array(ptx)+shift, np.array(pty)]
                print ("** Loading ISLM FPC Points")
                print ("   ISLM FPC Boundary Points Shift = %.2f"%(shift*1000))

            self.foots[self.fn].inputInitalFootprint(self.px, self.py, self.pv, self.ActualArea)
            self.foots[self.fn].xs, self.foots[self.fn].ys, self.foots[self.fn].vs = \
                self.rePosition(self.foots[self.fn], self.vmin,  float(self.lineEdit_rotating.text()), float(self.lineEdit_lateralShift.text()))

            self.center_Pressure = contPress(self.foots[self.fn].xs, self.foots[self.fn].ys, self.foots[self.fn].pv,\
                                 vmin=self.vmin, displim=0.25, savefile=None)
            self.foots[self.fn].inputCenterPressure(self.center_Pressure)
            self.foots[self.fn] = self.calculatingFPC(self.foots[self.fn])

            self.figure.Plotting(self.foots[self.fn].xs, self.foots[self.fn].ys, self.foots[self.fn].vs, vmin=self.vmin, vmax=self.vmax, size=self.size)
            
            self.filename.setText(fname)

            self.current[self.fn].setEnabled(True)
            self.checkboxes[self.fn].setEnabled(True)

            self.printObjectFPC(self.foots[self.fn])

            if self.foots[self.fn].ISLM_FPC: 
                self.check_ISLM_FPC.setEnabled(True)
            else: 
                self.check_ISLM_FPC.setEnabled(False)
    def drawFootprint(self): 
        self.loadImage()
        
    def reCalculatingFPC(self):

        if self.radioButton_print1.isChecked(): fn = 0 
        elif self.radioButton_print2.isChecked(): fn = 1 
        elif self.radioButton_print3.isChecked(): fn = 2 
        elif self.radioButton_print4.isChecked(): fn = 3 
        else: fn = 4 
        self.vmin = float(self.lineEdit_min_colorRange.text())
        self.vmax = float(self.lineEdit_max_colorRange.text())
        self.foots[fn].angle = float(self.lineEdit_rotating.text())
        self.foots[fn].lateralShift = float(self.lineEdit_lateralShift.text())/1000
        if self.foots[fn].vmin != self.vmin : 
            self.foots[fn].actualArea = 0.0
            self.foots[fn].vmin = self.vmin 
        self.foots[fn].vmax = self.vmax 

        self.foots[fn].xs, self.foots[fn].ys, self.foots[fn].vs = \
            self.rePosition(self.foots[fn], self.vmin,  float(self.lineEdit_rotating.text()), float(self.lineEdit_lateralShift.text()))

        center_Pressure = contPress(self.foots[fn].xs, self.foots[fn].ys, self.foots[fn].pv, vmin=self.vmin, displim=0.25, savefile=None)
        self.foots[fn].inputCenterPressure(center_Pressure)
        
        self.check_showFittingPoints.setChecked(False)
        self.size = float(self.lineEdit_pointSize.text())
        self.figure.Plotting(self.foots[fn].xs, self.foots[fn].ys, self.foots[fn].vs, vmin=self.vmin, vmax=self.vmax, size=self.size)

        self.foots[fn] = self.calculatingFPC(self.foots[fn])
        self.check_showFittingPoints.setChecked(False)

    def printFPC(self): 
        if self.radioButton_print1.isChecked(): fn = 0 
        elif self.radioButton_print2.isChecked(): fn = 1 
        elif self.radioButton_print3.isChecked(): fn = 2 
        elif self.radioButton_print4.isChecked(): fn = 3 
        elif self.radioButton_print5.isChecked(): fn = 4
        else: 
            self.current[self.fn].setChecked(True)
            fn = self.fn 
        self.printObjectFPC(self.foots[fn])
        self.viewRefPoints()

    def printObjectFPC(self, foot): 
        if self.check_ISLM_FPC.isChecked(): 
            if foot.ISLM_totalArea : 
                actualArea = foot.ISLM_actualArea
                totalArea = foot.ISLM_totalArea
                roundness = foot.ISLM_roundness 
                lengths = foot.ISLM_lengths
                widths = foot.ISLM_widths 
                GWShape = foot.ISLM_GWShape 
                localGWShape = foot.ISLM_localGWShape
                roundnessShape = foot.ISLM_roundnessShape 
                squarenessShape = foot.ISLM_squarenessShape
                # print ("** ISLM FPC")
            else: 
                self.check_ISLM_FPC.setChecked(False)
                self.check_ISLM_FPC.setDisabled(True)

        if not self.check_ISLM_FPC.isChecked(): 
            # print ("** Calculated FPC")
            actualArea = foot.actualArea
            totalArea = foot.totalArea
            roundness = foot.roundness 
            lengths = foot.lengths
            widths = foot.widths 
            GWShape = foot.GWShape 
            localGWShape = foot.localGWShape
            roundnessShape = foot.roundnessShape 
            squarenessShape = foot.squarenessShape

        if len(lengths): 
            txt = "Area Total=%8.2f, Actual=%8.2f, Roundness=%5.1f%%"%(totalArea*10000, actualArea*10000, roundness*100)
            self.Blank_1.setText(txt)
            sq1 = (lengths[5]+lengths[15])/2/lengths[10] *100
            sq2 = (lengths[3]+lengths[17])/2/lengths[10] *100
            txt = "Length :%6.1f,%6.1f,%6.1f,%6.1f,%6.1f (%5.1f%%,%5.1f%%)"%(lengths[3], lengths[5], lengths[10], lengths[15], lengths[17], sq1, sq2)
            # print ("L", lengths)
            self.Blank_3.setText(txt)
            txt = "  Width :%6.1f,%6.1f,%6.1f,%6.1f,%6.1f"%(widths[3], widths[5], widths[10], widths[15], widths[17])
            # print ("W", lengths)
            self.Blank_4.setText(txt)
            txt = "GW shape=%.3f, Local GW Shape=%.3f"%(GWShape, localGWShape)
            self.Blank_5.setText(txt)
            txt = "Roundness Shape=%.3f, Squareness Shape=%.3f"%(roundnessShape, squarenessShape)
            self.Blank_6.setText(txt)
            self.filename.setText(foot.file)

    def changeFootprint(self): 
        if self.radioButton_print1.isChecked(): fn = 0 
        elif self.radioButton_print2.isChecked(): fn = 1 
        elif self.radioButton_print3.isChecked(): fn = 2 
        elif self.radioButton_print4.isChecked(): fn = 3 
        elif self.radioButton_print5.isChecked(): fn = 4
        else: 
            self.current[self.fn].setChecked(True)
            fn = self.fn
        if not self.foots[fn].totalArea: 
            self.filename.setText("* No image to print")
            return 
        if self.foots[fn].ISLM_FPC: 
            self.check_ISLM_FPC.setEnabled(True)
        else: 
            self.check_ISLM_FPC.setChecked(False)
            self.check_ISLM_FPC.setEnabled(False)
        
        self.printObjectFPC(self.foots[fn])
        self.size = float(self.lineEdit_pointSize.text())
        self.figure.Plotting(self.foots[fn].xs, self.foots[fn].ys, self.foots[fn].vs, vmin=self.foots[fn].vmin, vmax=self.foots[fn].vmax, size=self.size)

        self.lineEdit_PointsDensity.setText(str(self.foots[fn].density))
        self.lineEdit_rotating.setText(str(self.foots[fn].angle))
        self.lineEdit_lateralShift.setText(str(self.foots[fn].lateralShift))
        self.lineEdit_fittingOrder.setText(str(self.foots[fn].fitting))
        self.check_showFittingPoints.setChecked(False)

    def redrawing(self): 
        if self.radioButton_print1.isChecked(): fn = 0 
        elif self.radioButton_print2.isChecked(): fn = 1 
        elif self.radioButton_print3.isChecked(): fn = 2 
        elif self.radioButton_print4.isChecked(): fn = 3 
        else: fn = 4
        
        self.vmin = float(self.lineEdit_min_colorRange.text())
        self.vmax = float(self.lineEdit_max_colorRange.text())
        self.size = float(self.lineEdit_pointSize.text())
        ixs = np.where(self.foots[fn].pv>self.vmin)[0]
        self.foots[fn].xs = self.foots[fn].px[ixs]
        self.foots[fn].ys = self.foots[fn].py[ixs]
        self.foots[fn].vs = self.foots[fn].pv[ixs]
        self.check_showFittingPoints.setChecked(False)
        self.figure.Plotting(self.foots[fn].xs, self.foots[fn].ys, self.foots[fn].vs, vmin=self.vmin, vmax=self.vmax, size=self.size)
        self.check_showFittingPoints.setChecked(False)
    def viewRefPoints(self): 
        if self.radioButton_print1.isChecked(): fn = 0 
        elif self.radioButton_print2.isChecked(): fn = 1 
        elif self.radioButton_print3.isChecked(): fn = 2 
        elif self.radioButton_print4.isChecked(): fn = 3 
        elif self.radioButton_print5.isChecked(): fn = 4
        else: 
            self.current[self.fn].setChecked(True)
            fn = self.fn
        if self.check_showFittingPoints.isChecked(): 
            if self.check_ISLM_FPC.isChecked(): 
                self.figure.addPoints(self.foots[fn].ISLM_boundary, lw=0, size=1.0)
            else: 
                self.figure.addPoints(self.foots[fn].areaPoints,  self.foots[fn].FPClines)
        else: 
            try: 
                self.figure.removePoints()
            except: 
                pass 
    
    def rePosition(self, foot, vmin, angle, shift): 
        ixs = np.where(foot.pv>vmin)
        px = foot.px[ixs]
        py = foot.py[ixs]
        pv = foot.pv[ixs]
        xs, ys = \
            rotatePoints(px, py, angle )
        xs += shift/1000
        try: 
            foot.ISLM_boundary[0] = foot.ISLM_boundary_Init[0] + shift/1000
        except:
            print (" NO ISLM Boundary points") 
            pass 
        return xs, ys, pv 

    def calculatingFPC(self, foot): 
        areapoints, basicFPC, advFPC, FPCLines \
            = FPC(foot.xs, foot.ys, foot.vs, cp=foot.centerPress, \
                vmin=self.vmin, vmax=self.vmax, ActualArea=foot.actualArea, fitting=int(self.lineEdit_fittingOrder.text()))
        foot.inputFPC(areapoints, basicFPC, advFPC, FPCLines )
        foot.inputFitting(int(self.lineEdit_fittingOrder.text()))
        self.printObjectFPC(foot)

        xs, ys \
        = FPC(foot.xs,foot.ys, foot.vs, cp=foot.centerPress, comparing=True, \
            vmin=self.vmin, vmax=self.vmax, ActualArea=foot.actualArea, fitting=int(self.lineEdit_fittingOrder.text()))
        xs, ys = SearchPoints(xs, ys, nofitting=True)
        foot.inputBoundary(xs, ys)
        return foot 
    
    def datFootprint(self, datFile, mesh=None, ptn=None, smart=None, isPTN=False, angle=0, axi=None):
        mesh2d = None; ptnmesh = None; smartInp = None 
        lateralShift = 0 
        camber = 0 
        centertop = None 
        sft = 0 
        if self.connectionStatus: 
            mesh2d = self.localMesh
            ptnmesh = self.localPtn
            smartInp = self.localSMART
            Y_Shift = 1.0
            centertop = None 
            with open(smartInp) as IN: 
                lines = IN.readlines()
            for line in lines: 
                if '*CAMBER_ANGLE' in line: 
                    camber = float(line.split("=")[1].strip())
            # print (localAxi, mesh2d, isPTN)
            outer, belt, bead, carcass = readBodyLayout( meshfile=mesh2d)
            if isfile(mesh2d): 
                orgn = getNode_2dMesh(mesh2d)
            
                ix1 = np.where(orgn[:,2]>-0.0001)[0]
                ix2 = np.where(orgn[:,2]< 0.03)[0]
                ix = np.intersect1d(ix1, ix2)
                posnodes = orgn[ix]
                zmax = np.max(posnodes[:,3])
                ix = np.where(posnodes[:,3]==zmax)[0][0]
                centertop = posnodes[ix]

            if isfile(self.localDeformed):
                npn = getNode_2dMesh(self.localDeformed)
                ix = np.where(npn[:,0] == centertop[0])[0][0]

                ixs = np.where(npn[:,2]>0)[0]; pos=npn[ixs]
                ixs = np.where(npn[:,2]<0)[0]; neg=npn[ixs]
                posmin = np.min(pos[:, 3]); pix=np.where(pos[:,3]==posmin)[0][0]
                negmin = np.min(neg[:, 3]); nix=np.where(neg[:,3]==negmin)[0][0]
                
                nx = npn[:,2]; ny = npn[:,3]
                rnx, rny = rotatePoints(nx, ny, angle=-camber)

                inx =  np.where(npn[:,0] == pos[pix][0])[0][0]; psn = rnx[inx]
                inx =  np.where(npn[:,0] == neg[nix][0])[0][0]; nsn = rnx[inx]
                sft = (psn + nsn)/2 
                npn[:,2] += sft 
                print ("* Camber Angle=%.1f degree, shift=%.3fmm"%(camber, -sft*1000))
                lateralShift = -sft #

        xs, ys, pv, ActualArea, shift = interpolation_footprint_pressure(vmin=self.vmin, vmax=self.vmax, rotating=self.angle, \
            dotNum=self.density, trd=10**7, post=datFile, Yshift=lateralShift, ptn=ptnmesh, centerNode_initial=centertop)
        print ("* Footprint from post-processed data")
        
        return np.array(xs), np.array(ys), np.array(pv), ActualArea, sft
        self.px = np.array(xs); self.py = np.array(ys); self.pv = np.array(pv)

    def sfricFootprint(self, sfric, mesh=None, ptn=None, smart=None, isPTN=False, angle=0): 
        mesh2d = None; ptnmesh = None; smartInp = None 
        lateralShift= 0 
        if self.connectionStatus: 
            sfricResult =  self.localSfricResult
            sfricModel =  self.localSfric
            mesh2d = self.localMesh
            ptnmesh = self.localPtn
            smart = self.localSMART
        else: 
            sfricResult = sfric
            sfricModel = sfric[:-3]
        Y_Shift = 1.0
        centertop = None


        if isPTN: 
            axi = getAXI_filename_SMARTInput(smartInp)
            localAxi= 'localAxi.axi'
            axifile = self.sftp.get(axi,localAxi)
        else: 
            localAxi = None 
        if localAxi or mesh2d: 
            outer, belt, bead, carcass = readBodyLayout(meshfile=mesh2d)

        xs, ys, pv, ActualArea, shift= interpolation_footprint_pressure(initSfric=sfricModel, resultSfric=sfricResult, vmin=self.vmin, \
            vmax=self.vmax, rotating=self.angle, \
            dotNum=self.density, trd=10**7, post=None, Yshift=lateralShift, ptn=ptnmesh, centerNode_initial=None)
        print (" Footprintn from SFRIC")

        return np.array(xs),  np.array(ys), np.array(pv), ActualArea, shift 

    def Starting(self):

        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("favicon.ico"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        MainWindow.setWindowIcon(icon)

        self.connectionStatus= False 

        self.sfric = SFRIC()
        self.figure = myCanvas()
        self.canvas = self.figure.canvas
        self.toolbar = self.figure.toolbar 
        self.verticalLayout_image.addWidget(self.toolbar)
        self.verticalLayout_image.addWidget(self.canvas)

        self.settingFile = 'setting.dat'
        if not isfile(self.settingFile): 
            self.writeSetting(default=True)
        self.readSetting()
        self.setColorRange()

        self.pushPointSize.setDisabled(True)
        self.pushPointsDensity.setDisabled(True)
        self.jobStatus()

        foot1 = FOOTPRINT()
        foot2 = FOOTPRINT()
        foot3 = FOOTPRINT()
        foot4 = FOOTPRINT()
        foot5 = FOOTPRINT()
        self.foots=[foot1, foot2, foot3, foot4, foot5]
        self.current = [self.radioButton_print1, self.radioButton_print2, self.radioButton_print3, self.radioButton_print4, self.radioButton_print5]
        self.checkboxes = [self.checkBox, self.checkBox_2, self.checkBox_3, self.checkBox_4, self.checkBox_5]
        self.checkBox.setDisabled(True)
        self.checkBox_2.setDisabled(True)
        self.checkBox_3.setDisabled(True)
        self.checkBox_4.setDisabled(True)
        self.checkBox_5.setDisabled(True)

        self.radioButton_print1.setDisabled(True)
        self.radioButton_print2.setDisabled(True)
        self.radioButton_print3.setDisabled(True)
        self.radioButton_print4.setDisabled(True)
        self.radioButton_print5.setDisabled(True)
        self.check_ISLM_FPC.setDisabled(True)
        
        txt = "Area Total=%9s, Actual=%9s, Roundness=%6s%%"%("", "", "")
        self.Blank_1.setText(txt)
        txt = "Position: 15%,25%,50%,75%,85%(Squreness 25-75, 15-85)"
        self.Blank_2.setText(txt)
        txt = "Length :"
        self.Blank_3.setText(txt)
        txt = "  Width :"
        self.Blank_4.setText(txt)

        try: remove (self.localSMART)
        except: pass 
        try: remove(self.localMesh)
        except: pass 
        try: remove(self.localDat)
        except: pass 
        try: remove(self.localSfric)
        except: pass 
        try: remove(self.localSfricResult)
        except: pass 
        try: remove(self.localPtn)
        except: pass 
        try: remove(self.localAxi)
        except: pass 
        try: remove(self.localISLMPoints)
        except: pass 
        try: remove(self.localISLMFPC)
        except: pass 
        try: remove(self.localDeformed)
        except: pass 

    def jobStatus(self): 
        if self.connectionStatus: 
            if self.radio_Single.isChecked(): 
                self.lineEdit_jobDir.setDisabled(True)
                self.lineEdit_jobFile.setDisabled(True)
                self.lineEdit_smartFile.setDisabled(True)
                self.lineEdit_patternMesh.setDisabled(True)
                self.lineEdit_DOE_ID.setEnabled(False)
                self.lineEdit_0_Location.setEnabled(True)
                self.lineEdit_1_VT_Number.setEnabled(True)
                self.lineEdit_3_VT_Serial.setEnabled(True)
                self.lineEdit_2_VT_Revision.setEnabled(True)
                self.lineEdit_4_Sim_Type.setEnabled(True)
                self.lineEdit_5_Sim_Num.setEnabled(True)
            elif self.radio_Manual.isChecked(): 
                self.lineEdit_jobDir.setDisabled(False)
                # self.lineEdit_jobFile.setDisabled(False)
                self.lineEdit_smartFile.setDisabled(False)
                self.lineEdit_patternMesh.setDisabled(False)
                self.lineEdit_DOE_ID.setEnabled(False)
                self.lineEdit_0_Location.setEnabled(False)
                self.lineEdit_1_VT_Number.setEnabled(False)
                self.lineEdit_3_VT_Serial.setEnabled(False)
                self.lineEdit_2_VT_Revision.setEnabled(False)
                self.lineEdit_4_Sim_Type.setEnabled(False)
                self.lineEdit_5_Sim_Num.setEnabled(False)
            else: 
                self.lineEdit_jobDir.setDisabled(True)
                self.lineEdit_jobFile.setDisabled(True)
                self.lineEdit_smartFile.setDisabled(True)
                self.lineEdit_patternMesh.setDisabled(True)
                self.lineEdit_DOE_ID.setEnabled(True)
                self.lineEdit_0_Location.setEnabled(True)
                self.lineEdit_1_VT_Number.setEnabled(True)
                self.lineEdit_3_VT_Serial.setEnabled(True)
                self.lineEdit_2_VT_Revision.setEnabled(True)
                self.lineEdit_4_Sim_Type.setEnabled(True)
                self.lineEdit_5_Sim_Num.setEnabled(True)
        else: 
            self.lineEdit_jobDir.setDisabled(True)
            self.lineEdit_jobFile.setDisabled(True)
            self.lineEdit_smartFile.setDisabled(True)
            self.lineEdit_patternMesh.setDisabled(True)
            self.lineEdit_DOE_ID.setDisabled(True)
            self.lineEdit_0_Location.setDisabled(True)
            self.lineEdit_1_VT_Number.setDisabled(True)
            self.lineEdit_3_VT_Serial.setDisabled(True)
            self.lineEdit_2_VT_Revision.setDisabled(True)
            self.lineEdit_4_Sim_Type.setDisabled(True)
            self.lineEdit_5_Sim_Num.setDisabled(True)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "SMART-Footprint"))
        self.lineEdit_address.setText(_translate("MainWindow", "10.82.66.65"))
        self.label_ID.setText(_translate("MainWindow", "ID"))
        self.lineEdit_hpc_ID.setText(_translate("MainWindow", "h20200155"))
        self.push_connection.setText(_translate("MainWindow", "Connect"))
        self.check_FTP.setText(_translate("MainWindow", "SFTP"))
        self.pushButton_GeneratngFoot.setText(_translate("MainWindow", "Load Original Image (Not Calibrated)"))
        self.radio_Single.setText(_translate("MainWindow", "Single"))
        self.radio_DOE.setText(_translate("MainWindow", "DOE"))
        self.lineEdit_DOE_ID.setText(_translate("MainWindow", "2100000"))
        self.radio_Manual.setText(_translate("MainWindow", "Manual"))
        self.lineEdit_0_Location.setText(_translate("MainWindow", "RND"))
        self.lineEdit_1_VT_Number.setText(_translate("MainWindow", "1024287"))
        self.lineEdit_3_VT_Serial.setText(_translate("MainWindow", "371"))
        self.lineEdit_2_VT_Revision.setText(_translate("MainWindow", "0"))
        self.lineEdit_4_Sim_Type.setText(_translate("MainWindow", "D101"))
        self.lineEdit_5_Sim_Num.setText(_translate("MainWindow", "1"))
        self.lineEdit_jobDir.setToolTip(_translate("MainWindow", "<html><head/><body><p>Working Directory (Full path)</p></body></html>"))
        self.lineEdit_jobDir.setText(_translate("MainWindow", "Working Directory"))
        self.lineEdit_jobFile.setToolTip(_translate("MainWindow", "<html><head/><body><p>Working file </p></body></html>"))
        self.lineEdit_jobFile.setText(_translate("MainWindow", "Working File"))
        self.lineEdit_patternMesh.setToolTip(_translate("MainWindow", "<html><head/><body><p>CUTE 2D mesh or Pattern Mesh (ptn)</p></body></html>"))
        self.lineEdit_patternMesh.setText(_translate("MainWindow", "Mesh 2D or Pattern"))
        self.lineEdit_smartFile.setToolTip(_translate("MainWindow", "<html><head/><body><p>SMART Input file</p></body></html>"))
        self.lineEdit_smartFile.setText(_translate("MainWindow", "Smart Input"))
        self.filename.setText(_translate("MainWindow", "Connect FTP or Open a file"))
        self.groupBox.setTitle(_translate("MainWindow", "Footprint Image"))
        self.radioButton_print1.setText(_translate("MainWindow", "Print 1"))
        self.radioButton_print2.setText(_translate("MainWindow", "Print 2"))
        self.radioButton_print3.setText(_translate("MainWindow", "Print 3"))
        self.radioButton_print4.setText(_translate("MainWindow", "Print 4"))
        self.radioButton_print5.setText(_translate("MainWindow", "Print 5"))
        self.groupBox_2.setTitle(_translate("MainWindow", "Boundary Image"))
        self.checkBox.setText(_translate("MainWindow", "Print 1"))
        self.checkBox_2.setText(_translate("MainWindow", "Print 2"))
        self.checkBox_3.setText(_translate("MainWindow", "Print 3"))
        self.checkBox_4.setText(_translate("MainWindow", "Print 4"))
        self.checkBox_5.setText(_translate("MainWindow", "Print 5"))
        self.pushButton_compare.setText(_translate("MainWindow", "Footprint Boundaries"))
        self.radio_PC.setText(_translate("MainWindow", "PC"))
        self.radioTB.setText(_translate("MainWindow", "TBR"))
        self.radioLT.setText(_translate("MainWindow", "LT"))
        self.pushButton_Redraw.setText(_translate("MainWindow", "ReDraw"))
        self.pushButton_Range.setText(_translate("MainWindow", "Re-Calculate"))
        self.label_min.setText(_translate("MainWindow", "Minimum"))
        self.lineEdit_min_colorRange.setText(_translate("MainWindow", "50000"))
        self.label_max.setText(_translate("MainWindow", "Maximum"))
        self.lineEdit_max_colorRange.setText(_translate("MainWindow", "500000"))
        self.pushPointSize.setText(_translate("MainWindow", "Points Size"))
        self.lineEdit_pointSize.setText(_translate("MainWindow", "1"))
        self.pushPointsDensity.setText(_translate("MainWindow", "Points Density"))
        self.lineEdit_PointsDensity.setText(_translate("MainWindow", "20"))
        self.push_Rotating.setText(_translate("MainWindow", "Rotate (Degree)"))
        self.lineEdit_rotating.setText(_translate("MainWindow", "0"))
        self.push_lateralShift.setText(_translate("MainWindow", "Lateral Shift(mm)"))
        self.lineEdit_lateralShift.setText(_translate("MainWindow", "0"))
        self.check_showFittingPoints.setText(_translate("MainWindow", "Show Points"))
        self.label_fittingOrder.setText(_translate("MainWindow", "Fitting Order"))
        self.lineEdit_fittingOrder.setText(_translate("MainWindow", "6"))
        self.check_ISLM_FPC.setText(_translate("MainWindow", "ISLM Original"))
        self.Blank_1.setToolTip(_translate("MainWindow", "<html><head/><body><p>Roundness = Total Contact Area / (Max Contact Length * Max Contact Width)</p></body></html>"))
        self.Blank_5.setToolTip(_translate("MainWindow", "<html><head/><body><p>Gullwing Global Shape Factor = 1 - Max Foot print Ratio (over Center 50% to 90% of footprint, FP Ratio = Length / Ctr Length)</p><p>Gullwing Local Shape Factor = Average Slope of shoulder Rib Leading Edge </p></body></html>"))
        self.Blank_6.setToolTip(_translate("MainWindow", "<html><head/><body><p>Roundness Shape Factor = 2nd order Polynomial Fit for center 50% of footprint (Roundness = Coef of 2nd-order Term)</p><p>Squareness Shape Factor = Footprint Max. Length / Footprint Max. Width </p></body></html>"))
        self.menuFILE.setTitle(_translate("MainWindow", "FILE"))
        self.actionOpen.setText(_translate("MainWindow", "Open sfric"))
        self.actionOpen.setShortcut(_translate("MainWindow", "Ctrl+O"))
        self.actionClose.setText(_translate("MainWindow", "Close"))
        self.actionClose.setShortcut(_translate("MainWindow", "Ctrl+C"))
        self.actionOpen_dat_from_sfric.setText(_translate("MainWindow", "Open dat from sfric"))
        self.actionOpen_dat_from_sfric.setShortcut(_translate("MainWindow", "Shift+O"))


    def writeSetting(self, default=False): 
        # "Hosts RND 10.82.66.65, ATC 10.1.1.22:3001, CTC 202.31.116.35:3001, ETC 192.168.202.4:3001"
        if 'h2' in self.lineEdit_hpc_ID.text().strip() : 
            self.lineEdit_address.setText("10.82.66.65")
        elif 'h4' in self.lineEdit_hpc_ID.text().strip() : 
            self.lineEdit_address.setText("10.1.1.22:3001")
        elif 'h8' in self.lineEdit_hpc_ID.text().strip() : 
            self.lineEdit_address.setText("202.31.116.35:3001")
        elif 'h7' in self.lineEdit_hpc_ID.text().strip() : 
            self.lineEdit_address.setText("192.168.202.4:3001")
        else: 
            self.lineEdit_address.setText("Input ID")
        
        if not default : 
            fp = open(self.settingFile, 'w') 
            fp.write("address=%s\n"%(self.lineEdit_address.text().strip()))
            fp.write("id=%s\n"%(self.lineEdit_hpc_ID.text().strip()))
            if self.radio_Single.isChecked(): fp.write("user=single\n") 
            elif self.radio_DOE.isChecked(): fp.write("user=doe\n") 
            else : fp.write("user=manual\n") 
            fp.write("doe=%s\n"%(self.lineEdit_DOE_ID.text()))
            fp.write("loc=%s\n"%(self.lineEdit_0_Location.text()))
            fp.write("vt=%s, %s, %s\n"%(self.lineEdit_1_VT_Number.text(), self.lineEdit_3_VT_Serial.text(), self.lineEdit_2_VT_Revision.text()))
            fp.write("sim=%s, %s\n"%(self.lineEdit_4_Sim_Type.text(), self.lineEdit_5_Sim_Num.text()))
            fp.write("wd=%s\n"%(self.lineEdit_jobDir.text()))
            fp.write("wf=%s\n"%(self.lineEdit_jobFile.text()))
            fp.write("ms=%s\n"%(self.lineEdit_patternMesh.text()))
            fp.write("sm=%s\n"%(self.lineEdit_smartFile.text()))
            if self.radio_PC.isChecked():  fp.write("grp=PCR\n")
            else: fp.write("grp=TBR\n")
            fp.write("vmin=%s\n"%(self.lineEdit_min_colorRange.text()))
            fp.write("vmax=%s\n"%(self.lineEdit_max_colorRange.text()))
            fp.write("size=%s\n"%(self.lineEdit_pointSize.text()))
            fp.write("density=%s\n"%(self.lineEdit_PointsDensity.text()))
            fp.write("angle=%s\n"%(self.lineEdit_rotating.text()))
            fp.write("fitting=%s\n"%(self.lineEdit_fittingOrder.text()))
            fp.write("dir=%s\n"%(self.cwd))
            fp.close()
        else: 
            fp = open(self.settingFile, 'w') 
            fp.write("address=10.85.66.65\n")
            fp.write("id=h2..\n")
            fp.write("user=single\n")
            fp.write("doe=2100000\n")
            fp.write("loc=RND\n")
            fp.write("vt=1024287, 371, 0\n")
            fp.write("sim=D101, 3\n")
            fp.write("wd=Working Directory\n")
            fp.write("wf=Working File\n")
            fp.write("ms=Mesh 2D or Pattern Mesh\n")
            fp.write("sm=Smart Input File\n")
            fp.write("grp=PCR\n")
            fp.write("val=press\n")
            fp.write("tp=contour\n")
            fp.write("vmin=50000\n")
            fp.write("vmax=500000\n")
            fp.write("size=1.0\n")
            fp.write("density=20\n")
            fp.write("angle=0\n")
            fp.write("fitting=6\n")
            cwd = getcwd()
            self.cwd = getCWD(cwd)
            fp.write("dir=%s\n"%(cwd))
            fp.close()
    def readSetting(self): 
        with open(self.settingFile) as SF: 
            lines = SF.readlines()
        for line in lines: 
            wd = line.split("=")[1]
            if 'address=' in line: 
                self.lineEdit_address.setText(wd.strip())
            if 'id=' in line: 
                self.lineEdit_hpc_ID.setText(wd.strip())
            if 'user=' in line: 
                if 'single' in line: self.radio_Single.setChecked(True)
                elif 'doe' in line:  self.radio_DOE.setChecked(True)
                else: self.radio_Manual.setChecked(True)
            if 'doe=' in line: 
                self.lineEdit_DOE_ID.setText(wd.strip())
            if 'loc=' in line: self.lineEdit_0_Location.setText(wd.strip())
            if "vt=" in line: 
                w = wd.split(",")
                self.lineEdit_1_VT_Number.setText(w[0].strip())
                self.lineEdit_3_VT_Serial.setText(w[1].strip())
                self.lineEdit_2_VT_Revision.setText(w[2].strip())
            if "sim=" in line:
                w = wd.split(",") 
                self.lineEdit_4_Sim_Type.setText(w[0].strip())
                self.lineEdit_5_Sim_Num.setText(w[1].strip())
            if "wd=" in line: 
                self.lineEdit_jobDir.setText(wd.strip())
            if "wf=" in line: 
                self.lineEdit_jobFile.setText(wd.strip())
            if "ms=" in line: 
                self.lineEdit_patternMesh.setText(wd.strip())
            if "sm=" in line: 
                self.lineEdit_smartFile.setText(wd.strip())
            if "grp=" in line: 
                if 'PC' in wd:  self.radio_PC.setChecked(True)
                else: self.radioTB.setChecked(True)
            if "vmin=" in line: 
                self.lineEdit_min_colorRange.setText(wd.strip())
            if "vmax=" in line: 
                self.lineEdit_max_colorRange.setText(wd.strip())
            if "size=" in line: 
                self.lineEdit_pointSize.setText(wd.strip())
            if "density=" in line: 
                self.lineEdit_PointsDensity.setText(wd.strip())
            if "angle=" in line: 
                self.lineEdit_rotating.setText(wd.strip())
            if "fitting=" in line: 
                self.lineEdit_fittingOrder.setText(wd.strip())
            if "dir=" in line: 
                self.cwd = wd.strip()

    def getRemoteFiles(self, workingDirectory, simulationID, manual=True): 
        jobFile =None 
        if workingDirectory[-1]!="/": workingDirectory+="/"

        try: 
            dirList =self.sftp.listdir(workingDirectory)
        except: 
            print ("No files in the directory : ", workingDirectory)
            return 

        for name in dirList: 
            if "-postfoot.dat" in name: 
                jobFile = makingFullFilePath_linux(workingDirectory, name )
                self.lineEdit_jobFile.setText(name)
                self.sftp.get(jobFile, self.localDat)
                print ("** COPIED: ", jobFile.split("/")[-1])
                break 
        else: 
            subdir = workingDirectory + "SFRIC." + simulationID +"/"
            subdirList = self.sftp.listdir(subdir)
            subdirList = sorted(subdirList)
            jobFile = makingFullFilePath_linux(subdir, subdirList[-1])
            self.lineEdit_jobFile.setText(subdirList[-1])

            if not ("sfric" != jobFile[:-5] and '.sfric' in jobFile) : 
                self.filename.setText("Footprint result was not found.")
                self.fn -= 1
                return 
            self.sftp.get(jobFile[:-3], self.localSfric)
            self.sftp.get(jobFile, self.localSfricResult)
            print ("** COPIED: ", self.localSfric.split("/")[-1])
            print ("** COPIED: ", self.localSfricResult.split("/")[-1])

        if manual: 
            ptnMesh = self.lineEdit_patternMesh.text().strip()
            ptnMesh = makingFullFilePath_linux(workingDirectory, ptnMesh)
            if ".ptn" in ptnMesh:   
                self.sftp.get(ptnMesh, self.localPtn)
                axi = getAXI_filename_SMARTInput(self.localSMART)
                self.sftp.get(axi, self.localAxi)
                LayoutMesh_From_axi(axi=self.localAxi, output=self.localMesh)
                print ("* Mesh 2d Generated Copied : ", axi.split("/")[-1])

            elif '.inp' in ptnMesh: 
                self.sftp.get(ptnMesh, self.localMesh)
                print ("** COPIED: ", ptnMesh.split("/")[-1])
            else: 
                if not isfile(self.localSMART): 
                    print (" NO SMART INPUT")
                axi = getAXI_filename_SMARTInput(self.localSMART)
                if not axi: 
                    print ("* NO FOUND AXI FILE NAME", axi)
                axi = makingFullFilePath_linux(workingDirectory, axi)
                self.sftp.get(axi, self.localAxi)
                LayoutMesh_From_axi(axi=self.localAxi, output=self.localMesh)
                print ("* Mesh 2d Generated Copied : %s to %s"%(axi.split("/")[-1], self.localMesh))
        else: 
            for name in dirList:
                if ".ptn" in name: 
                    ptnMesh = makingFullFilePath_linux(workingDirectory, name)
                    self.sftp.get(ptnMesh, self.localPtn)
                    axi = getAXI_filename_SMARTInput(self.localSMART)
                    self.sftp.get(axi, self.localAxi)
                    print ("** COPIED: ", axi.split("/")[-1])
                    LayoutMesh_From_axi(axi=self.localAxi, output=self.localMesh)
            else: 
                localPtn = None 
                for name in dirList:
                    if '.inp' in name: 
                        if check2DMesh_File: 
                            mesh2d = makingFullFilePath_linux(workingDirectory, name)
                            self.sftp.get(mesh2d, self.localMesh)
                            print ("** COPIED: ", mesh2d.split("/")[-1])
                            if check2DMesh_File(self.localMesh): 
                                break 
                else: 
                    self.localMesh = None 
        
        try: remove(self.localISLMPoints)
        except: pass 
        for name in dirList: 
            if "-ContactShapePoint_Original.dat" in name: 
                ISLM_boundary_points = makingFullFilePath_linux(workingDirectory, name)
                self.sftp.get(ISLM_boundary_points, self.localISLMPoints)
                print ("** COPIED: ", name)
                break 
        try: remove(self.localISLMFPC)
        except: pass 
        for name in dirList: 
            if "-FPC_Original.txt" in name: 
                ISLM_FPC = makingFullFilePath_linux(workingDirectory, name)
                self.sftp.get(ISLM_FPC, self.localISLMFPC)
                print ("** COPIED: ", name)
                break 
        try: remove(self.localDeformed)
        except: pass 
        for name in dirList: 
            if "-Deformed_BTM.inp" in name: 
                ISLM_DFM = makingFullFilePath_linux(workingDirectory, name)
                self.sftp.get(ISLM_DFM, self.localDeformed)
                print ("** COPIED: ", name)
                break 
        return jobFile 
        
def checkSMART_File(file): 

    with open(file) as F: 
        lines = F.readlines()
    checks=[False, False, False]
    for line in lines: 
        if "*SIMULATION_TYPE" in line.upper(): checks[0] = True 
        if "*SIMULATION_TIME" in line.upper(): checks[1] = True 
        if "*SURFACES_FOR_CONTACT_AND_LOAD" in line.upper(): checks[2] = True 
    if checks[0] and checks[1] and checks[2]: 
        return True 
    else: 
        return False 
def getAXI_filename_SMARTInput(smartInput): 
    with open(smartInput) as IN: 
        lines = IN.readlines()
    for line in lines: 
        line = line.strip()
        if "*INCLUDE" in line.upper() and "INP=" in line.upper() and '.axi' == line[-4:].lower(): 
            return  line.split("=")[1].strip()
    return 

def check2DMesh_File(file): 
    with open(file) as F: 
        lines = F.readlines()
    checks=[False, False, False]
    for line in lines: 
        if "*ELEMENT" in line.upper() and "TYPE=CGAX4" in line.upper(): 
            checks[0] = True 
        if "*ELEMENT" in line.upper() and "TYPE=MGAX1" in line.upper(): 
            checks[1] = True 
        if "*SURFACE" in line.upper() and "TYPE=ELEMENT" in line.upper() and "NAME=CONT" in line.upper(): 
            checks[2] = True 
    if checks[0] and checks[1] and checks[2]: 
        return True 
    else: 
        return False 

class myCanvas(FigureCanvas):
    def __init__(self, parent=None, *args, **kwargs):
        self.figure = plt.figure()
        FigureCanvas.__init__(self, self.figure)
        self.setParent(parent)
        self.canvas = FigureCanvas(self.figure)
        self.toolbar = NavigationToolbar(self.canvas,self)

        self.xs=[]; self.ys=[]
        self.mclick=0; self.clicked = 0 
        self.dots=[];   self.circle=[];     self.chars=[]; self.lines=[]
        self.achars=[]; self.cline=[]; self.llen=[] 
        self.distance=0 
        self.fpcLine=[]
        self.fpcArea=[]
        self.fpcTexts=[]

        self.fontsize = 10
    def Area(self, ix=[], iy=[]): 
        x =[]; y=[]
        for px, py in zip(ix, iy):
            x.append(px)
            y.append(py)
        x.append(ix[0]); y.append(iy[0])

        A = [0.0, 0.0, 0.0]

        n = len(x)-1

        for i in range(n):
            s = x[i] * y[i + 1] - x[i + 1] * y[i]
            A[0] += s
            A[1] += (x[i] + x[i + 1]) * s
            A[2] += (y[i] + y[i + 1]) * s

        A[0] = A[0] / 2.0


        return A[0]

    def onReleased(self, event): 

        if event.button == 2: 
            self.mclick += 1

            if self.mclick == 4: 
                self.xs=[]
                self.ys=[]
                self.mclick=0
                for dot in self.dots:
                    dot.remove()
                self.dots=[]

                for char in self.chars: 
                    char.set_visible(False)

                for cl in self.circle:
                    cl.remove()

                self.circle=[]
            
            elif self.mclick ==3:
                self.xs.append(event.xdata)
                self.ys.append(event.ydata)
                d, = plt.plot(event.xdata, event.ydata, 'o', color='gray')
                self.dots.append(d)
                

                x1 = self.xs[0]; x2=self.xs[1]; x3=self.xs[2]
                y1 = self.ys[0]; y2=self.ys[1]; y3=self.ys[2]
                A = x1*(y2-y3) - y1 *(x2-x3) + x2*y3 - x3*y2
                B = (x1*x1 + y1*y1)*(y3-y2) +(x2**2 + y2**2)*(y1-y3) + (x3**2+y3**2)*(y2-y1)
                C = (x1**2 + y1**2)*(x2-x3)+(x2**2+y2**2)*(x3-x1) + (x3*x3 + y3*y3)*(x1-x2)
                D = (x1*x1 + y1*y1)*(x3*y2-x2*y3)+(x2*x2+y2*y2)*(x1*y3-x3*y1)+(x3*x3+y3*y3)*(x2*y1-x1*y2)

                cx = -B/A/2.0
                cy = -C/A/2.0
                R = math.sqrt(B*B + C*C - 4*A*D) / 2/abs(A)

                self.xs.append(event.xdata)
                self.ys.append(event.ydata)
                d, = plt.plot(cx, cy, 'o', color='red')
                self.dots.append(d)

                ch = plt.text((self.xs[0]+self.xs[1])/2.0, (self.ys[0]+self.ys[1])/2.0, "R="+str(round(R*1000, 2)), size=self.fontsize, color='black')
                self.chars.append(ch)

                crcl = plt.Circle((cx, cy), R, color='gray', fill=False)
                self.ax.add_artist(crcl)
                self.circle.append(crcl)

            else:
                self.xs.append(event.xdata)
                self.ys.append(event.ydata)
                d, = plt.plot(event.xdata, event.ydata, 'o', color='gray')
                self.dots.append(d)

            current_xlim=self.ax.get_xlim()
            current_ylim=self.ax.get_ylim()
            plt.xlim(current_xlim[0], current_xlim[1])
            plt.ylim(current_ylim[0], current_ylim[1])
            self.figure.canvas.draw_idle()

        elif event.button == 1: 
            self.clicked =0  
            self.mclick = 0
            self.xs=[];           self.ys=[]

            for dot in self.dots: 
                dot.remove()
            for line in self.lines: 
                line.remove()
            for char in self.chars: 
                char.set_visible(False)
            for char in self.achars: 
                char.set_visible(False)
            for cl in self.cline: 
                cl.remove()
            for ch in self.llen:
                ch.set_visible(False)
            for cl in self.circle:
                cl.remove()

            self.circle=[]
            self.dots=[];      self.lines=[];        self.chars=[];        self.achars=[]
            self.cline=[];     self.llen=[]

            current_xlim=self.ax.get_xlim()
            current_ylim=self.ax.get_ylim()
            plt.xlim(current_xlim[0], current_xlim[1])
            plt.ylim(current_ylim[0], current_ylim[1])
            self.figure.canvas.draw_idle()
        elif event.button ==3:
            self.clicked += 1
            self.xs.append(event.xdata)
            self.ys.append(event.ydata)
            d, = plt.plot(event.xdata, event.ydata, 'o', color='red')
            self.dots.append(d)
            N = len(self.xs)-1
            if N> 0: 
                self.distance = round( math.sqrt((self.xs[N]-self.xs[N-1])**2 + (self.ys[N]-self.ys[N-1])**2 ) *1000, 2)
                ch = plt.text((self.xs[N]+self.xs[N-1])/2.0, (self.ys[N]+self.ys[N-1])/2.0, str(self.distance), size=self.fontsize)
                self.chars.append(ch)

                ln, = plt.plot([self.xs[N-1], self.xs[N]],[self.ys[N-1], self.ys[N]], color='orange')
                self.lines.append(ln)

                if self.clicked > 2: 

                    sx = 0; sy=0
                    for x, y in zip(self.xs, self.ys): 
                        sx += x
                        sy += y
                    cx = sx/(float(N)+1)
                    cy = sy/(float(N)+1)

                    area = self.Area(ix=self.xs, iy=self.ys)
                    for achar in self.achars: 
                        achar.set_visible(False)
                    self.figure.canvas.draw_idle()
                    ach= plt.text(cx, cy, "A="+ str(round(area*1_000_000, 1)), color='gray', size=self.fontsize)
                    self.achars.append(ach)

                    for char in self.llen:
                        char.set_visible(False)

                    for line in self.cline: 
                        line.remove()
                    self.cline=[]
                    
                    self.distance = round( math.sqrt((self.xs[N]-self.xs[0])**2 + (self.ys[N]-self.ys[0])**2 ) *1000, 2)
                    ch = plt.text((self.xs[N]+self.xs[0])/2.0, (self.ys[N]+self.ys[0])/2.0, str(self.distance), color='gray', size=self.fontsize)
                    self.llen.append(ch)

                    ln, = plt.plot([self.xs[0], self.xs[N]],[self.ys[0], self.ys[N]], color='gray', linestyle="--" )
                    self.cline.append(ln)
            current_xlim=self.ax.get_xlim()
            current_ylim=self.ax.get_ylim()
            plt.xlim(current_xlim[0], current_xlim[1])
            plt.ylim(current_ylim[0], current_ylim[1])
            self.figure.canvas.draw_idle()

    def plotComparing(self, pts): 
        colors = ['black', 'red', 'blue', 'green', 'orange', 'gray']
        self.figure.clear()
        self.ax = self.figure.add_subplot(111)
        self.ax.axis('equal')
        plt.xlim(-0.25, 0.25)
        size = 3
        m = 0 
        N = len(colors)
        for pt in pts: 
            self.ax.scatter(pt[0], pt[1], c=colors[m], s=size, edgecolors=None, linewidths=0.0)
            m += 1 
            if m >=N : 
                m -= N 
        self.figure.canvas.mpl_connect('button_release_event', self.onReleased)
        self.figure.tight_layout()
        self.figure.canvas.draw()

    def Plotting(self, xs=None, ys=None, pv=None, **args) :
        ## points = plt.scatter(px, py, c=pv, s=size, cmap=cmap, vmin=vmin, vmax=vmin*10, edgecolors=None, linewidths=0.0 )
        vmin = 50000; vmax = 500000
        size = 0.3 ; cmap = 'rainbow'
        for key, value in args.items(): 
            if key == 'vmin': vmin = value 
            if key == 'vmax': vmax = value 
            if key == 'size': size = value 
            if key == 'cmap': cmap = value 
        self.figure.clear()
        self.ax = self.figure.add_subplot(111)
        self.ax.axis('equal')
        
        
        self.ax.scatter(xs, ys, c=pv, s=size, cmap=cmap, vmin=vmin, vmax=vmax, edgecolors=None, linewidths=0.0)
        lim = 0.25
        self.ax.scatter([lim, lim, -lim, -lim], [-lim, lim, lim, -lim], edgecolors=None, linewidths=0.0, c='gray', s=0.01)

        self.figure.canvas.mpl_connect('button_release_event', self.onReleased)
        self.figure.tight_layout()
        # plt.xlim(-0.25, 0.25)
        self.figure.canvas.draw()
        
        print ("***************************************")
        print (" Min Pressure to plot : %.1EPa"%(vmin))
        print (" No. of points : %dEA"%(len(pv)))
        print (" Color Range = %.1E ~ %.1E"%(vmin, vmax))
        print (" Color map =%s"%(cmap))
        print (" Point size=%.2f"%(size))
        print ("***************************************")

    def addPoints(self, points=None, lines=None, lw=1, size=0.3): 
        if isinstance(points, type(None)): 
            return 
        try: 
            self.removePoints(action=False)
        except: 
            pass 

        xs = points[0]
        ys = points[1]

        self.fpcArea, = plt.plot(xs,ys, color='black', linewidth=lw, marker="o", markersize=size)
        if not isinstance(lines, type(None)): 
            cnt = 0 
            for line in lines: 
                ln, = plt.plot(line[0], line[1], color='blue', lw=0.5)
                self.fpcLine.append(ln)
                if cnt %2:  
                    ch = plt.text(line[2][0], line[2][1], line[2][2], size=8)
                    self.fpcTexts.append(ch)
                cnt += 1

        current_xlim=self.ax.get_xlim()
        current_ylim=self.ax.get_ylim()
        plt.xlim(current_xlim[0], current_xlim[1])
        plt.ylim(current_ylim[0], current_ylim[1])

        self.figure.canvas.draw_idle()

    def removePoints(self, action=True): 
        self.fpcArea.remove()
        for ln in self.fpcLine: 
            try: 
                ln.remove()
            except: 
                continue 
        for txt in self.fpcTexts: 
            txt.set_visible(False)
        if action : 
            current_xlim=self.ax.get_xlim()
            current_ylim=self.ax.get_ylim()
            plt.xlim(current_xlim[0], current_xlim[1])
            plt.ylim(current_ylim[0], current_ylim[1])
            self.figure.canvas.draw_idle()



class Tee(object):
     def __init__(self, *files):
         self.files = files
     def write(self, obj):
         for f in self.files:
             f.write(obj.encode('utf-8'))

if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()

    sys.exit(app.exec_())




# 

# Characteristic Evaluation Project  .

## min - max     ( download  )
# PCR  1 ~ 6 LTR: 1 ~ 8, TBR 1 ~ 12 
# 

# iPFS(Image Processing FootShape)    .


# 2.4.0       .

#   1)  Raw data 

#       ( Raw data  )


# : \\202.31.56.99\iPFS

# : \\202.31.56.99\iPFS\ iPFS Setup\iPFS (v2.4.0  )

# : \\202.31.56.99\iPFS\ iPFS Setup\Manual


#  -  

# ID : nasad1.com\iPFSREAD

# PW : #%0FNy5G


#   1.  1        .

#   2. DB    pdf   manual  .


#             ,
#        .

#   - Characteristic Evaluation Project  (77-1767), (77-1752)
